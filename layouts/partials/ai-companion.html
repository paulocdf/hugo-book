<!-- AI Companion: In-browser LLM via WebLLM (Qwen2.5-0.5B) -->
<!-- Floating side panel + engine management. Requires dm-sync for task context. -->

<!-- Floating side panel (appended positioning — lives outside .book-page to avoid will-change issues) -->
<div class="ai-panel" id="ai-panel" style="display:none;" role="dialog" aria-label="AI Companion">
  <div class="ai-panel-header">
    <div class="ai-panel-title">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275L21 12l-5.813 1.912a2 2 0 0 0-1.275 1.275L12 21l-1.912-5.813a2 2 0 0 0-1.275-1.275L3 12l5.813-1.912a2 2 0 0 0 1.275-1.275L12 3z"></path>
      </svg>
      <span>AI Companion</span>
      <span class="ai-panel-status" id="ai-panel-status"></span>
    </div>
    <div class="ai-panel-header-actions">
      <button type="button" class="ai-panel-btn" id="ai-settings-btn" title="Settings" aria-label="Settings">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
      </button>
      <button type="button" class="ai-panel-btn" id="ai-clear-btn" title="Clear chat" aria-label="Clear chat">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
      </button>
      <button type="button" class="ai-panel-btn ai-panel-close" id="ai-panel-close" title="Close (Esc)" aria-label="Close">&times;</button>
    </div>
  </div>

  <!-- Settings panel (hidden by default) -->
  <div class="ai-settings" id="ai-settings" style="display:none;">
    <div class="ai-settings-row">
      <span class="ai-settings-label">AI Companion</span>
      <label class="ai-toggle-switch">
        <input type="checkbox" id="ai-enabled-toggle">
        <span class="ai-toggle-slider"></span>
      </label>
    </div>
    <div class="ai-settings-info">
      <p>Uses <strong>Qwen2.5-0.5B</strong> running entirely in your browser via WebGPU.</p>
      <p>First use downloads ~350 MB (cached for future visits). Requires ~1 GB GPU memory.</p>
    </div>
    <div class="ai-settings-row" id="ai-webgpu-status-row">
      <span class="ai-settings-label">WebGPU</span>
      <span class="ai-settings-value" id="ai-webgpu-status">Checking...</span>
    </div>
    <div class="ai-settings-row" id="ai-model-status-row" style="display:none;">
      <span class="ai-settings-label">Model</span>
      <span class="ai-settings-value" id="ai-model-status">Not loaded</span>
    </div>
    <button type="button" class="ai-settings-unload" id="ai-unload-btn" style="display:none;">Unload model (free GPU memory)</button>
    <div class="ai-settings-context">
      <label class="ai-settings-label" for="ai-custom-context">Custom context</label>
      <p class="ai-settings-context-hint">Add personal context or instructions to make the AI more useful (e.g. your role, preferences, goals).</p>
      <textarea class="ai-custom-context" id="ai-custom-context" placeholder="e.g. I'm a software engineer. I prefer short actionable tasks. My work hours are 9am-6pm." rows="3"></textarea>
      <div class="ai-settings-context-actions">
        <span class="ai-settings-context-saved" id="ai-context-saved" style="display:none;">Saved</span>
      </div>
    </div>
  </div>

  <!-- Download progress (shown during first model load) -->
  <div class="ai-download" id="ai-download" style="display:none;">
    <div class="ai-download-text" id="ai-download-text">Preparing AI model...</div>
    <div class="ai-download-bar">
      <div class="ai-download-fill" id="ai-download-fill" style="width:0%"></div>
    </div>
    <div class="ai-download-detail" id="ai-download-detail"></div>
  </div>

  <!-- Quick actions -->
  <div class="ai-quick-actions" id="ai-quick-actions">
    <button type="button" class="ai-quick-btn" data-action="plan">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
      Plan my day
    </button>
    <button type="button" class="ai-quick-btn" data-action="suggest">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
      Suggest tasks
    </button>
    <button type="button" class="ai-quick-btn" data-action="improve">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
      Improve text
    </button>
    <button type="button" class="ai-quick-btn" data-action="summarize">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line></svg>
      Summarize
    </button>
  </div>

  <!-- Chat messages -->
  <div class="ai-messages" id="ai-messages">
    <div class="ai-welcome" id="ai-welcome">
      <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="var(--accent-ai)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275L21 12l-5.813 1.912a2 2 0 0 0-1.275 1.275L12 21l-1.912-5.813a2 2 0 0 0-1.275-1.275L3 12l5.813-1.912a2 2 0 0 0 1.275-1.275L12 3z"></path>
      </svg>
      <p>I can help you plan your day, suggest tasks, improve text, or answer questions about your tasks.</p>
      <p class="ai-welcome-hint">Use the quick actions above or type a message below.</p>
    </div>
  </div>

  <!-- Input area -->
  <div class="ai-input-area" id="ai-input-area">
    <div class="ai-mode-badge" id="ai-mode-badge" style="display:none;">
      <span id="ai-mode-badge-text"></span>
      <button type="button" class="ai-mode-badge-cancel" id="ai-mode-badge-cancel" aria-label="Cancel mode">&times;</button>
    </div>
    <div class="ai-input-wrap">
      <textarea class="ai-input" id="ai-input" placeholder="Ask me anything..." rows="1"></textarea>
      <button type="button" class="ai-mic-btn" id="ai-mic-btn" title="Voice input" aria-label="Voice input" style="display:none;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
      </button>
      <button type="button" class="ai-send-btn" id="ai-send-btn" title="Send" aria-label="Send" disabled>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
      </button>
    </div>
    <div class="ai-input-hint">
      <span><kbd>Enter</kbd> send &middot; <kbd>Shift+Enter</kbd> newline</span>
      <button type="button" class="ai-stop-btn" id="ai-stop-btn" style="display:none;">Stop</button>
    </div>
  </div>

  <!-- Not supported message -->
  <div class="ai-not-supported" id="ai-not-supported" style="display:none;">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="var(--gray-400)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"></circle>
      <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
    </svg>
    <p>WebGPU is not supported in your browser.</p>
    <p class="ai-not-supported-hint">AI Companion requires Chrome 113+ or Edge 113+ with WebGPU enabled.</p>
  </div>
</div>

<style>
/* ─── AI Side Panel ─── */
.ai-panel {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 400px;
  max-width: 100vw;
  z-index: 1200;
  background: var(--body-background);
  border-left: 1px solid var(--gray-200);
  box-shadow: -4px 0 24px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  animation: ai-panel-in 0.25s ease-out;
}
@keyframes ai-panel-in {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
.ai-panel.closing {
  animation: ai-panel-out 0.2s ease-in forwards;
}
@keyframes ai-panel-out {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}

/* Header */
.ai-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--gray-200);
  flex-shrink: 0;
}
.ai-panel-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
  font-weight: 700;
  color: var(--body-font-color);
}
.ai-panel-title svg {
  color: var(--accent-ai);
}
.ai-panel-status {
  font-size: 0.68rem;
  font-weight: 500;
  padding: 2px 8px;
  border-radius: 10px;
  display: none;
}
.ai-panel-status.ready {
  display: inline-block;
  background: var(--color-success-bg);
  color: var(--color-success);
}
.ai-panel-status.loading {
  display: inline-block;
  background: rgba(0, 105, 255, 0.08);
  color: var(--color-link);
}
.ai-panel-status.error {
  display: inline-block;
  background: var(--color-danger-bg);
  color: var(--color-danger);
}
.ai-panel-header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}
.ai-panel-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 30px;
  height: 30px;
  border: 1px solid transparent;
  border-radius: 8px;
  background: none;
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.2s, background 0.2s, border-color 0.2s;
  line-height: 0;
}
.ai-panel-btn:hover {
  color: var(--body-font-color);
  background: var(--gray-200);
  border-color: var(--gray-300);
}
.ai-panel-close {
  font-size: 1.4rem;
  font-weight: 300;
}

/* ─── Settings panel ─── */
.ai-settings {
  padding: 12px 16px;
  border-bottom: 1px solid var(--gray-200);
  flex-shrink: 0;
  animation: ai-settings-in 0.15s ease-out;
}
@keyframes ai-settings-in {
  from { opacity: 0; max-height: 0; }
  to { opacity: 1; max-height: 300px; }
}
.ai-settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
}
.ai-settings-label {
  font-size: 0.82rem;
  font-weight: 600;
  color: var(--body-font-color);
}
.ai-settings-value {
  font-size: 0.78rem;
  color: var(--gray-500);
}
.ai-settings-info {
  padding: 8px 0;
  font-size: 0.75rem;
  color: var(--gray-500);
  line-height: 1.5;
}
.ai-settings-info p {
  margin: 0 0 4px;
}
.ai-settings-unload {
  width: 100%;
  padding: 8px;
  margin-top: 8px;
  border: 1px solid var(--color-danger);
  border-radius: 8px;
  background: var(--color-danger-bg);
  color: var(--color-danger);
  font-size: 0.78rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}
.ai-settings-unload:hover {
  background: var(--color-danger);
  color: #fff;
}

/* Toggle switch */
.ai-toggle-switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 22px;
}
.ai-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.ai-toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--gray-300);
  border-radius: 22px;
  transition: background 0.2s;
}
.ai-toggle-slider::before {
  content: '';
  position: absolute;
  height: 16px;
  width: 16px;
  left: 3px;
  bottom: 3px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s;
}
.ai-toggle-switch input:checked + .ai-toggle-slider {
  background: var(--accent-ai);
}
.ai-toggle-switch input:checked + .ai-toggle-slider::before {
  transform: translateX(18px);
}

/* ─── Download progress ─── */
.ai-settings-context {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--gray-200);
}
.ai-settings-context-hint {
  font-size: 0.72rem;
  color: var(--text-secondary, var(--gray-500));
  margin: 4px 0 8px 0;
  line-height: 1.4;
}
.ai-custom-context {
  width: 100%;
  font-size: 0.8rem;
  font-family: inherit;
  line-height: 1.4;
  padding: 8px 10px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--body-font-color);
  resize: vertical;
  min-height: 60px;
  max-height: 150px;
  box-sizing: border-box;
}
.ai-custom-context:focus {
  outline: none;
  border-color: var(--accent-ai);
  box-shadow: 0 0 0 2px rgba(0, 188, 180, 0.15);
}
.ai-custom-context::placeholder {
  color: var(--gray-400);
  font-size: 0.75rem;
}
.ai-settings-context-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: 4px;
  min-height: 18px;
}
.ai-settings-context-saved {
  font-size: 0.7rem;
  color: var(--color-success, #34a853);
  font-weight: 500;
}
.ai-download {
  padding: 16px;
  border-bottom: 1px solid var(--gray-200);
  flex-shrink: 0;
}
.ai-download-text {
  font-size: 0.82rem;
  font-weight: 600;
  color: var(--body-font-color);
  margin-bottom: 8px;
}
.ai-download-bar {
  height: 6px;
  border-radius: 3px;
  background: var(--gray-200);
  overflow: hidden;
}
.ai-download-fill {
  height: 100%;
  border-radius: 3px;
  background: var(--accent-ai);
  transition: width 0.3s ease;
}
.ai-download-detail {
  font-size: 0.7rem;
  color: var(--gray-500);
  margin-top: 6px;
}

/* ─── Quick Actions ─── */
.ai-quick-actions {
  display: flex;
  gap: 6px;
  padding: 10px 16px;
  border-bottom: 1px solid var(--gray-200);
  flex-shrink: 0;
  flex-wrap: wrap;
}
.ai-quick-btn {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 5px 10px;
  border: 1px solid var(--gray-200);
  border-radius: 16px;
  background: var(--body-background);
  color: var(--body-font-color);
  font-size: 0.73rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s, color 0.15s;
  white-space: nowrap;
}
.ai-quick-btn:hover {
  background: var(--ai-accent-bg, rgba(0, 150, 136, 0.08));
  border-color: var(--accent-ai);
  color: var(--accent-ai);
}
.ai-quick-btn svg {
  flex-shrink: 0;
}

/* ─── Chat Messages ─── */
.ai-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.ai-welcome {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 2rem 1rem;
  color: var(--gray-500);
  flex: 1;
}
.ai-welcome p {
  margin: 8px 0 0;
  font-size: 0.82rem;
  line-height: 1.5;
  max-width: 280px;
}
.ai-welcome-hint {
  font-size: 0.72rem !important;
  color: var(--gray-400) !important;
}

/* Message bubbles */
.ai-msg {
  display: flex;
  gap: 10px;
  animation: ai-msg-in 0.2s ease-out;
}
@keyframes ai-msg-in {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}
.ai-msg-user {
  flex-direction: row-reverse;
}
.ai-msg-avatar {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 700;
}
.ai-msg-user .ai-msg-avatar {
  background: var(--color-link);
  color: #fff;
}
.ai-msg-assistant .ai-msg-avatar {
  background: var(--accent-ai);
  color: #fff;
}
.ai-msg-bubble {
  max-width: 85%;
  padding: 8px 12px;
  border-radius: 12px;
  font-size: 0.82rem;
  line-height: 1.55;
  word-break: break-word;
}
.ai-msg-user .ai-msg-bubble {
  background: var(--color-link);
  color: #fff;
  border-bottom-right-radius: 4px;
}
.ai-msg-assistant .ai-msg-bubble {
  background: var(--gray-100);
  color: var(--body-font-color);
  border-bottom-left-radius: 4px;
}
.ai-msg-bubble p {
  margin: 0 0 6px;
}
.ai-msg-bubble p:last-child {
  margin-bottom: 0;
}
.ai-msg-bubble ul, .ai-msg-bubble ol {
  margin: 4px 0;
  padding-left: 1.2em;
}
.ai-msg-bubble li {
  margin: 2px 0;
}
.ai-msg-bubble code {
  background: var(--code-bg);
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 0.78rem;
}
.ai-msg-bubble strong {
  font-weight: 600;
}

/* Code blocks */
.ai-code-block {
  margin: 6px 0;
  padding: 10px 12px;
  border-radius: 6px;
  background: var(--code-bg, #f6f8fa);
  overflow-x: auto;
  font-size: 0.75rem;
  line-height: 1.5;
}
.ai-code-block code {
  background: none;
  padding: 0;
  border-radius: 0;
  font-size: inherit;
}
.ai-msg-bubble h3,
.ai-msg-bubble h4,
.ai-msg-bubble h5,
.ai-msg-bubble h6 {
  margin: 8px 0 4px;
  font-size: 0.85rem;
  font-weight: 700;
}
.ai-msg-bubble hr {
  border: none;
  border-top: 1px solid var(--gray-200);
  margin: 8px 0;
}

/* Streaming cursor */
.ai-msg-bubble.streaming::after {
  content: '';
  display: inline-block;
  width: 2px;
  height: 0.9em;
  background: var(--accent-ai);
  margin-left: 2px;
  vertical-align: text-bottom;
  animation: ai-cursor-blink 0.8s step-end infinite;
}
@keyframes ai-cursor-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

/* Typing indicator */
.ai-typing {
  display: flex;
  gap: 4px;
  padding: 4px 0;
}
.ai-typing-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--gray-400);
  animation: ai-typing-bounce 1.2s ease-in-out infinite;
}
.ai-typing-dot:nth-child(2) { animation-delay: 0.15s; }
.ai-typing-dot:nth-child(3) { animation-delay: 0.3s; }
@keyframes ai-typing-bounce {
  0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
  30% { transform: translateY(-6px); opacity: 1; }
}

/* Task suggestion cards */
.ai-task-card {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  margin: 4px 0;
  border: 1px solid var(--gray-200);
  border-radius: 8px;
  background: var(--body-background);
  transition: background 0.15s;
}
.ai-task-card:hover {
  background: var(--gray-100);
}
.ai-task-card-title {
  flex: 1;
  font-size: 0.8rem;
  font-weight: 500;
}
.ai-task-card-add {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border: 1px solid var(--accent-ai);
  border-radius: 6px;
  background: none;
  color: var(--accent-ai);
  cursor: pointer;
  font-size: 1rem;
  line-height: 0;
  transition: background 0.15s, color 0.15s;
  flex-shrink: 0;
}
.ai-task-card-add:hover {
  background: var(--accent-ai);
  color: #fff;
}
.ai-task-card-added {
  font-size: 0.72rem;
  color: var(--color-success);
  font-weight: 500;
}

/* Copy button in messages */
.ai-copy-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  margin-top: 6px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--gray-500);
  font-size: 0.7rem;
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s;
}
.ai-copy-btn:hover {
  color: var(--body-font-color);
  border-color: var(--gray-300);
}
.ai-copy-btn.copied {
  color: var(--color-success);
  border-color: var(--color-success);
}

/* ─── Input Area ─── */
.ai-input-area {
  padding: 12px 16px;
  border-top: 1px solid var(--gray-200);
  flex-shrink: 0;
}
.ai-mode-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
  padding: 4px 8px;
  background: var(--ai-accent-bg, rgba(0, 150, 136, 0.08));
  border: 1px solid var(--accent-ai);
  border-radius: 6px;
  font-size: 0.72rem;
  font-weight: 500;
  color: var(--accent-ai);
}
.ai-mode-badge-cancel {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border: none;
  border-radius: 50%;
  background: none;
  color: var(--accent-ai);
  cursor: pointer;
  font-size: 0.9rem;
  line-height: 0;
  padding: 0;
  margin-left: auto;
  opacity: 0.7;
  transition: opacity 0.15s;
}
.ai-mode-badge-cancel:hover {
  opacity: 1;
}
.ai-retry-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-top: 8px;
  padding: 4px 12px;
  border: 1px solid var(--accent-ai);
  border-radius: 6px;
  background: var(--ai-accent-bg, rgba(0, 150, 136, 0.08));
  color: var(--accent-ai);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}
.ai-retry-btn:hover {
  background: var(--accent-ai);
  color: #fff;
}
.ai-input-wrap {
  display: flex;
  align-items: flex-end;
  gap: 0;
  border: 1px solid var(--gray-300);
  border-radius: 10px;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.ai-input-wrap:focus-within {
  border-color: var(--accent-ai);
  box-shadow: 0 0 0 2px var(--ai-accent-bg, rgba(0, 150, 136, 0.1));
}
.ai-input {
  flex: 1;
  border: none;
  padding: 8px 12px;
  font-size: 0.82rem;
  line-height: 1.4;
  background: transparent;
  color: var(--body-font-color);
  resize: none;
  outline: none;
  min-height: 36px;
  max-height: 120px;
  font-family: inherit;
  border-radius: 10px 0 0 10px;
}
.ai-input::placeholder {
  color: var(--gray-400);
}
.ai-send-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 36px;
  border: none;
  border-left: 1px solid var(--gray-200);
  border-radius: 0 9px 9px 0;
  background: transparent;
  color: var(--accent-ai);
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  flex-shrink: 0;
  line-height: 0;
}
/* When mic button is visible, it sits between textarea and send */
.ai-input-wrap .ai-mic-btn + .ai-send-btn {
  border-radius: 0 9px 9px 0;
}
.ai-mic-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 34px;
  height: 36px;
  border: none;
  border-left: 1px solid var(--gray-200);
  background: transparent;
  color: var(--gray-400);
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  flex-shrink: 0;
  line-height: 0;
}
.ai-mic-btn:hover {
  color: var(--accent-ai);
  background: rgba(0, 188, 180, 0.06);
}
.ai-mic-btn.recording {
  color: var(--color-danger, #ea4335);
  animation: ai-mic-pulse 1.2s ease-in-out infinite;
}
@keyframes ai-mic-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}
.ai-send-btn:hover:not(:disabled) {
  background: var(--accent-ai);
  color: #fff;
}
.ai-send-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.ai-input-hint {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 0.65rem;
  color: var(--gray-400);
}
.ai-input-hint kbd {
  display: inline-block;
  padding: 0 3px;
  font-size: 0.6rem;
  border-radius: 2px;
  background: var(--gray-100);
  border: 1px solid var(--gray-200);
}
.ai-stop-btn {
  padding: 2px 10px;
  border: 1px solid var(--color-danger);
  border-radius: 6px;
  background: var(--color-danger-bg);
  color: var(--color-danger);
  font-size: 0.7rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s;
}
.ai-stop-btn:hover {
  background: var(--color-danger);
  color: #fff;
}

/* ─── Not supported ─── */
.ai-not-supported {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 2rem 1rem;
  color: var(--gray-500);
  flex: 1;
}
.ai-not-supported p {
  margin: 8px 0 0;
  font-size: 0.82rem;
}
.ai-not-supported-hint {
  font-size: 0.72rem !important;
  color: var(--gray-400) !important;
}

/* ─── Responsive ─── */
@media (max-width: 500px) {
  .ai-panel {
    width: 100vw;
  }
}
</style>

<script>
(function() {
  'use strict';

  // ─── DOM refs ───
  var fab = null; // FAB removed — AI is now accessed via Quick Capture mode toggle
  var panel = document.getElementById('ai-panel');
  var panelClose = document.getElementById('ai-panel-close');
  var settingsBtn = document.getElementById('ai-settings-btn');
  var settingsPanel = document.getElementById('ai-settings');
  var enabledToggle = document.getElementById('ai-enabled-toggle');
  var clearBtn = document.getElementById('ai-clear-btn');
  var messagesEl = document.getElementById('ai-messages');
  var welcomeEl = document.getElementById('ai-welcome');
  var quickActions = document.getElementById('ai-quick-actions');
  var inputArea = document.getElementById('ai-input-area');
  var inputEl = document.getElementById('ai-input');
  var sendBtn = document.getElementById('ai-send-btn');
  var stopBtn = document.getElementById('ai-stop-btn');
  var statusEl = document.getElementById('ai-panel-status');
  var downloadEl = document.getElementById('ai-download');
  var downloadText = document.getElementById('ai-download-text');
  var downloadFill = document.getElementById('ai-download-fill');
  var downloadDetail = document.getElementById('ai-download-detail');
  var webgpuStatusEl = document.getElementById('ai-webgpu-status');
  var modelStatusEl = document.getElementById('ai-model-status');
  var modelStatusRow = document.getElementById('ai-model-status-row');
  var unloadBtn = document.getElementById('ai-unload-btn');
  var notSupportedEl = document.getElementById('ai-not-supported');
  var modeBadge = document.getElementById('ai-mode-badge');
  var modeBadgeText = document.getElementById('ai-mode-badge-text');
  var customContextEl = document.getElementById('ai-custom-context');
  var contextSavedEl = document.getElementById('ai-context-saved');
  var micBtn = document.getElementById('ai-mic-btn');
  var modeBadgeCancel = document.getElementById('ai-mode-badge-cancel');

  if (!panel) return;

  // ─── Constants ───
  var MODEL_ID = 'Qwen2.5-0.5B-Instruct-q4f32_1-MLC';
  var CDN_URL = 'https://esm.run/@mlc-ai/web-llm';
  var LS_KEY_ENABLED = 'dm-ai-enabled';
  var LS_KEY_CONTEXT = 'dm-ai-custom-context';
  var SS_KEY_MESSAGES = 'dm-ai-messages';
  var SS_KEY_PANEL = 'dm-ai-panel-open';

  // ─── State ───
  var engine = null;
  var webllm = null;
  var loadingPromise = null;
  var aiStatus = 'idle'; // 'idle' | 'loading' | 'ready' | 'error' | 'disabled' | 'unsupported'
  var chatHistory = []; // array of {role, content}
  var isGenerating = false;
  var abortController = null;
  var hasWebGPU = typeof navigator !== 'undefined' && !!navigator.gpu;

  // ─── System prompt builder (optimized for Qwen2.5-0.5B) ───
  function buildSystemPrompt(tasks) {
    var now = new Date();
    var todayStr = now.toISOString().split('T')[0];
    var dayName = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][now.getDay()];

    var prompt = 'You are a proactive productivity assistant and executive task manager. Today: ' + dayName + ', ' + todayStr + '.\n';
    prompt += 'Rules:\n';
    prompt += '- Be concise. Use bullet points with dashes.\n';
    prompt += '- Keep replies under 150 words.\n';
    prompt += '- When suggesting tasks, wrap each task title in **bold**.\n';
    prompt += '- Do not repeat the user\'s message back.\n';
    prompt += '- Be proactive: suggest improvements, don\'t just answer passively.\n';
    prompt += '- If a task is vague (e.g. "clean house"), suggest breaking it into specific subtasks.\n';
    prompt += '- If tasks have no deadline, recommend when to schedule them.\n';
    prompt += '- When a task involves a deliverable (PR, report, presentation), suggest follow-up tasks like review, notify stakeholders, or documentation.\n';
    prompt += '- If the user mentions a goal, suggest actionable next steps as tasks.\n';
    prompt += '- Flag overdue tasks and suggest rescheduling or prioritizing them.\n\n';

    // Inject custom context from settings
    var customCtx = '';
    try { customCtx = (localStorage.getItem(LS_KEY_CONTEXT) || '').trim(); } catch(e) {}
    if (customCtx) {
      prompt += 'User context: ' + customCtx + '\n\n';
    }

    if (!tasks || tasks.length === 0) {
      prompt += 'The user has no tasks. Suggest they start by adding tasks for today.\n';
      return prompt;
    }

    // Categorize tasks
    var pending = [];
    var overdue = [];
    var completedRecent = [];
    var sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

    tasks.forEach(function(t) {
      // Skip deleted tasks — they should not appear in AI context
      if ((t.status || 'active') === 'deleted') return;
      if (t.done) {
        if (t.completedAt && t.completedAt > sevenDaysAgo) {
          completedRecent.push(t);
        }
      } else {
        pending.push(t);
        if (t.scheduledDate && t.scheduledDate < todayStr) {
          overdue.push(t);
        }
      }
    });

    // Build task context — most important info last (recency bias for small models)
    if (completedRecent.length > 0) {
      prompt += 'Done recently: ' + completedRecent.slice(0, 5).map(function(t) { return t.title; }).join(', ') + '\n';
    }

    if (pending.length > 0) {
      var unscheduled = pending.filter(function(t) { return !t.scheduledDate; });
      var futureTasks = pending.filter(function(t) { return t.scheduledDate && t.scheduledDate > todayStr; });

      if (unscheduled.length > 0) {
        prompt += '\nBacklog/Unscheduled (' + unscheduled.length + ' — suggest scheduling these):\n';
        unscheduled.slice(0, 7).forEach(function(t) {
          prompt += '- ' + t.title;
          if (t.category) prompt += ' [' + t.category + ']';
          if (t.estimatedMin) prompt += ' ~' + t.estimatedMin + 'min';
          prompt += '\n';
        });
        if (unscheduled.length > 7) prompt += '- +' + (unscheduled.length - 7) + ' more\n';
      }

      if (futureTasks.length > 0) {
        prompt += '\nUpcoming (' + futureTasks.length + '):\n';
        futureTasks.slice(0, 5).forEach(function(t) {
          prompt += '- ' + t.title + ' (' + t.scheduledDate + ')';
          prompt += '\n';
        });
        if (futureTasks.length > 5) prompt += '- +' + (futureTasks.length - 5) + ' more\n';
      }
    }

    // Overdue and Today last — most important, strongest recency signal
    if (overdue.length > 0) {
      prompt += '\nOVERDUE (' + overdue.length + ' — urge user to reschedule or complete):\n';
      overdue.forEach(function(t) {
        prompt += '- ' + t.title;
        if (t.scheduledDate) prompt += ' (was: ' + t.scheduledDate + ')';
        prompt += '\n';
      });
    }

    if (pending.length > 0) {
      var todayTasks = pending.filter(function(t) { return t.scheduledDate === todayStr; });
      if (todayTasks.length > 0) {
        prompt += '\nTODAY (' + todayTasks.length + '):\n';
        todayTasks.forEach(function(t) {
          prompt += '- ' + t.title;
          if (t.estimatedMin) prompt += ' ~' + t.estimatedMin + 'min';
          prompt += '\n';
        });
      }
    }

    return prompt;
  }

  // ─── Task context loader ───
  function getTaskContext() {
    return new Promise(function(resolve) {
      if (!window.dmSync || !window.dmSync.getAllTodos) {
        resolve([]);
        return;
      }
      window.dmSync.getAllTodos().then(function(todos) {
        resolve(todos || []);
      }).catch(function() {
        resolve([]);
      });
    });
  }

  // ─── WebGPU check ───
  function checkWebGPU() {
    if (!hasWebGPU) {
      webgpuStatusEl.textContent = 'Not supported';
      webgpuStatusEl.style.color = 'var(--color-danger)';
      return false;
    }
    webgpuStatusEl.textContent = 'Supported';
    webgpuStatusEl.style.color = 'var(--color-success)';
    return true;
  }

  // ─── Status management ───
  function setStatus(status, text) {
    aiStatus = status;
    statusEl.className = 'ai-panel-status';
    statusEl.style.display = 'none';
    if (status === 'ready') {
      statusEl.textContent = text || 'Ready';
      statusEl.className = 'ai-panel-status ready';
      statusEl.style.display = '';
      modelStatusEl.textContent = 'Loaded';
      modelStatusEl.style.color = 'var(--color-success)';
      modelStatusRow.style.display = '';
      unloadBtn.style.display = '';
    } else if (status === 'loading') {
      statusEl.textContent = text || 'Loading...';
      statusEl.className = 'ai-panel-status loading';
      statusEl.style.display = '';
      modelStatusEl.textContent = 'Loading...';
      modelStatusEl.style.color = 'var(--color-link)';
      modelStatusRow.style.display = '';
    } else if (status === 'error') {
      statusEl.textContent = text || 'Error';
      statusEl.className = 'ai-panel-status error';
      statusEl.style.display = '';
      modelStatusEl.textContent = 'Error';
      modelStatusEl.style.color = 'var(--color-danger)';
      modelStatusRow.style.display = '';
    } else {
      modelStatusEl.textContent = 'Not loaded';
      modelStatusEl.style.color = 'var(--gray-500)';
      unloadBtn.style.display = 'none';
    }
  }

  // ─── Engine management ───
  function loadEngine() {
    if (engine) return Promise.resolve(engine);
    if (loadingPromise) return loadingPromise;
    if (!hasWebGPU) {
      setStatus('error', 'No WebGPU');
      return Promise.reject(new Error('WebGPU not supported'));
    }

    setStatus('loading', 'Loading...');
    downloadEl.style.display = '';
    downloadText.textContent = 'Loading AI model...';
    downloadFill.style.width = '0%';
    downloadDetail.textContent = 'This may take a moment on first use (~350 MB download)';

    loadingPromise = import(CDN_URL).then(function(mod) {
      webllm = mod;
      return mod.CreateMLCEngine(MODEL_ID, {
        initProgressCallback: function(progress) {
          var pct = Math.round((progress.progress || 0) * 100);
          downloadFill.style.width = pct + '%';
          downloadText.textContent = progress.text || 'Loading...';
          if (pct > 0 && pct < 100) {
            downloadDetail.textContent = pct + '% complete';
          }
          // Broadcast progress so the dedicated page can update its own UI
          window.dispatchEvent(new CustomEvent('dm-ai-load-progress', { detail: { pct: pct, text: progress.text || 'Loading...' } }));
        }
      });
    }).then(function(eng) {
      engine = eng;
      loadingPromise = null;
      downloadEl.style.display = 'none';
      setStatus('ready');
      return engine;
    }).catch(function(err) {
      console.error('[AI Companion] Failed to load engine:', err);
      loadingPromise = null;
      downloadEl.style.display = 'none';
      setStatus('error', 'Load failed');
      var errMsg = (err.message || String(err));
      var errLower = errMsg.toLowerCase();
      var friendlyMsg = 'Failed to load the AI model.';
      if (errLower.indexOf('webgpu') !== -1 || errLower.indexOf('gpu') !== -1) {
        friendlyMsg += ' WebGPU is not available in your browser. Try Chrome 113+ or Edge 113+.';
      } else if (errLower.indexOf('network') !== -1 || errLower.indexOf('fetch') !== -1) {
        friendlyMsg += ' Network error — check your connection and try again.';
      } else {
        friendlyMsg += ' ' + errMsg;
      }
      var msgEl = addMessage('assistant', friendlyMsg);
      var retryBtn = document.createElement('button');
      retryBtn.className = 'ai-retry-btn';
      retryBtn.textContent = 'Retry';
      retryBtn.addEventListener('click', function() {
        retryBtn.disabled = true;
        retryBtn.textContent = 'Retrying...';
        loadEngine().then(function() {
          if (retryBtn.parentNode) retryBtn.parentNode.removeChild(retryBtn);
        }).catch(function() {
          retryBtn.disabled = false;
          retryBtn.textContent = 'Retry';
        });
      });
      var bubble = msgEl.querySelector('.ai-msg-bubble');
      if (bubble) bubble.appendChild(retryBtn);
      throw err;
    });
    return loadingPromise;
  }

  function unloadEngine() {
    if (engine) {
      engine.unload().catch(function() {});
      engine = null;
    }
    setStatus('idle');
  }

  // ─── Chat completion ───
  function runChat(userMessage, systemOverride) {
    if (isGenerating) return;
    isGenerating = true;
    sendBtn.disabled = true;
    stopBtn.style.display = '';

    // Add user message
    addMessage('user', userMessage);
    chatHistory.push({ role: 'user', content: userMessage });

    // Show typing indicator
    var typingEl = addTypingIndicator();

    // Ensure engine is loaded
    var enginePromise = engine ? Promise.resolve(engine) : loadEngine();

    enginePromise.then(function(eng) {
      engine = eng || engine;
      return getTaskContext();
    }).then(function(tasks) {
      var systemPrompt = systemOverride || buildSystemPrompt(tasks);
      var messages = [{ role: 'system', content: systemPrompt }];

      // Include recent chat history (last 10 messages for context window)
      var recentHistory = chatHistory.slice(-10);
      messages = messages.concat(recentHistory);

      // Create abort mechanism
      var stopped = false;
      abortController = { stop: function() { stopped = true; } };

      return engine.chat.completions.create({
        messages: messages,
        stream: true,
        temperature: 0.7,
        max_tokens: 512
      }).then(function(chunks) {
        // Remove typing indicator
        if (typingEl && typingEl.parentNode) {
          typingEl.parentNode.removeChild(typingEl);
        }

        // Create assistant message element
        var msgEl = addMessage('assistant', '');
        var bubbleEl = msgEl.querySelector('.ai-msg-bubble');
        bubbleEl.classList.add('streaming');
        var fullText = '';
        var rafPending = false;

        function finalizeStream() {
          bubbleEl.classList.remove('streaming');
          chatHistory.push({ role: 'assistant', content: fullText });
          saveMessages();
          bubbleEl.innerHTML = renderMarkdown(fullText);
          addCopyButton(bubbleEl, fullText);
          detectAndRenderTaskCards(bubbleEl, fullText);
          isGenerating = false;
          sendBtn.disabled = !inputEl.value.trim();
          stopBtn.style.display = 'none';
          abortController = null;
        }

        // Handle async iterator (WebLLM standard response format)
        if (chunks[Symbol.asyncIterator]) {
          var iterator = chunks[Symbol.asyncIterator]();
          function processIterator() {
            return iterator.next().then(function(result) {
              if (result.done || stopped) {
                finalizeStream();
                return;
              }
              var chunk = result.value;
              var delta = '';
              if (chunk.choices && chunk.choices[0] && chunk.choices[0].delta) {
                delta = chunk.choices[0].delta.content || '';
              }
              if (delta) {
                fullText += delta;
                if (!rafPending) {
                  rafPending = true;
                  requestAnimationFrame(function() {
                    rafPending = false;
                    bubbleEl.innerHTML = renderMarkdown(fullText);
                    scrollToBottom();
                  });
                }
              }
              return processIterator();
            });
          }
          return processIterator();
        } else {
          throw new Error('Unexpected streaming response format from WebLLM');
        }
      });
    }).catch(function(err) {
      if (typingEl && typingEl.parentNode) {
        typingEl.parentNode.removeChild(typingEl);
      }
      var errRaw = (err.message || String(err));
      var errLower = errRaw.toLowerCase();
      if (errLower.indexOf('not supported') !== -1) {
        // Suppress — loadEngine already displayed this
      } else {
        var friendlyMsg = 'Something went wrong.';
        if (errLower.indexOf('network') !== -1 || errLower.indexOf('fetch') !== -1) {
          friendlyMsg = 'Network error — check your connection and try again.';
        } else if (errLower.indexOf('context') !== -1 || errLower.indexOf('token') !== -1) {
          friendlyMsg = 'The conversation is too long. Try clearing the chat and starting fresh.';
        } else {
          friendlyMsg += ' ' + errRaw;
        }
        addMessage('assistant', friendlyMsg);
      }
      isGenerating = false;
      sendBtn.disabled = !inputEl.value.trim();
      stopBtn.style.display = 'none';
      abortController = null;
    });
  }

  // ─── Quick action prompts ───
  var quickPrompts = {
    plan: 'Look at my tasks for today and overdue. Create a prioritized plan with suggested order. If any tasks are vague, suggest breaking them into subtasks. If no tasks today, pick from my backlog and suggest scheduling them. Flag anything overdue that should be rescheduled.',
    suggest: 'Suggest 3-5 new tasks based on my existing tasks. For each, give the title in **bold** and a one-line reason. Consider follow-up tasks for existing work (e.g., if I have a PR task, suggest code review or documentation). If I have unscheduled tasks, suggest when to do them.',
    improve: null, // handled separately with text input
    summarize: null // handled separately with text input
  };

  function showModeBadge(label) {
    if (modeBadge) {
      modeBadgeText.textContent = label;
      modeBadge.style.display = '';
    }
  }

  function hideModeBadge() {
    if (modeBadge) {
      modeBadge.style.display = 'none';
      modeBadgeText.textContent = '';
    }
  }

  function handleQuickAction(action) {
    if (action === 'improve') {
      inputEl.value = '';
      inputEl.placeholder = 'Paste the text you want to improve...';
      inputEl.focus();
      inputEl.dataset.mode = 'improve';
      showModeBadge('Improve mode');
      return;
    }
    if (action === 'summarize') {
      inputEl.value = '';
      inputEl.placeholder = 'Paste the text you want to summarize...';
      inputEl.focus();
      inputEl.dataset.mode = 'summarize';
      showModeBadge('Summarize mode');
      return;
    }
    var prompt = quickPrompts[action];
    if (prompt) {
      runChat(prompt);
    }
  }

  // ─── Message rendering ───
  function addMessage(role, content) {
    // Hide welcome on first message
    if (welcomeEl) welcomeEl.style.display = 'none';

    var msgEl = document.createElement('div');
    msgEl.className = 'ai-msg ai-msg-' + role;

    var avatarEl = document.createElement('div');
    avatarEl.className = 'ai-msg-avatar';
    avatarEl.textContent = role === 'user' ? 'U' : 'AI';

    var bubbleEl = document.createElement('div');
    bubbleEl.className = 'ai-msg-bubble';
    if (content) {
      bubbleEl.innerHTML = renderMarkdown(content);
    }

    msgEl.appendChild(avatarEl);
    msgEl.appendChild(bubbleEl);
    messagesEl.appendChild(msgEl);
    scrollToBottom(true);
    return msgEl;
  }

  function addTypingIndicator() {
    var el = document.createElement('div');
    el.className = 'ai-msg ai-msg-assistant';
    el.innerHTML = '<div class="ai-msg-avatar">AI</div><div class="ai-msg-bubble"><div class="ai-typing"><span class="ai-typing-dot"></span><span class="ai-typing-dot"></span><span class="ai-typing-dot"></span></div></div>';
    messagesEl.appendChild(el);
    scrollToBottom(true);
    return el;
  }

  function addCopyButton(bubbleEl, text) {
    var btn = document.createElement('button');
    btn.className = 'ai-copy-btn';
    btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> Copy';
    btn.addEventListener('click', function() {
      navigator.clipboard.writeText(text).then(function() {
        btn.classList.add('copied');
        btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied';
        setTimeout(function() {
          btn.classList.remove('copied');
          btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> Copy';
        }, 2000);
      }).catch(function() {});
    });
    bubbleEl.appendChild(btn);
  }

  function detectAndRenderTaskCards(bubbleEl, text) {
    // Detect bold items that look like task suggestions (e.g., "**Task title**")
    var boldPattern = /\*\*([^*]+)\*\*/g;
    var matches = [];
    var match;
    while ((match = boldPattern.exec(text)) !== null) {
      var title = match[1].trim();
      // Skip short matches or ones that look like labels
      if (title.length > 5 && title.length < 200 && !/^[A-Za-z]{1,15}:/.test(title)) {
        matches.push(title);
      }
    }

    if (matches.length === 0) return;

    var cardsContainer = document.createElement('div');
    cardsContainer.style.marginTop = '8px';

    matches.forEach(function(taskTitle) {
      var card = document.createElement('div');
      card.className = 'ai-task-card';

      var titleSpan = document.createElement('span');
      titleSpan.className = 'ai-task-card-title';
      titleSpan.textContent = taskTitle;

      var addBtn = document.createElement('button');
      addBtn.className = 'ai-task-card-add';
      addBtn.innerHTML = '+';
      addBtn.title = 'Add as task';
      addBtn.addEventListener('click', function() {
        addTaskFromSuggestion(taskTitle, card);
      });

      card.appendChild(titleSpan);
      card.appendChild(addBtn);
      cardsContainer.appendChild(card);
    });

    bubbleEl.appendChild(cardsContainer);
  }

  function addTaskFromSuggestion(title, cardEl) {
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser) {
      addMessage('assistant', 'Please sign in to add tasks.');
      return;
    }

    // Dispatch a custom event to create the task (todo-list.html listens for this)
    var event = new CustomEvent('dm-ai-create-task', { detail: { title: title, source: 'ai' } });
    window.dispatchEvent(event);

    // Update the card UI
    var addBtn = cardEl.querySelector('.ai-task-card-add');
    if (addBtn) {
      addBtn.style.display = 'none';
      var addedSpan = document.createElement('span');
      addedSpan.className = 'ai-task-card-added';
      addedSpan.textContent = 'Added';
      cardEl.appendChild(addedSpan);
    }
  }

  // ─── Markdown renderer (shared via window.dmAI) ───
  function renderMarkdown(text) {
    if (!text) return '';

    // Escape HTML
    var html = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    // Code blocks (triple backtick) — extract before other processing
    var codeBlocks = [];
    html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, function(_, lang, code) {
      var idx = codeBlocks.length;
      codeBlocks.push('<pre class="ai-code-block"><code>' + code.replace(/\n$/, '') + '</code></pre>');
      return '\x00CB' + idx + '\x00';
    });

    // Inline code (protect from further processing)
    var inlineCode = [];
    html = html.replace(/`([^`]+)`/g, function(_, code) {
      var idx = inlineCode.length;
      inlineCode.push('<code>' + code + '</code>');
      return '\x00IC' + idx + '\x00';
    });

    // Bold and italic
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');

    // Horizontal rule
    html = html.replace(/^---+$/gm, '<hr>');

    // Headers (proper semantic elements)
    html = html.replace(/^#### (.+)$/gm, '<h6>$1</h6>');
    html = html.replace(/^### (.+)$/gm, '<h5>$1</h5>');
    html = html.replace(/^## (.+)$/gm, '<h4>$1</h4>');
    html = html.replace(/^# (.+)$/gm, '<h3>$1</h3>');

    // Process line by line for lists
    var lines = html.split('\n');
    var result = [];
    var inUl = false;
    var inOl = false;

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      var ulMatch = line.match(/^[-*] (.+)$/);
      var olMatch = line.match(/^\d+\. (.+)$/);

      if (ulMatch) {
        if (inOl) { result.push('</ol>'); inOl = false; }
        if (!inUl) { result.push('<ul>'); inUl = true; }
        result.push('<li>' + ulMatch[1] + '</li>');
      } else if (olMatch) {
        if (inUl) { result.push('</ul>'); inUl = false; }
        if (!inOl) { result.push('<ol>'); inOl = true; }
        result.push('<li>' + olMatch[1] + '</li>');
      } else {
        if (inUl) { result.push('</ul>'); inUl = false; }
        if (inOl) { result.push('</ol>'); inOl = false; }
        result.push(line);
      }
    }
    if (inUl) result.push('</ul>');
    if (inOl) result.push('</ol>');

    html = result.join('\n');

    // Paragraphs and line breaks
    html = html.replace(/\n\n/g, '</p><p>');
    html = html.replace(/\n/g, '<br>');

    // Restore code blocks and inline code
    html = html.replace(/\x00CB(\d+)\x00/g, function(_, idx) { return codeBlocks[parseInt(idx)]; });
    html = html.replace(/\x00IC(\d+)\x00/g, function(_, idx) { return inlineCode[parseInt(idx)]; });

    return '<p>' + html + '</p>';
  }

  function scrollToBottom(force) {
    // Only auto-scroll if user is near the bottom (within 80px) or forced
    var atBottom = force || (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < 80);
    if (atBottom) {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }

  // ─── Session storage for messages ───
  function saveMessages() {
    try {
      // Truncate in memory to prevent unbounded growth
      if (chatHistory.length > 50) {
        chatHistory = chatHistory.slice(-50);
      }
      var toSave = chatHistory.slice(-20);
      sessionStorage.setItem(SS_KEY_MESSAGES, JSON.stringify(toSave));
    } catch(e) {}
  }

  function loadMessages() {
    try {
      var saved = sessionStorage.getItem(SS_KEY_MESSAGES);
      if (saved) {
        var parsed = JSON.parse(saved);
        if (!Array.isArray(parsed)) return;
        chatHistory = parsed.filter(function(msg) {
          return msg && (msg.role === 'user' || msg.role === 'assistant') && typeof msg.content === 'string';
        });
        chatHistory.forEach(function(msg) {
          var msgEl = addMessage(msg.role, msg.content);
          msgEl.style.animation = 'none'; // Skip entrance animation for restored messages
        });
      }
    } catch(e) {}
  }

  // ─── Enable/Disable ───
  function isAiEnabled() {
    return localStorage.getItem(LS_KEY_ENABLED) === '1';
  }

  function setAiEnabled(enabled) {
    localStorage.setItem(LS_KEY_ENABLED, enabled ? '1' : '0');
    enabledToggle.checked = enabled;
    if (enabled) {
      quickActions.style.display = '';
      inputArea.style.display = '';
      notSupportedEl.style.display = 'none';
      if (!hasWebGPU) {
        notSupportedEl.style.display = '';
        quickActions.style.display = 'none';
        inputArea.style.display = 'none';
      }
    } else {
      unloadEngine();
      closePanel();
    }
    // Notify other components (Quick Capture listens for this to show/hide AI mode)
    window.dispatchEvent(new CustomEvent('dm-ai-state-changed', { detail: { enabled: enabled } }));
  }

  // ─── Panel open/close ───
  var closingTimeout = null;

  function openPanel() {
    if (closingTimeout) { clearTimeout(closingTimeout); closingTimeout = null; }
    panel.style.display = '';
    panel.classList.remove('closing');
    try { sessionStorage.setItem(SS_KEY_PANEL, '1'); } catch(e) {}
    setTimeout(function() { inputEl.focus({ preventScroll: true }); }, 100);
  }

  function closePanel() {
    if (closingTimeout) { clearTimeout(closingTimeout); closingTimeout = null; }
    panel.classList.add('closing');
    closingTimeout = setTimeout(function() {
      panel.style.display = 'none';
      panel.classList.remove('closing');
      closingTimeout = null;
    }, 200);
    try { sessionStorage.setItem(SS_KEY_PANEL, '0'); } catch(e) {}
  }

  function togglePanel() {
    if (panel.style.display === 'none') {
      openPanel();
    } else {
      closePanel();
    }
  }

  // ─── Send message ───
  // ─── Task-creation intent detection & NLP parsing ───

  var taskIntentPatterns = [
    /^(?:add|create|make|new|schedule)\s+(?:a\s+)?task\s*[:;\-–—]\s*(.+)/i,
    /^(?:add|create|make|new|schedule)\s+(?:a\s+)?task\s+(?:called|named|titled)\s+(.+)/i,
    /^(?:add|create|make|new|schedule)\s+(?:a\s+)?task\s+(?:to|for)\s+(.+)/i,
    /^(?:add|create|make|new|schedule)\s+(?:a\s+)?task\s+(.+)/i,
    /^(?:add)\s+(.+?)\s+(?:to\s+(?:my\s+)?(?:tasks|todos?|inbox|list))\s*$/i,
    /^(?:remind\s+me\s+to)\s+(.+)/i,
    /^(?:todo|task)\s*[:;\-–—]\s*(.+)/i,
    /^(?:schedule)\s+(.+)/i,
    /^(?:i\s+need\s+to|i\s+have\s+to|i\s+should|i\s+must|i\s+gotta)\s+(.+)/i,
    /^(?:plan)\s+(?:a\s+)?(?:task\s+)?(?:to|for)\s+(.+)/i,
    /^(?:don'?t\s+(?:let\s+me\s+)?forget\s+to)\s+(.+)/i,
    /^(?:put|set)\s+(?:a\s+)?(?:task|reminder)\s+(?:to|for)\s+(.+)/i
  ];

  function detectTaskIntent(text) {
    for (var i = 0; i < taskIntentPatterns.length; i++) {
      var m = taskIntentPatterns[i].exec(text.trim());
      if (m && m[1]) {
        var title = m[1].trim().replace(/\.+$/, '').trim();
        if (title.length >= 3 && title.length < 200) {
          return title;
        }
      }
    }
    return null;
  }

  // ─── Date parsing from natural language ───
  function _fmtDate(d) {
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
  }

  function _nextWeekday(dayIndex) {
    // dayIndex: 0=Sun, 1=Mon, ..., 6=Sat
    var d = new Date();
    var diff = (dayIndex - d.getDay() + 7) % 7;
    if (diff === 0) diff = 7; // "next Monday" when today is Monday means +7
    d.setDate(d.getDate() + diff);
    return d;
  }

  var _dayNames = { sunday: 0, sun: 0, monday: 1, mon: 1, tuesday: 2, tue: 2, tues: 2, wednesday: 3, wed: 3, thursday: 4, thu: 4, thur: 4, thurs: 4, friday: 5, fri: 5, saturday: 6, sat: 6 };

  // ─── Time-of-day parsing helper ───
  function _parseTimeOfDay(text) {
    var lower = text.toLowerCase();
    // "at 5pm", "at 5:30pm", "at 17:00", "at 5 pm", "at 5:30 p.m."
    var timeMatch = lower.match(/\bat\s+(\d{1,2})(?::(\d{2}))?\s*([ap]\.?m\.?)?/i);
    if (timeMatch) {
      var hour = parseInt(timeMatch[1]);
      var min = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
      var ampm = timeMatch[3] ? timeMatch[3].replace(/\./g, '').toLowerCase() : null;
      if (ampm === 'pm' && hour < 12) hour += 12;
      if (ampm === 'am' && hour === 12) hour = 0;
      // If no AM/PM and hour <= 7, assume PM (business hours heuristic)
      if (!ampm && hour >= 1 && hour <= 7) hour += 12;
      if (hour >= 0 && hour <= 23 && min >= 0 && min <= 59) {
        return { hour: hour, minute: min, matched: timeMatch[0] };
      }
    }
    // "morning", "afternoon", "evening", "night" as standalone time hints
    if (/\b(?:in\s+the\s+)?morning\b/.test(lower)) {
      var mMatch = lower.match(/\b(?:in\s+the\s+)?morning\b/);
      return { hour: 9, minute: 0, matched: mMatch[0] };
    }
    if (/\b(?:in\s+the\s+)?afternoon\b/.test(lower)) {
      var aMatch = lower.match(/\b(?:in\s+the\s+)?afternoon\b/);
      return { hour: 14, minute: 0, matched: aMatch[0] };
    }
    if (/\b(?:in\s+the\s+)?evening\b/.test(lower)) {
      var eMatch = lower.match(/\b(?:in\s+the\s+)?evening\b/);
      return { hour: 19, minute: 0, matched: eMatch[0] };
    }
    if (/\b(?:at\s+)?night\b/.test(lower)) {
      var nMatch = lower.match(/\b(?:at\s+)?night\b/);
      return { hour: 21, minute: 0, matched: nMatch[0] };
    }
    return null;
  }

  // ─── Priority parsing ───
  function _parsePriority(text) {
    var lower = text.toLowerCase();
    // Explicit priority mentions
    if (/\b(?:high\s+priority|urgent|asap|important|critical)\b/.test(lower)) {
      var m = lower.match(/\b(high\s+priority|urgent|asap|important|critical)\b/);
      return { level: 'high', matched: m[0] };
    }
    if (/\b(?:low\s+priority|whenever|no\s+rush|not\s+urgent)\b/.test(lower)) {
      var m2 = lower.match(/\b(low\s+priority|whenever|no\s+rush|not\s+urgent)\b/);
      return { level: 'low', matched: m2[0] };
    }
    // Exclamation marks as urgency signal
    if (/!!+/.test(text)) {
      return { level: 'high', matched: text.match(/!!+/)[0] };
    }
    return null;
  }

  function parseDate(text) {
    var lower = text.toLowerCase();
    var timeInfo = _parseTimeOfDay(text);

    // "today"
    if (/\b(today)\b/.test(lower)) {
      return { date: _fmtDate(new Date()), matched: 'today', time: timeInfo };
    }
    // "tonight"
    if (/\b(tonight)\b/.test(lower)) {
      return { date: _fmtDate(new Date()), matched: 'tonight', time: timeInfo || { hour: 21, minute: 0, matched: 'tonight' } };
    }
    // "day after tomorrow" (must be checked BEFORE "tomorrow")
    if (/\bday\s+after\s+tomorrow\b/.test(lower)) {
      var d2 = new Date(); d2.setDate(d2.getDate() + 2);
      return { date: _fmtDate(d2), matched: 'day after tomorrow', time: timeInfo };
    }
    // "tomorrow" / "tmr" / "tmrw"
    if (/\b(tomorrow|tmrw?)\b/.test(lower)) {
      var d = new Date(); d.setDate(d.getDate() + 1);
      return { date: _fmtDate(d), matched: 'tomorrow', time: timeInfo };
    }
    // "this weekend"
    if (/\bthis\s+weekend\b/.test(lower)) {
      var dw = new Date();
      var daysTillSat = (6 - dw.getDay() + 7) % 7;
      if (daysTillSat === 0) daysTillSat = 7;
      dw.setDate(dw.getDate() + daysTillSat);
      return { date: _fmtDate(dw), matched: 'this weekend', time: timeInfo };
    }
    // "next week" -> next Monday
    if (/\bnext\s+week\b/.test(lower)) {
      var d3 = _nextWeekday(1); // Monday
      return { date: _fmtDate(d3), matched: 'next week', time: timeInfo };
    }
    // "next month"
    if (/\bnext\s+month\b/.test(lower)) {
      var dm = new Date(); dm.setMonth(dm.getMonth() + 1); dm.setDate(1);
      return { date: _fmtDate(dm), matched: 'next month', time: timeInfo };
    }
    // "end of week" -> Friday
    if (/\b(?:end\s+of\s+(?:the\s+)?week|eow)\b/.test(lower)) {
      var eow = _nextWeekday(5); // Friday
      return { date: _fmtDate(eow), matched: lower.match(/\b(?:end\s+of\s+(?:the\s+)?week|eow)\b/)[0], time: timeInfo };
    }
    // "end of day" / "eod" -> today
    if (/\b(?:end\s+of\s+(?:the\s+)?day|eod)\b/.test(lower)) {
      return { date: _fmtDate(new Date()), matched: lower.match(/\b(?:end\s+of\s+(?:the\s+)?day|eod)\b/)[0], time: timeInfo || { hour: 17, minute: 0, matched: 'eod' } };
    }
    // "next <day>" or "on <day>" or "this <day>"
    var dayMatch = lower.match(/\b(?:next|on|this)\s+(sunday|sun|monday|mon|tuesday|tue|tues|wednesday|wed|thursday|thu|thur|thurs|friday|fri|saturday|sat)\b/);
    if (dayMatch) {
      var idx = _dayNames[dayMatch[1]];
      if (idx !== undefined) {
        return { date: _fmtDate(_nextWeekday(idx)), matched: dayMatch[0], time: timeInfo };
      }
    }
    // standalone day name at end or followed by time: "... friday", "friday at 5pm"
    var trailingDay = lower.match(/\b(sunday|sun|monday|mon|tuesday|tue|tues|wednesday|wed|thursday|thu|thur|thurs|friday|fri|saturday|sat)\b(?:\s+at\s+|$)/);
    if (trailingDay) {
      var idx2 = _dayNames[trailingDay[1]];
      if (idx2 !== undefined) {
        return { date: _fmtDate(_nextWeekday(idx2)), matched: trailingDay[1], time: timeInfo };
      }
    }
    // "in N days"
    var inDays = lower.match(/\bin\s+(\d+)\s+days?\b/);
    if (inDays) {
      var d4 = new Date(); d4.setDate(d4.getDate() + parseInt(inDays[1]));
      return { date: _fmtDate(d4), matched: inDays[0], time: timeInfo };
    }
    // "in N weeks"
    var inWeeks = lower.match(/\bin\s+(\d+)\s+weeks?\b/);
    if (inWeeks) {
      var d5 = new Date(); d5.setDate(d5.getDate() + parseInt(inWeeks[1]) * 7);
      return { date: _fmtDate(d5), matched: inWeeks[0], time: timeInfo };
    }
    // If only time was found (no date reference), assume today
    if (timeInfo) {
      return { date: _fmtDate(new Date()), matched: '', time: timeInfo };
    }
    return null;
  }

  // ─── Time estimate parsing ───
  function parseEstimate(text) {
    var lower = text.toLowerCase();
    // "30 min" / "30 minutes" / "30m"
    var minMatch = lower.match(/\b(\d+)\s*(?:min(?:utes?)?|m)\b/);
    if (minMatch) {
      var mins = parseInt(minMatch[1]);
      if (mins > 0 && mins <= 480) return { minutes: mins, matched: minMatch[0] };
    }
    // "1 hour" / "2 hours" / "1h" / "1.5 hours"
    var hrMatch = lower.match(/\b(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|h)\b/);
    if (hrMatch) {
      var hrs = parseFloat(hrMatch[1]);
      if (hrs > 0 && hrs <= 8) return { minutes: Math.round(hrs * 60), matched: hrMatch[0] };
    }
    // "1 pomodoro" / "2 pomodoros"
    var pomMatch = lower.match(/\b(\d+)\s*(?:pomodoros?|poms?)\b/);
    if (pomMatch) {
      var poms = parseInt(pomMatch[1]);
      if (poms > 0 && poms <= 16) return { minutes: poms * 25, matched: pomMatch[0] };
    }
    return null;
  }

  // ─── Category inference from keywords ───
  var _categoryKeywords = {
    work: ['work', 'meeting', 'email', 'report', 'presentation', 'project', 'deadline', 'client', 'office', 'standup', 'sprint', 'deploy', 'release', 'review pr', 'code review', 'jira', 'slack'],
    health: ['gym', 'workout', 'exercise', 'run', 'jog', 'yoga', 'doctor', 'dentist', 'appointment', 'medication', 'vitamin', 'meditate', 'stretch', 'walk'],
    personal: ['call mom', 'call dad', 'birthday', 'gift', 'family', 'friend', 'date', 'party', 'wedding', 'anniversary'],
    finance: ['pay', 'bill', 'invoice', 'budget', 'tax', 'bank', 'transfer', 'rent', 'mortgage', 'insurance'],
    errands: ['buy', 'grocery', 'groceries', 'shop', 'shopping', 'pick up', 'pickup', 'return', 'drop off', 'laundry', 'clean', 'repair', 'fix'],
    learning: ['read', 'study', 'course', 'tutorial', 'learn', 'practice', 'book', 'chapter', 'research', 'lecture'],
    admin: ['organize', 'sort', 'file', 'paperwork', 'register', 'renew', 'update', 'backup', 'cancel subscription']
  };

  function inferCategory(text) {
    var lower = text.toLowerCase();
    // First check if user's existing categories match words in the title
    // (loaded dynamically from todos — best match wins)
    if (window.dmSync && window.dmSync.getAllTodos) {
      // We can't do async here, so we skip dynamic lookup and rely on keyword map
    }
    var bestCat = null;
    var bestLen = 0;
    for (var cat in _categoryKeywords) {
      var keywords = _categoryKeywords[cat];
      for (var i = 0; i < keywords.length; i++) {
        if (lower.indexOf(keywords[i]) !== -1 && keywords[i].length > bestLen) {
          bestCat = cat;
          bestLen = keywords[i].length;
        }
      }
    }
    return bestCat;
  }

  // ─── Clean title: remove date/time/estimate/priority phrases ───
  function cleanTaskTitle(title, parsedDate, parsedEstimate, parsedPriority) {
    var cleaned = title;
    // Remove date phrases
    if (parsedDate && parsedDate.matched) {
      // Remove common preposition+date patterns
      cleaned = cleaned.replace(new RegExp('\\s*(?:for|on|by|before|due|scheduled\\s+for|scheduled)?\\s*\\b' + parsedDate.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i'), '');
    }
    // Remove time phrases (e.g., "at 5pm", "morning")
    if (parsedDate && parsedDate.time && parsedDate.time.matched) {
      cleaned = cleaned.replace(new RegExp('\\s*\\b' + parsedDate.time.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i'), '');
    }
    // Remove estimate phrases
    if (parsedEstimate) {
      cleaned = cleaned.replace(new RegExp('\\s*(?:for|taking|takes|about|around|~)?\\s*\\b' + parsedEstimate.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i'), '');
    }
    // Remove priority phrases
    if (parsedPriority && parsedPriority.matched) {
      cleaned = cleaned.replace(new RegExp('\\s*\\b' + parsedPriority.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i'), '');
    }
    // Clean up leftover artifacts
    cleaned = cleaned.replace(/\s*[-–—,]\s*$/, '').replace(/^\s*[-–—,]\s*/, '').trim();
    // Strip leading prepositions left over after date/estimate removal
    cleaned = cleaned.replace(/^(to|for|on|by|at|in)\s+/i, '').trim();
    return cleaned || title;
  }

  // ─── Parse full task from natural language ───
  function parseTaskDetails(rawTitle) {
    var parsedDate = parseDate(rawTitle);
    var parsedEstimate = parseEstimate(rawTitle);
    var parsedPriority = _parsePriority(rawTitle);
    var category = inferCategory(rawTitle);
    var bujoType = detectBujoType(rawTitle);
    var title = cleanTaskTitle(rawTitle, parsedDate, parsedEstimate, parsedPriority);

    return {
      title: title,
      scheduledDate: parsedDate ? parsedDate.date : null,
      estimatedMin: parsedEstimate ? parsedEstimate.minutes : null,
      category: category,
      priority: parsedPriority ? parsedPriority.level : null,
      timeOfDay: parsedDate && parsedDate.time ? { hour: parsedDate.time.hour, minute: parsedDate.time.minute } : null,
      bujoType: bujoType
    };
  }

  // ─── BuJo type detection from natural language ───
  function detectBujoType(text) {
    var lower = text.toLowerCase().trim();
    // Event patterns: meetings, appointments, calls, events with dates/times
    if (/\b(meeting|appointment|call|event|conference|standup|stand-up|sync|demo|interview|webinar|workshop|ceremony|party|dinner|lunch|breakfast|brunch|hangout|date night|concert|show|game|flight|check-?in)\b/i.test(lower)) {
      return 'event';
    }
    // Note patterns: explicit note/idea/remember markers
    if (/^(note|idea|remember|fyi|reminder|thought|insight|observation|til|learned|read that|heard that)\b/i.test(lower)) {
      return 'note';
    }
    if (/\b(jot down|take note|keep in mind|don'?t forget that|worth noting)\b/i.test(lower)) {
      return 'note';
    }
    return 'task';
  }

  // ─── Multi-action detection ───
  function detectMultipleActions(rawTitle) {
    // Detect comma/and-separated actions: "clean kitchen, do laundry, and buy groceries"
    // Only trigger if there are at least 2 distinct actions
    var lower = rawTitle.toLowerCase();

    // Split on ", and ", " and ", or just ","
    var parts = rawTitle.split(/\s*,\s+and\s+|\s*,\s*|\s+and\s+/i);

    // Filter out empty/short parts and date/time phrases that might be split
    var datePhrases = /^(today|tomorrow|tmrw?|tonight|next\s+\w+|on\s+\w+|this\s+\w+|in\s+\d+\s+\w+|\d+\s*(?:min|hour|h|m)\w*|morning|afternoon|evening|night|(?:sun|mon|tue|wed|thu|fri|sat)\w*)$/i;
    var actions = parts.filter(function(p) {
      var trimmed = p.trim();
      return trimmed.length >= 3 && !datePhrases.test(trimmed);
    }).map(function(p) { return p.trim(); });

    // Only return as multi-action if 2+ valid actions found
    if (actions.length >= 2) {
      return actions;
    }
    return null;
  }

  function createTaskDirectly(details) {
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser) {
      return false;
    }
    var event = new CustomEvent('dm-ai-create-task', {
      detail: {
        title: details.title,
        scheduledDate: details.scheduledDate,
        estimatedMin: details.estimatedMin,
        category: details.category,
        bujoType: details.bujoType || 'task',
        source: 'ai'
      }
    });
    window.dispatchEvent(event);
    return true;
  }

  function buildTaskConfirmation(details) {
    var parts = ['Done — added **' + details.title + '**'];
    var meta = [];
    if (details.scheduledDate) {
      // Format the date nicely
      var today = _fmtDate(new Date());
      var tmr = new Date(); tmr.setDate(tmr.getDate() + 1);
      var tmrStr = _fmtDate(tmr);
      var dateLabel;
      if (details.scheduledDate === today) dateLabel = 'today';
      else if (details.scheduledDate === tmrStr) dateLabel = 'tomorrow';
      else {
        var dp = details.scheduledDate.split('-');
        var dd = new Date(parseInt(dp[0]), parseInt(dp[1]) - 1, parseInt(dp[2]));
        var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        var days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        dateLabel = days[dd.getDay()] + ' ' + months[dd.getMonth()] + ' ' + dd.getDate();
      }
      // Append time if available
      if (details.timeOfDay) {
        var h = details.timeOfDay.hour;
        var m = details.timeOfDay.minute;
        var ampm = h >= 12 ? 'pm' : 'am';
        var displayH = h % 12 || 12;
        dateLabel += ' at ' + displayH + (m > 0 ? ':' + String(m).padStart(2, '0') : '') + ampm;
      }
      meta.push(dateLabel);
    }
    if (details.priority) meta.push(details.priority + ' priority');
    if (details.category) meta.push(details.category);
    if (details.estimatedMin) meta.push(details.estimatedMin + ' min');

    if (meta.length > 0) {
      parts.push(' (' + meta.join(', ') + ')');
    }
    return parts.join('') + '.';
  }

  function sendMessage() {
    var text = inputEl.value.trim();
    if (!text || isGenerating) return;

    var mode = inputEl.dataset.mode;
    inputEl.value = '';
    inputEl.dataset.mode = '';
    inputEl.placeholder = 'Ask me anything...';
    hideModeBadge();
    updateInputHeight();
    sendBtn.disabled = true;

    if (mode === 'improve') {
      runChat('Please improve the following text. Make it clearer, more concise, and better written. Return only the improved version:\n\n' + text);
    } else if (mode === 'summarize') {
      runChat('Please summarize the following text concisely:\n\n' + text);
    } else {
      // Check for task-creation intent
      var rawTitle = detectTaskIntent(text);
      if (rawTitle) {
        // Check for multiple actions in one sentence
        var multiActions = detectMultipleActions(rawTitle);
        if (multiActions && multiActions.length >= 2) {
          // Parse shared date/time context from the full raw title
          var sharedDate = parseDate(rawTitle);
          var sharedScheduledDate = sharedDate ? sharedDate.date : null;
          var confirmParts = [];
          var allCreated = true;

          multiActions.forEach(function(action) {
            var details = parseTaskDetails(action);
            // Use shared date if individual action has no date
            if (!details.scheduledDate && sharedScheduledDate) {
              details.scheduledDate = sharedScheduledDate;
            }
            if (!createTaskDirectly(details)) {
              allCreated = false;
            }
            confirmParts.push('**' + details.title + '**');
          });

          if (allCreated) {
            addMessage('user', text);
            chatHistory.push({ role: 'user', content: text });
            var confirmText = 'Done — added ' + multiActions.length + ' tasks: ' + confirmParts.join(', ') + '.';
            if (sharedScheduledDate) {
              var today = _fmtDate(new Date());
              var tmr = new Date(); tmr.setDate(tmr.getDate() + 1);
              var tmrStr = _fmtDate(tmr);
              var dateLabel = sharedScheduledDate === today ? 'today' : (sharedScheduledDate === tmrStr ? 'tomorrow' : sharedScheduledDate);
              confirmText += ' All scheduled for ' + dateLabel + '.';
            }
            addMessage('assistant', confirmText);
            chatHistory.push({ role: 'assistant', content: confirmText });
            saveMessages();
            return;
          }
        }

        // Single task creation
        var details = parseTaskDetails(rawTitle);
        if (createTaskDirectly(details)) {
          // Show user message + instant confirmation (no AI call)
          addMessage('user', text);
          chatHistory.push({ role: 'user', content: text });
          var confirmText = buildTaskConfirmation(details);
          addMessage('assistant', confirmText);
          chatHistory.push({ role: 'assistant', content: confirmText });
          saveMessages();
          return;
        }
      }
      runChat(text);
    }
  }

  // ─── Auto-resize textarea ───
  function updateInputHeight() {
    inputEl.style.height = 'auto';
    inputEl.style.height = Math.min(inputEl.scrollHeight, 120) + 'px';
  }

  // ─── Clear chat ───
  function clearChat() {
    chatHistory = [];
    messagesEl.innerHTML = '';
    if (welcomeEl) {
      messagesEl.appendChild(welcomeEl);
      welcomeEl.style.display = '';
    }
    inputEl.dataset.mode = '';
    inputEl.placeholder = 'Ask me anything...';
    hideModeBadge();
    try { sessionStorage.removeItem(SS_KEY_MESSAGES); } catch(e) {}
    if (engine) {
      try { engine.resetChat(); } catch(e) {}
    }
  }

  // ─── Event listeners ───

  // Close
  panelClose.addEventListener('click', closePanel);

  // Settings toggle
  settingsBtn.addEventListener('click', function() {
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? '' : 'none';
  });

  // Enable/disable toggle
  enabledToggle.addEventListener('change', function() {
    setAiEnabled(enabledToggle.checked);
  });

  // Unload button
  unloadBtn.addEventListener('click', function() {
    unloadEngine();
    addMessage('assistant', 'Model unloaded. GPU memory has been freed. The model will reload on your next message.');
  });

  // Custom context auto-save
  var _contextSaveTimeout = null;
  if (customContextEl) {
    try { customContextEl.value = localStorage.getItem(LS_KEY_CONTEXT) || ''; } catch(e) {}
    customContextEl.addEventListener('input', function() {
      if (_contextSaveTimeout) clearTimeout(_contextSaveTimeout);
      _contextSaveTimeout = setTimeout(function() {
        try { localStorage.setItem(LS_KEY_CONTEXT, customContextEl.value); } catch(e) {}
        if (contextSavedEl) {
          contextSavedEl.style.display = '';
          setTimeout(function() { contextSavedEl.style.display = 'none'; }, 1500);
        }
      }, 600);
    });
  }

  // Clear chat
  clearBtn.addEventListener('click', clearChat);

  // Mode badge cancel
  if (modeBadgeCancel) {
    modeBadgeCancel.addEventListener('click', function() {
      inputEl.dataset.mode = '';
      inputEl.placeholder = 'Ask me anything...';
      hideModeBadge();
      inputEl.focus();
    });
  }

  // Quick actions
  quickActions.addEventListener('click', function(e) {
    var btn = e.target.closest('.ai-quick-btn');
    if (!btn) return;
    var action = btn.dataset.action;
    if (action) handleQuickAction(action);
  });

  // Send message
  sendBtn.addEventListener('click', sendMessage);
  inputEl.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
  inputEl.addEventListener('input', function() {
    updateInputHeight();
    sendBtn.disabled = !inputEl.value.trim() || isGenerating;
  });

  // Stop generation
  stopBtn.addEventListener('click', function() {
    if (abortController) {
      abortController.stop();
    }
  });

  // ─── Voice input (Web Speech API) ───
  var SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
  var recognition = null;
  var isRecording = false;

  if (SpeechRecognitionAPI && micBtn) {
    micBtn.style.display = '';

    recognition = new SpeechRecognitionAPI();
    recognition.continuous = false;
    recognition.interimResults = true;
    recognition.lang = navigator.language || 'en-US';

    var _interimStart = '';

    recognition.onstart = function() {
      isRecording = true;
      micBtn.classList.add('recording');
      micBtn.title = 'Stop recording';
      _interimStart = inputEl.value;
    };

    recognition.onresult = function(event) {
      var interim = '';
      var final = '';
      for (var i = event.resultIndex; i < event.results.length; i++) {
        var transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          final += transcript;
        } else {
          interim += transcript;
        }
      }
      // Append final results; show interim as preview
      if (final) {
        var sep = _interimStart && !_interimStart.endsWith(' ') ? ' ' : '';
        _interimStart += sep + final;
        inputEl.value = _interimStart;
      } else if (interim) {
        var sep2 = _interimStart && !_interimStart.endsWith(' ') ? ' ' : '';
        inputEl.value = _interimStart + sep2 + interim;
      }
      updateInputHeight();
      sendBtn.disabled = !inputEl.value.trim() || isGenerating;
    };

    recognition.onend = function() {
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.title = 'Voice input';
      inputEl.focus();
    };

    recognition.onerror = function(event) {
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.title = 'Voice input';
      if (event.error !== 'aborted' && event.error !== 'no-speech') {
        console.warn('[AI] Speech recognition error:', event.error);
      }
    };

    micBtn.addEventListener('click', function() {
      if (isRecording) {
        recognition.stop();
      } else {
        try { recognition.start(); } catch(e) {
          // Already started
          recognition.stop();
        }
      }
    });
  }

  // Keyboard shortcuts: Escape to close side panel
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && panel.style.display !== 'none') {
      closePanel();
      return;
    }
  });

  // ─── Initialization ───
  checkWebGPU();

  // Restore enabled state
  var enabled = isAiEnabled();
  enabledToggle.checked = enabled;
  if (enabled) {
    if (!hasWebGPU) {
      notSupportedEl.style.display = '';
    }
  }

  // Restore messages
  loadMessages();

  // Restore panel state
  try {
    if (enabled && sessionStorage.getItem(SS_KEY_PANEL) === '1') {
      openPanel();
    }
  } catch(e) {}

  // ─── Public API (shared with ai-chat.html page) ───
  window.dmAI = {
    open: openPanel,
    close: closePanel,
    toggle: togglePanel,
    isEnabled: isAiEnabled,
    setEnabled: setAiEnabled,
    getStatus: function() { return aiStatus; },
    // Engine sharing: the dedicated AI page delegates to these
    _getEngine: function() {
      return engine ? Promise.resolve(engine) : Promise.reject(new Error('Engine not loaded'));
    },
    _loadEngine: function() {
      return loadEngine();
    },
    _buildSystemPrompt: buildSystemPrompt,
    _renderMarkdown: renderMarkdown,
    _detectTaskIntent: detectTaskIntent,
    _parseTaskDetails: parseTaskDetails,
    _buildTaskConfirmation: buildTaskConfirmation,
    _detectMultipleActions: detectMultipleActions,
    _detectBujoType: detectBujoType,
    _parseDate: parseDate,
    _parseTimeOfDay: _parseTimeOfDay,
    _fmtDate: _fmtDate
  };

})();
</script>
