<!-- todo-list: Time-tracked TODO list for Inbox page -->
<!-- Renders above inbox note content. Requires dm-sync and dm-todo-complete-modal. -->
<div class="todo-list" id="todo-list" style="display: none;">
  <div class="todo-list-header">
    <h3 class="todo-list-title">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
      Tasks
    </h3>
  </div>

  <div class="todo-list-body" id="todo-list-body">
    <!-- Add todo form — two rows: inputs + icon bar with chips -->
    <div class="todo-add-form" id="todo-add-form">
      <div class="todo-add-row-main">
        <input type="text" id="todo-add-title" class="todo-add-title" placeholder="What needs to be done?">
        <div class="todo-add-pomodoro-group" id="todo-add-pomodoro-group">
          <button type="button" class="todo-add-pomo-minus" id="todo-add-pomo-minus" title="Remove pomodoro" aria-label="Decrease pomodoro count">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="6" y1="12" x2="18" y2="12"></line></svg>
          </button>
          <button type="button" class="todo-add-pomodoro-btn" id="todo-add-pomodoro-btn" title="Short session (click tomato to switch)" aria-label="Pomodoro count">
            <svg class="todo-add-pomodoro-icon todo-pomo-icon-short" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 6c-.4-.9 0-1.8.6-2 .5-.2 1 .1 1.4.5.4-.4.9-.7 1.4-.5.6.2 1 1.1.6 2" fill="#b5c4ad"/><ellipse cx="12" cy="14" rx="7.5" ry="7" fill="#d9a080" stroke="#cc9474" stroke-width="0.8"/></svg>
            <svg class="todo-add-pomodoro-icon todo-pomo-icon-long" width="16" height="16" viewBox="0 0 24 28" fill="none" style="display:none;"><path d="M10.5 6c-.3-.8 0-1.5.5-1.7.4-.1.8.1 1 .5.2-.4.6-.6 1-.5.5.2.8 1 .5 1.7" fill="#4a7a3e"/><path d="M13.8 5.2c.4-.2.9 0 1.1.3.2.3.1.7-.2.9" stroke="#4a7a3e" stroke-width="0.7" fill="none" stroke-linecap="round"/><path d="M12 10.5 C11 9 9.5 7.8 7.5 7.8 C4.4 7.8 2.8 10.2 2.8 12.8 C2.8 15.5 4.5 18.5 7 21.5 C9 23.8 10.8 25.3 12 27 C13.2 25.3 15 23.8 17 21.5 C19.5 18.5 21.2 15.5 21.2 12.8 C21.2 10.2 19.6 7.8 16.5 7.8 C14.5 7.8 13 9 12 10.5Z" fill="#c4553a" stroke="#a8412e" stroke-width="0.7"/><ellipse cx="7.8" cy="12" rx="2.5" ry="2" fill="#d4776a" opacity="0.25"/></svg>
            <span class="todo-add-pomodoro-count" id="todo-add-pomodoro-count">1</span>
          </button>
          <button type="button" class="todo-add-pomo-plus" id="todo-add-pomo-plus" title="Add pomodoro" aria-label="Increase pomodoro count">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="12" y1="6" x2="12" y2="18"></line><line x1="6" y1="12" x2="18" y2="12"></line></svg>
          </button>
        </div>
        <input type="number" id="todo-add-custom-min" class="todo-add-custom-min" placeholder="min" min="0" max="999" title="Custom time override (minutes)" aria-label="Custom time in minutes">
        <button type="button" class="todo-add-mic-btn" id="todo-add-mic-btn" title="Dictate task (speech-to-text)" aria-label="Dictate task" style="display:none;">
          <svg class="todo-mic-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="1" width="6" height="11" rx="3"></rect><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
          <span class="todo-mic-pulse" id="todo-mic-pulse"></span>
        </button>
        <button type="button" id="todo-add-btn" class="todo-add-btn" title="Add task">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
      </div>
      <div class="todo-add-row-icons" id="todo-add-row-icons">
        <div class="todo-add-bujo-type-toggle" id="todo-add-bujo-type-toggle">
          <button type="button" class="todo-add-bujo-type-btn active" data-bujo-type="task" title="Task">
            <svg width="12" height="12" viewBox="0 0 16 16"><circle cx="8" cy="8" r="4" fill="currentColor"/></svg>
          </button>
          <button type="button" class="todo-add-bujo-type-btn" data-bujo-type="event" title="Event">
            <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="8" cy="8" r="5.5"/></svg>
          </button>
          <button type="button" class="todo-add-bujo-type-btn" data-bujo-type="note" title="Note">
            <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="8" x2="13" y2="8"/></svg>
          </button>
        </div>
        <button type="button" class="todo-add-icon-btn" id="todo-add-date-icon" title="Schedule date" aria-label="Schedule date">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
        </button>
        <span class="todo-add-chip" id="todo-add-date-chip" style="display:none;">
          <span class="todo-add-chip-text" id="todo-add-date-chip-text"></span>
          <button type="button" class="todo-add-chip-clear" id="todo-add-date-chip-clear" aria-label="Clear date">&times;</button>
        </span>
        <button type="button" class="todo-add-icon-btn" id="todo-add-reminder-icon" title="Set reminder" aria-label="Set reminder">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
        </button>
        <span class="todo-add-chip" id="todo-add-reminder-chip" style="display:none;">
          <span class="todo-add-chip-text" id="todo-add-reminder-chip-text"></span>
          <button type="button" class="todo-add-chip-clear" id="todo-add-reminder-chip-clear" aria-label="Clear reminder">&times;</button>
        </span>
        <div class="todo-add-category-icon-wrap" id="todo-add-category-icon-wrap">
          <button type="button" class="todo-add-icon-btn" id="todo-add-category-icon" title="Set category" aria-label="Set category">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>
          </button>
          <div class="todo-add-category-popover" id="todo-add-category-popover" style="display:none;">
            <input type="text" id="todo-add-category-input" class="todo-add-category-search" placeholder="Search or add category..." autocomplete="off">
            <div class="todo-add-category-dropdown" id="todo-add-category-dropdown"></div>
          </div>
        </div>
        <span class="todo-add-chip" id="todo-add-category-chip" style="display:none;">
          <span class="todo-add-chip-text" id="todo-add-category-chip-text"></span>
          <button type="button" class="todo-add-chip-clear" id="todo-add-category-chip-clear" aria-label="Clear category">&times;</button>
        </span>
      </div>
      <div class="todo-add-hints" id="todo-add-hints">
        <span><kbd>Enter</kbd> to add</span>
        <span class="todo-add-hints-sep">&middot;</span>
        <span><kbd>&#x21E7;Enter</kbd> to add another</span>
        <span class="todo-add-hints-sep">&middot;</span>
        <span><kbd>Esc</kbd> to close</span>
      </div>
    </div>

    <!-- Todo items rendered here -->
    <div class="todo-items" id="todo-items"></div>

    <!-- Summary -->
    <div class="todo-summary" id="todo-summary" style="display: none;"></div>
  </div>
</div>

<!-- Backdrop for elevated add-form focus mode (outside .todo-list to avoid overflow:hidden clipping) -->
<div class="todo-add-backdrop" id="todo-add-backdrop"></div>

<!-- Delete modal is created dynamically via JS and appended to document.body -->

<style>
.todo-list {
  position: relative;
  margin-bottom: 1.5rem;
  border: 1px solid var(--gray-200);
  border-radius: 12px;
  overflow: hidden;
}
.todo-list-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background: var(--gray-100);
  border-bottom: 1px solid var(--gray-200);
}
.todo-list-title {
  margin: 0;
  font-size: 0.9rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--body-font-color);
}
.todo-list-title svg {
  color: var(--color-link);
}

.todo-list-body {
  padding: 0.75rem 1rem;
}

/* Add form — two-row layout */
.todo-add-form {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 0.75rem;
}
.todo-add-row-main {
  display: flex;
  gap: 0;
  align-items: center;
  position: relative;
  border: 1px solid var(--gray-300);
  border-radius: 10px;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.todo-add-row-main:focus-within {
  border-color: var(--color-link);
  box-shadow: 0 0 0 2px rgba(0, 105, 255, 0.08);
}
.todo-add-row-main > :first-child {
  border-radius: 9px 0 0 9px;
}
.todo-add-row-main > :last-child {
  border-radius: 0 9px 9px 0;
}
/* Icon bar row with chips */
.todo-add-row-icons {
  display: flex;
  align-items: center;
  gap: 6px;
  padding-left: 2px;
  position: relative;
}
.todo-add-bujo-type-toggle {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  padding: 2px;
  background: var(--body-background);
  margin-right: 2px;
}
.todo-add-bujo-type-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 4px;
  background: transparent;
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  line-height: 0;
  padding: 0;
}
.todo-add-bujo-type-btn:hover {
  color: var(--body-font-color);
  background: var(--gray-100);
}
.todo-add-bujo-type-btn.active {
  color: var(--body-font-color);
  background: var(--gray-200);
}
.todo-add-bujo-type-btn[data-bujo-type="task"].active { color: #3d3d3d; }
.todo-add-bujo-type-btn[data-bujo-type="event"].active { color: #4a7a9b; }
.todo-add-bujo-type-btn[data-bujo-type="note"].active { color: #888888; }
.todo-add-icon-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s, background 0.15s;
  line-height: 0;
  flex-shrink: 0;
  position: relative;
}
.todo-add-icon-btn:hover {
  color: var(--color-link);
  border-color: var(--color-link);
}
.todo-add-icon-btn.active {
  color: var(--color-link);
  border-color: var(--color-link);
  background: rgba(0, 105, 255, 0.06);
}
/* Chip tags next to icons */
.todo-add-chip {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 2px 8px 2px 8px;
  border-radius: 12px;
  font-size: 0.72rem;
  font-weight: 500;
  background: rgba(0, 105, 255, 0.08);
  color: var(--color-link);
  white-space: nowrap;
  line-height: 1.4;
}
.todo-add-chip-text {
  pointer-events: none;
}
.todo-add-chip-clear {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border: none;
  border-radius: 50%;
  background: none;
  color: var(--color-link);
  font-size: 0.85rem;
  line-height: 1;
  cursor: pointer;
  padding: 0;
  transition: background 0.15s, color 0.15s;
}
.todo-add-chip-clear:hover {
  background: rgba(0, 105, 255, 0.15);
}
/* ─── Category icon + popover ─── */
.todo-add-category-icon-wrap {
  position: relative;
}
.todo-add-category-popover {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 30;
  width: 240px;
  margin-top: 4px;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.12);
  animation: todo-popover-in 0.15s ease-out;
  overflow: hidden;
}
.todo-add-category-search {
  width: 100%;
  padding: 8px 10px;
  border: none;
  border-bottom: 1px solid var(--gray-200);
  font-size: 0.8rem;
  background: transparent;
  color: var(--body-font-color);
  box-sizing: border-box;
  outline: none;
}
.todo-add-category-search::placeholder {
  color: var(--gray-400);
}
.todo-add-category-dropdown {
  display: none;
  flex-wrap: wrap;
  gap: 5px;
  padding: 6px;
  max-height: 150px;
  overflow-y: auto;
}
.todo-add-category-dropdown.show {
  display: flex;
}
.todo-add-category-chip {
  display: inline-flex;
  align-items: center;
  padding: 3px 10px;
  font-size: 0.75rem;
  font-weight: 500;
  color: var(--color-link);
  background: rgba(0, 105, 255, 0.08);
  border: 1px solid rgba(0, 105, 255, 0.12);
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
  white-space: nowrap;
  line-height: 1.5;
  user-select: none;
}
.todo-add-category-chip:hover {
  background: rgba(0, 105, 255, 0.15);
  border-color: rgba(0, 105, 255, 0.25);
}
.todo-add-category-chip.active {
  background: rgba(0, 105, 255, 0.18);
  border-color: var(--color-link);
  box-shadow: 0 0 0 1px var(--color-link);
}
.todo-add-category-chip .cat-highlight {
  font-weight: 700;
  text-decoration: underline;
  text-decoration-color: var(--color-link);
  text-underline-offset: 2px;
}
/* Add-form popover (reuses reminder popover styles but positioned for the icon bar) */
.todo-add-popover {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 20;
  width: 220px;
  margin-top: 4px;
  padding: 10px;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 10px;
  box-shadow: 0 4px 16px var(--shadow-color, rgba(0,0,0,0.1));
  display: flex;
  flex-direction: column;
  gap: 6px;
  animation: todo-popover-in 0.15s ease-out;
}
.todo-add-popover-title {
  font-size: 0.72rem;
  font-weight: 600;
  color: var(--gray-500);
  text-transform: uppercase;
  letter-spacing: 0.04em;
  margin-bottom: 2px;
}
.todo-add-popover-shortcut {
  display: block;
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--body-font-color);
  font-size: 0.78rem;
  text-align: left;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
}
.todo-add-popover-shortcut:hover {
  background: var(--gray-100);
  border-color: var(--color-link);
}
.todo-add-popover-custom {
  display: flex;
  gap: 4px;
  align-items: center;
}
.todo-add-popover-input {
  flex: 1;
  padding: 5px 8px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  font-size: 0.75rem;
  background: var(--body-background);
  color: var(--body-font-color);
}
.todo-add-popover-input:focus {
  outline: none;
  border-color: var(--color-link);
}
.todo-add-popover-set {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: 1px solid var(--color-link);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--color-link);
  cursor: pointer;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
}
.todo-add-popover-set:hover {
  background: var(--color-link);
  color: #fff;
}
.todo-add-title {
  flex: 1;
  padding: 9px 12px;
  border: none;
  border-radius: 0;
  font-size: 0.88rem;
  background: transparent;
  color: var(--body-font-color);
  outline: none;
  min-width: 0;
}
.todo-add-title:focus {
  outline: none;
}
.todo-add-title::placeholder {
  color: var(--gray-400);
}
/* Pomodoro button group in add-form main row */
.todo-add-pomodoro-group {
  display: inline-flex;
  align-items: center;
  border-left: 1px solid var(--gray-200);
  flex-shrink: 0;
  height: 36px;
  box-sizing: border-box;
}
.todo-add-pomo-minus,
.todo-add-pomo-plus {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 26px;
  height: 36px;
  padding: 0;
  border: none;
  background: transparent;
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  flex-shrink: 0;
}
.todo-add-pomo-minus:hover,
.todo-add-pomo-plus:hover {
  background: var(--gray-100);
  color: var(--color-link);
}
.todo-add-pomo-minus:disabled {
  opacity: 0.25;
  cursor: default;
  pointer-events: none;
}
.todo-add-pomodoro-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 6px;
  border: none;
  border-left: 1px solid var(--gray-200);
  border-right: 1px solid var(--gray-200);
  border-radius: 0;
  background: transparent;
  color: var(--gray-500);
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  flex-shrink: 0;
  user-select: none;
  -webkit-user-select: none;
  line-height: 1;
  height: 36px;
  box-sizing: border-box;
}
.todo-add-pomodoro-btn:hover {
  background: var(--gray-100);
  color: var(--color-link);
}
.todo-add-pomodoro-btn.has-count {
  color: var(--color-link);
  background: rgba(0, 105, 255, 0.06);
}
.todo-add-pomodoro-icon {
  flex-shrink: 0;
}
.todo-add-pomodoro-count {
  font-size: 0.82rem;
  font-weight: 700;
  min-width: 14px;
  text-align: center;
}
/* Pomodoro icon click-to-toggle transition */
.todo-add-pomodoro-icon {
  transition: transform 0.2s ease;
}
.todo-add-pomodoro-btn:active .todo-add-pomodoro-icon {
  transform: scale(0.85);
}
/* ─── Custom minutes override input ─── */
.todo-add-custom-min {
  width: 42px;
  padding: 4px 4px;
  border: none;
  border-left: 1px solid var(--gray-200);
  border-radius: 0;
  background: transparent;
  color: var(--body-font-color);
  font-size: 0.78rem;
  text-align: center;
  outline: none;
  height: 36px;
  box-sizing: border-box;
  flex-shrink: 0;
  -moz-appearance: textfield;
  appearance: textfield;
}
.todo-add-custom-min::-webkit-inner-spin-button,
.todo-add-custom-min::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.todo-add-custom-min::placeholder {
  color: var(--gray-400);
  font-size: 0.72rem;
}
.todo-add-custom-min:focus {
  background: rgba(0, 105, 255, 0.04);
}
/* ─── Mic (speech-to-text) button ─── */
.todo-add-mic-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border: none;
  border-left: 1px solid var(--gray-200);
  border-radius: 0;
  background: transparent;
  color: var(--gray-500);
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  flex-shrink: 0;
  line-height: 0;
  box-sizing: border-box;
}
.todo-add-mic-btn:hover {
  background: var(--gray-100);
  color: var(--color-link);
}
.todo-add-mic-btn.recording {
  color: var(--color-danger, #e53e3e);
  background: var(--color-danger-bg, rgba(229, 62, 62, 0.06));
}
.todo-mic-pulse {
  display: none;
  position: absolute;
  top: 4px;
  right: 4px;
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: var(--color-danger, #e53e3e);
  animation: todo-mic-pulse-anim 1s ease-in-out infinite;
}
.todo-add-mic-btn.recording .todo-mic-pulse {
  display: block;
}
@keyframes todo-mic-pulse-anim {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(1.3); }
}

/* ─── Elevated add-form focus mode ─── */
.todo-add-backdrop {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 1199;
  background: rgba(0, 0, 0, 0.55);
}
.todo-add-backdrop.visible {
  display: block;
}
.todo-add-form.elevated {
  position: fixed;
  z-index: 1200;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 96%;
  max-width: 780px;
  background: var(--body-background, #fff);
  border-radius: 16px;
  padding: 1.25rem 1.5rem;
  margin-bottom: 0;
  animation: todo-form-elevate 0.18s ease-out;
}
@keyframes todo-form-elevate {
  from { opacity: 0; transform: translate(-50%, -50%) translateY(-8px) scale(0.98); }
  to   { opacity: 1; transform: translate(-50%, -50%) translateY(0) scale(1); }
}
.todo-add-form.elevated .todo-add-row-main {
  border-color: var(--color-link);
  box-shadow: 0 0 0 2px rgba(0, 105, 255, 0.08);
}
.todo-add-form.elevated .todo-add-title {
  padding: 14px 16px;
  font-size: 1.1rem;
}
.todo-add-form.elevated .todo-add-pomodoro-group {
  height: 46px;
}
.todo-add-form.elevated .todo-add-row-icons {
  gap: 10px;
  padding-top: 6px;
}
/* Keyboard shortcut hints — only visible in elevated mode */
.todo-add-hints {
  display: none;
}
.todo-add-form.elevated .todo-add-hints {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding-top: 10px;
  font-size: 0.72rem;
  color: var(--gray-400);
}
.todo-add-hints kbd {
  display: inline-block;
  padding: 1px 5px;
  border: 1px solid var(--gray-300);
  border-radius: 4px;
  background: var(--gray-100);
  font-family: inherit;
  font-size: 0.68rem;
  line-height: 1.4;
}
.todo-add-hints-sep {
  color: var(--gray-300);
}

/* Day group headers */
.todo-day-group {
  margin-bottom: 4px;
}
.todo-day-group:not(:first-child) {
  margin-top: 12px;
}
.todo-day-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--gray-500);
  border-left: 3px solid var(--gray-300);
  margin-bottom: 4px;
  cursor: pointer;
  user-select: none;
  transition: background 0.15s;
}
.todo-day-header:hover {
  background: var(--gray-100);
}
.todo-day-header.today {
  color: var(--color-link);
  border-left-color: var(--color-link);
  background: rgba(0, 105, 255, 0.04);
}
.todo-day-header.today:hover {
  background: rgba(0, 105, 255, 0.08);
}
.todo-day-header.overdue {
  color: var(--color-danger);
  border-left-color: var(--color-danger);
  background: var(--color-danger-bg);
}
.todo-day-header.tomorrow {
  color: var(--color-success);
  border-left-color: var(--color-success);
}
.todo-day-chevron {
  display: inline-flex;
  align-items: center;
  transition: transform 0.2s;
  flex-shrink: 0;
}
.todo-day-group.collapsed .todo-day-chevron {
  transform: rotate(-90deg);
}
.todo-day-group.collapsed .todo-day-group-items {
  display: none;
}
.todo-day-badge {
  font-size: 0.68rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}
.todo-day-label {
  font-weight: 500;
  flex: 1;
}
.todo-day-progress {
  font-size: 0.68rem;
  font-weight: 500;
  color: var(--gray-400);
  margin-left: auto;
}
.todo-add-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 36px;
  border: none;
  border-left: 1px solid var(--gray-200);
  border-radius: 0;
  background: transparent;
  color: var(--color-link);
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  flex-shrink: 0;
  line-height: 0;
}
.todo-add-btn:hover {
  background: var(--color-link);
  color: #fff;
}
.todo-add-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Todo items */
.todo-items {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.todo-empty {
  text-align: center;
  padding: 1.25rem 1rem;
  color: var(--gray-500);
  font-size: 0.85rem;
}
.todo-item {
  display: flex;
  align-items: flex-start;
  gap: 6px;
  padding: 6px 10px;
  border-radius: 8px;
  transition: background 0.15s;
}
.todo-item:hover {
  background: var(--gray-100);
}

/* Drag handle */
.todo-drag-handle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 14px;
  min-height: 20px;
  margin-top: 2px;
  color: var(--gray-300);
  cursor: grab;
  flex-shrink: 0;
  opacity: 0;
  transition: opacity 0.15s, color 0.15s;
  touch-action: none;
}
.todo-drag-handle-spacer {
  width: 14px;
  flex-shrink: 0;
}
.todo-item:hover .todo-drag-handle,
.todo-item-group:hover > .todo-item .todo-drag-handle {
  opacity: 1;
}
.todo-drag-handle:hover {
  color: var(--gray-500);
}
.todo-drag-handle:active {
  cursor: grabbing;
}

/* Drag states */
.todo-item-group {
  border-radius: 8px;
}
.todo-drag-ghost {
  opacity: 0.4;
  background: var(--gray-100);
  border-radius: 8px;
}
.todo-drag-chosen {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
  border-radius: 8px;
  background: var(--body-background);
  z-index: 10;
}
.todo-drag-active {
  opacity: 0.9;
}
.todo-item.done {
  opacity: 0.6;
}
.todo-item.done.just-completed {
  animation: todo-slide-down 0.35s ease-out;
}
@keyframes todo-slide-down {
  from { opacity: 0.3; transform: translateY(-8px); }
  to { opacity: 0.6; transform: translateY(0); }
}
.todo-bujo-bullet {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 22px;
  margin-top: 1px;
  padding: 0;
  border: 1.5px solid transparent;
  background: none;
  cursor: pointer;
  flex-shrink: 0;
  border-radius: 4px;
  transition: background 0.15s, border-color 0.2s;
  position: relative;
}
.todo-bujo-bullet:hover {
  background: var(--gray-100);
}
.todo-bujo-bullet svg {
  display: block;
}
/* Task states */
.todo-bujo-bullet.bujo-task-open svg { color: #3d3d3d; }
.todo-bujo-bullet.bujo-task-done svg { color: #7a7a7a; }
.todo-bujo-bullet.bujo-task-migrated svg { color: #8b6e4e; }
.todo-bujo-bullet.bujo-task-scheduled svg { color: #5b7a8a; }

/* Open task: subtle ring at rest to signal interactivity */
.todo-bujo-bullet.bujo-task-open {
  border: 1.5px solid rgba(61, 61, 61, 0.2);
  border-radius: 50%;
  transition: border-color 0.2s, background 0.15s;
}
.todo-bujo-bullet.bujo-task-open:hover {
  border-color: rgba(122, 122, 122, 0.5);
  background: rgba(122, 122, 122, 0.08);
}

/* Open task: dot/X swap on hover */
.todo-bujo-bullet.bujo-task-open .bujo-icon-rest {
  display: block;
  transition: opacity 0.15s;
}
.todo-bujo-bullet.bujo-task-open .bujo-icon-hover {
  display: none;
  position: absolute;
  color: #7a7a7a;
}
.todo-bujo-bullet.bujo-task-open:hover .bujo-icon-rest {
  display: none;
}
.todo-bujo-bullet.bujo-task-open:hover .bujo-icon-hover {
  display: block;
}

/* Done task: show dot on hover to hint "click to reopen" */
.todo-bujo-bullet.bujo-task-done {
  border: 1.5px solid transparent;
  border-radius: 50%;
  transition: border-color 0.2s, background 0.15s;
}
.todo-bujo-bullet.bujo-task-done:hover {
  border-color: rgba(61, 61, 61, 0.2);
  background: rgba(61, 61, 61, 0.06);
}
/* Event */
.todo-bujo-bullet.bujo-event svg { color: #4a7a9b; }
.todo-bujo-bullet.bujo-event .bujo-icon-rest { display: block; }
.todo-bujo-bullet.bujo-event .bujo-icon-hover { display: none; position: absolute; color: #7a7a7a; }
.todo-bujo-bullet.bujo-event:hover .bujo-icon-rest { display: none; }
.todo-bujo-bullet.bujo-event:hover .bujo-icon-hover { display: block; }
/* Event done — muted event blue to retain type identity */
.todo-bujo-bullet.bujo-event-done svg { color: #7a9aab; }
.todo-bujo-bullet.bujo-event-done .bujo-icon-rest { display: block; }
.todo-bujo-bullet.bujo-event-done .bujo-icon-hover { display: none; position: absolute; color: #4a7a9b; }
.todo-bujo-bullet.bujo-event-done:hover .bujo-icon-rest { display: none; }
.todo-bujo-bullet.bujo-event-done:hover .bujo-icon-hover { display: block; }
.todo-bujo-bullet.bujo-event-done:hover {
  border-color: rgba(74, 122, 155, 0.2);
  background: rgba(74, 122, 155, 0.06);
}
/* Note */
.todo-bujo-bullet.bujo-note svg { color: #888888; }
.todo-bujo-bullet.bujo-note .bujo-icon-rest { display: block; }
.todo-bujo-bullet.bujo-note .bujo-icon-hover { display: none; position: absolute; color: #7a7a7a; }
.todo-bujo-bullet.bujo-note:hover .bujo-icon-rest { display: none; }
.todo-bujo-bullet.bujo-note:hover .bujo-icon-hover { display: block; }
/* Note done */
.todo-bujo-bullet.bujo-note-done svg { color: #7a7a7a; }
.todo-bujo-bullet.bujo-note-done .bujo-icon-rest { display: block; }
.todo-bujo-bullet.bujo-note-done .bujo-icon-hover { display: none; position: absolute; color: #888; }
.todo-bujo-bullet.bujo-note-done:hover .bujo-icon-rest { display: none; }
.todo-bujo-bullet.bujo-note-done:hover .bujo-icon-hover { display: block; }
.todo-bujo-bullet.bujo-note-done:hover {
  border-color: rgba(136, 136, 136, 0.2);
  background: rgba(136, 136, 136, 0.06);
}
/* Migrated / scheduled title treatment */
/* Migrate to Today button in overdue day group headers */
.todo-day-migrate-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border: 1px solid var(--gray-300, #ddd);
  border-radius: 6px;
  background: transparent;
  color: var(--color-danger, #e53e3e);
  font-size: 0.65rem;
  font-weight: 600;
  cursor: pointer;
  margin-left: 8px;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
  white-space: nowrap;
}
.todo-day-migrate-btn:hover {
  background: var(--color-danger, #e53e3e);
  color: #fff;
}
.todo-day-migrate-btn svg {
  flex-shrink: 0;
}

/* Individual migrate action button on overdue open tasks */
.todo-item-action-btn.migrate-today {
  color: #8b6e4e;
}
.todo-item-action-btn.migrate-today:hover {
  color: #6b4e2e;
  background: rgba(139, 110, 78, 0.1);
}

/* Highlight flash on newly added tasks */
@keyframes todo-item-flash {
  0%   { background: rgba(0, 105, 255, 0.12); }
  100% { background: transparent; }
}
.todo-item.just-added {
  animation: todo-item-flash 1.5s ease-out;
}

/* Migration removes line-through — migrated tasks on today show > but normal title */
.todo-item.migrated .todo-item-title {
  text-decoration: none;
  color: #8b6e4e;
}
.todo-item.scheduled .todo-item-title {
  color: #5b7a8a;
}
/* BuJo state picker popover */
.todo-state-picker {
  position: absolute;
  z-index: 200;
  background: var(--body-background, #fff);
  border: 1px solid var(--gray-200, #e5e5e5);
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.12);
  padding: 4px 0;
  min-width: 160px;
}
.todo-state-picker-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 12px;
  cursor: pointer;
  font-size: 0.82rem;
  color: var(--body-font-color, #333);
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  border-radius: 0;
}
.todo-state-picker-item:hover {
  background: var(--gray-100, #f5f5f5);
}
.todo-state-picker-item.active {
  font-weight: 600;
  background: var(--gray-50, #fafafa);
}
.todo-state-picker-item svg {
  flex-shrink: 0;
}
.todo-state-picker-sep {
  height: 1px;
  background: var(--gray-200, #e5e5e5);
  margin: 4px 0;
}
/* BuJo migration date prompt */
.todo-migrate-prompt {
  position: absolute;
  z-index: 210;
  background: var(--body-background, #fff);
  border: 1px solid var(--gray-200, #e5e5e5);
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.12);
  padding: 12px;
  min-width: 200px;
}
.todo-migrate-prompt label {
  display: block;
  font-size: 0.78rem;
  color: var(--gray-500, #888);
  margin-bottom: 4px;
}
.todo-migrate-prompt input[type="date"] {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--gray-300, #ccc);
  border-radius: 6px;
  font-size: 0.84rem;
  margin-bottom: 8px;
}
.todo-migrate-prompt-actions {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
}
.todo-migrate-prompt-actions button {
  padding: 4px 12px;
  border-radius: 6px;
  font-size: 0.78rem;
  cursor: pointer;
  border: 1px solid var(--gray-300, #ccc);
  background: var(--body-background, #fff);
}
.todo-migrate-prompt-actions button.primary {
  background: var(--color-link, #0070f3);
  color: #fff;
  border-color: var(--color-link, #0070f3);
}
.todo-item-content {
  flex: 1;
  min-width: 0;
}
.todo-item-title {
  font-size: 0.88rem;
  line-height: 1.4;
  word-break: break-word;
}
.todo-item.done .todo-item-title {
  text-decoration: line-through;
  color: var(--gray-500);
}
.todo-item-ai-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: var(--accent-ai, #00bcb4);
  margin-right: 4px;
  vertical-align: middle;
  opacity: 0.8;
  position: relative;
  top: -1px;
}
.todo-item.done .todo-item-ai-badge {
  opacity: 0.4;
}
.todo-item-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 1px;
  flex-wrap: wrap;
}
.todo-item-estimate,
.todo-item-actual,
.todo-item-category {
  font-size: 0.68rem;
  color: var(--gray-400);
}
.todo-item-estimate {
  background: var(--gray-100);
  padding: 1px 5px;
  border-radius: 4px;
}
.todo-item-actual {
  padding: 1px 5px;
  border-radius: 4px;
}
.todo-item-actual.over {
  background: var(--color-danger-bg);
  color: var(--color-danger);
}
.todo-item-actual.under {
  background: var(--color-success-bg);
  color: var(--color-success);
}
.todo-item-category {
  background: rgba(0, 105, 255, 0.08);
  color: var(--color-link);
  padding: 1px 5px;
  border-radius: 4px;
  font-weight: 500;
}
.todo-item-finish-at {
  font-size: 0.66rem;
  color: var(--gray-400);
  padding: 1px 5px;
  border-radius: 4px;
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  gap: 3px;
}
.todo-item-finish-at svg {
  flex-shrink: 0;
  opacity: 0.6;
}

.todo-item-actions {
  display: flex;
  gap: 2px;
  opacity: 0;
  transition: opacity 0.15s;
}
.todo-item:hover .todo-item-actions {
  opacity: 1;
}
.todo-item-action-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 26px;
  height: 26px;
  border: none;
  border-radius: 6px;
  background: none;
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  line-height: 0;
}
.todo-item-action-btn:hover {
  background: var(--gray-200);
  color: var(--body-font-color);
}
.todo-item-action-btn.delete:hover {
  color: var(--color-danger);
  background: var(--color-danger-bg);
}
.todo-item-action-btn.archive:hover {
  color: var(--color-link);
  background: rgba(66, 133, 244, 0.1);
}
.todo-item-action-btn.edit:hover {
  color: var(--color-link);
  background: rgba(66, 133, 244, 0.1);
}

/* Subtask collapse toggle */
.todo-subtask-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 22px;
  margin-top: 1px;
  border: none;
  border-radius: 4px;
  background: none;
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, background 0.15s, transform 0.2s;
  flex-shrink: 0;
  line-height: 0;
  padding: 0;
}
.todo-subtask-toggle:hover {
  background: var(--gray-200);
  color: var(--body-font-color);
}
.todo-subtask-toggle svg {
  transition: transform 0.2s;
}
.todo-subtask-toggle.collapsed svg {
  transform: rotate(-90deg);
}
.todo-subtask-spacer {
  width: 22px;
  flex-shrink: 0;
}
.todo-subtasks-wrapper.collapsed .todo-subtasks,
.todo-subtasks-wrapper.collapsed .todo-add-subtask-row {
  display: none;
}

/* Subtasks */
.todo-subtasks {
  margin-left: 48px;
  padding-left: 8px;
  border-left: 2px solid var(--gray-200);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.todo-add-subtask-row {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-left: 48px;
  margin-top: 2px;
  margin-bottom: 4px;
}
.todo-add-subtask-input {
  flex: 1;
  padding: 5px 10px;
  border: 1px solid var(--gray-300);
  border-radius: 6px;
  font-size: 0.82rem;
  background: var(--body-background);
  color: var(--body-font-color);
}
.todo-add-subtask-input:focus {
  outline: none;
  border-color: var(--color-link);
}
.todo-add-subtask-estimate {
  width: 55px;
  padding: 5px 8px;
  border: 1px solid var(--gray-300);
  border-radius: 6px;
  font-size: 0.82rem;
  background: var(--body-background);
  color: var(--body-font-color);
  text-align: center;
}
.todo-add-subtask-estimate:focus {
  outline: none;
  border-color: var(--color-link);
}
.todo-add-subtask-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: 1px solid var(--color-link);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--color-link);
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  flex-shrink: 0;
  line-height: 0;
}
.todo-add-subtask-btn:hover {
  background: var(--color-link);
  color: #fff;
}

/* Summary bar */
.todo-summary {
  margin-top: 0.75rem;
  padding: 8px 12px;
  border-radius: 8px;
  background: var(--gray-100);
  font-size: 0.78rem;
  color: var(--gray-500);
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}
.todo-summary-item {
  display: flex;
  align-items: center;
  gap: 4px;
}
.todo-summary-item strong {
  color: var(--body-font-color);
  font-weight: 600;
}

/* Clear all completed bar */
.todo-clear-all-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 0.5rem;
  padding: 6px 4px;
  border-top: 1px solid var(--gray-200);
}
.todo-clear-all-count {
  font-size: 0.78rem;
  color: var(--gray-400);
  font-weight: 500;
  padding-left: 4px;
}
.todo-clear-all-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: none;
  border: 1px solid transparent;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 0.75rem;
  color: var(--gray-400);
  cursor: pointer;
  transition: background 0.15s, color 0.15s, border-color 0.15s;
}
.todo-clear-all-btn:hover {
  color: var(--color-danger, #e53e3e);
  background: var(--color-danger-bg, rgba(229, 62, 62, 0.06));
  border-color: var(--color-danger, #e53e3e);
}

/* Toast notifications */
.todo-toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 0.82rem;
  font-weight: 500;
  opacity: 0;
  transition: opacity 0.3s, transform 0.3s;
  z-index: 9999;
  pointer-events: none;
  white-space: nowrap;
}
.todo-toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
.todo-toast-error {
  background: var(--color-danger-bg, #fee);
  color: var(--color-danger, #c53030);
  border: 1px solid var(--color-danger, #c53030);
}
.todo-toast-undo {
  background: var(--sidebar-bg, #f7f7f7);
  color: var(--body-font-color, #333);
  border: 1px solid var(--border-medium, #ddd);
  box-shadow: 0 4px 16px rgba(0,0,0,0.12);
  display: flex;
  align-items: center;
  gap: 12px;
  pointer-events: auto;
  padding: 8px 10px 8px 16px;
}
.todo-undo-label {
  font-size: 0.8rem;
  opacity: 0.85;
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
}
.todo-undo-btn {
  background: none;
  border: none;
  color: var(--accent-blue, #1976d2);
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 6px;
  transition: background 0.15s;
  white-space: nowrap;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}
.todo-undo-btn:hover {
  background: rgba(25, 118, 210, 0.08);
}

/* Mobile responsiveness */
@media screen and (max-width: 500px) {
  .todo-add-row-main {
    flex-wrap: wrap;
  }
  .todo-add-title {
    flex: 1 1 100%;
    border-bottom: 1px solid var(--gray-300);
    border-radius: 9px 9px 0 0 !important;
  }
  .todo-add-row-main > :nth-child(2) {
    border-left: none !important;
    border-radius: 0 0 0 9px !important;
  }
  .todo-add-row-main > :last-child {
    border-radius: 0 0 9px 0 !important;
  }

  .todo-add-row-icons {
    flex-wrap: wrap;
  }
  .todo-item-actions {
    opacity: 1;
  }
  .todo-day-header {
    font-size: 0.72rem;
    padding: 5px 8px;
    gap: 6px;
  }
  .todo-reminder-popover {
    right: auto;
    left: 0;
  }
  .todo-add-popover {
    left: 0;
    right: auto;
    width: min(220px, calc(100vw - 2rem));
  }
}

/* Reminder bell icon */
.todo-item-action-btn.reminder-bell {
  position: relative;
}
.todo-item-action-btn.reminder-bell.has-reminder {
  color: var(--color-link);
  opacity: 1;
}
.todo-item-action-btn.reminder-bell.has-reminder:hover {
  background: rgba(0, 105, 255, 0.08);
  color: var(--color-link);
}

/* Inline pomodoro start/pause/stop in meta row */
.todo-item-pomo-inline {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 18px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background: rgba(0, 105, 255, 0.06);
  color: var(--gray-400);
  cursor: pointer;
  transition: color 0.15s, background 0.15s, transform 0.1s, opacity 0.15s;
  line-height: 0;
  flex-shrink: 0;
  vertical-align: middle;
}
.todo-item-pomo-inline:hover {
  background: rgba(0, 105, 255, 0.14);
  color: var(--accent-blue, var(--color-link));
  transform: scale(1.1);
}
.todo-item-pomo-inline.active {
  color: var(--accent-blue, var(--color-link));
  background: rgba(0, 105, 255, 0.1);
  animation: pomo-btn-pulse 2s ease-in-out infinite;
}
.todo-item-pomo-inline.pomo-stop {
  color: var(--color-danger, #ea4335);
  background: rgba(234, 67, 53, 0.06);
}
.todo-item-pomo-inline.pomo-stop:hover {
  background: rgba(234, 67, 53, 0.14);
  color: var(--color-danger, #ea4335);
}
/* Hide inactive pomodoro start button until row hover */
.todo-item-pomo-inline.pomodoro-start:not(.active) {
  opacity: 0;
}
.todo-item:hover .todo-item-pomo-inline.pomodoro-start:not(.active) {
  opacity: 1;
}
@keyframes pomo-btn-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Reminder info text under task title */
.todo-item-reminder {
  font-size: 0.68rem;
  color: var(--color-link);
  display: flex;
  align-items: center;
  gap: 3px;
}
.todo-item-reminder.overdue {
  color: var(--color-danger);
}

/* Reminder popover — positioned relative to .todo-item */
.todo-reminder-popover {
  position: absolute;
  z-index: 20;
  width: 220px;
  padding: 10px;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 10px;
  box-shadow: 0 4px 16px var(--shadow-color, rgba(0,0,0,0.1));
  display: flex;
  flex-direction: column;
  gap: 6px;
  animation: todo-popover-in 0.15s ease-out;
}
@keyframes todo-popover-in {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.todo-reminder-popover-title {
  font-size: 0.72rem;
  font-weight: 600;
  color: var(--gray-500);
  text-transform: uppercase;
  letter-spacing: 0.04em;
  margin-bottom: 2px;
}
.todo-reminder-shortcuts {
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.todo-reminder-shortcut-btn {
  display: block;
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--body-font-color);
  font-size: 0.78rem;
  text-align: left;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
}
.todo-reminder-shortcut-btn:hover {
  background: var(--gray-100);
  border-color: var(--color-link);
}
.todo-reminder-custom {
  display: flex;
  gap: 4px;
  align-items: center;
}
.todo-reminder-datetime {
  flex: 1;
  padding: 5px 8px;
  border: 1px solid var(--gray-200);
  border-radius: 6px;
  font-size: 0.75rem;
  background: var(--body-background);
  color: var(--body-font-color);
}
.todo-reminder-datetime:focus {
  outline: none;
  border-color: var(--color-link);
}
.todo-reminder-set-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: 1px solid var(--color-link);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--color-link);
  cursor: pointer;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
}
.todo-reminder-set-btn:hover {
  background: var(--color-link);
  color: #fff;
}
.todo-reminder-clear-btn {
  display: block;
  width: 100%;
  padding: 5px 10px;
  border: 1px solid var(--color-danger, #e53e3e);
  border-radius: 6px;
  background: var(--body-background);
  color: var(--color-danger, #e53e3e);
  font-size: 0.75rem;
  text-align: center;
  cursor: pointer;
  transition: background 0.15s;
}
.todo-reminder-clear-btn:hover {
  background: var(--color-danger-bg, rgba(229, 62, 62, 0.06));
}

/* ─── Delete confirmation modal ─── */
.todo-delete-modal {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  z-index: 1200;
  display: flex;
  align-items: center;
  justify-content: center;
}
.todo-delete-backdrop {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}
.todo-delete-dialog {
  position: relative;
  background: var(--body-background);
  border-radius: 14px;
  padding: 1.5rem;
  width: 94%;
  max-width: 380px;
  box-shadow: 0 24px 64px rgba(0,0,0,0.3);
  animation: todo-delete-in 0.2s ease-out;
}
@keyframes todo-delete-in {
  from { opacity: 0; transform: translateY(12px) scale(0.97); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
.todo-delete-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}
.todo-delete-header h3 { margin: 0; font-size: 1.05rem; font-weight: 700; }
.todo-delete-close {
  background: none; border: none; font-size: 1.5rem;
  cursor: pointer; color: var(--body-font-color); padding: 4px 8px;
  border-radius: 6px; transition: background 0.15s;
}
.todo-delete-close:hover { background: var(--gray-100); }
.todo-delete-message {
  font-size: 0.9rem;
  color: var(--body-font-color);
  margin: 0 0 1.25rem 0;
  line-height: 1.5;
}
.todo-delete-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}
.todo-delete-btn-cancel,
.todo-delete-btn-confirm {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border-radius: 8px;
  border: 1px solid var(--gray-300);
  background: var(--body-background);
  color: var(--body-font-color);
  font-size: 0.85rem;
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
}
.todo-delete-btn-cancel:hover { background: var(--gray-100); }
.todo-delete-btn-confirm {
  border-color: var(--color-danger, #e53e3e);
  color: var(--color-danger, #e53e3e);
}
.todo-delete-btn-confirm:hover {
  background: var(--color-danger, #e53e3e);
  color: #fff;
}
.todo-delete-hints {
  margin-top: 0.75rem;
  text-align: center;
  font-size: 0.7rem;
  color: var(--gray-400);
}
.todo-delete-hints kbd {
  display: inline-block;
  padding: 1px 5px;
  border: 1px solid var(--gray-300);
  border-radius: 4px;
  background: var(--gray-100);
  font-size: 0.65rem;
  font-family: inherit;
  color: var(--gray-500);
}
@media screen and (max-width: 500px) {
  .todo-delete-dialog {
    width: 96%;
    padding: 1rem;
  }
}


</style>

<script>
(function() {
  'use strict';

  var container = document.getElementById('todo-list');
  var body = document.getElementById('todo-list-body');
  var itemsEl = document.getElementById('todo-items');
  var summaryEl = document.getElementById('todo-summary');

  var addTitleInput = document.getElementById('todo-add-title');
  var addBtn = document.getElementById('todo-add-btn');
  var addMainRow = document.querySelector('.todo-add-row-main');
  var addIconRow = document.getElementById('todo-add-row-icons');
  var addPomodoroBtn = document.getElementById('todo-add-pomodoro-btn');
  var addPomodoroCountEl = document.getElementById('todo-add-pomodoro-count');
  var addPomoMinusBtn = document.getElementById('todo-add-pomo-minus');
  var addPomoPlusBtn = document.getElementById('todo-add-pomo-plus');
  var addCustomMinInput = document.getElementById('todo-add-custom-min');
  var addDateIcon = document.getElementById('todo-add-date-icon');
  var addDateChip = document.getElementById('todo-add-date-chip');
  var addDateChipText = document.getElementById('todo-add-date-chip-text');
  var addDateChipClear = document.getElementById('todo-add-date-chip-clear');
  var addReminderIcon = document.getElementById('todo-add-reminder-icon');
  var addReminderChip = document.getElementById('todo-add-reminder-chip');
  var addReminderChipText = document.getElementById('todo-add-reminder-chip-text');
  var addReminderChipClear = document.getElementById('todo-add-reminder-chip-clear');
  var addCategoryIconWrap = document.getElementById('todo-add-category-icon-wrap');
  var addCategoryIcon = document.getElementById('todo-add-category-icon');
  var addCategoryPopover = document.getElementById('todo-add-category-popover');
  var addCategoryInput = document.getElementById('todo-add-category-input');
  var addCategoryChip = document.getElementById('todo-add-category-chip');
  var addCategoryChipText = document.getElementById('todo-add-category-chip-text');
  var addCategoryChipClear = document.getElementById('todo-add-category-chip-clear');
  var addCategoryDropdown = document.getElementById('todo-add-category-dropdown');
  var addMicBtn = document.getElementById('todo-add-mic-btn');

  if (!container || !itemsEl) return;

  // State
  var allTodos = [];
  var _pomodoroTrackedMinutes = {}; // { todoId: minutes } — stores tracked time from Pomodoro timer
  // Restore tracked minutes from localStorage (persisted across page navigations)
  try {
    var _savedTracked = localStorage.getItem('dm-pomodoro-tracked');
    if (_savedTracked) _pomodoroTrackedMinutes = JSON.parse(_savedTracked);
  } catch(e) {}
  var _justCompletedIds = {}; // { todoId: true } — for slide-down animation on just-completed tasks
  var _justAddedIds = {}; // { todoId: true } — for highlight flash animation on just-added tasks
  var _addFormCategory = null; // Selected category string for new task
  var _addFormCategoryPrompted = false; // True when Enter opened category popover (submit on select/skip)
  var _addFormBujoType = 'task'; // Selected BuJo type for new item (task/event/note)
  var _existingCategories = []; // Cached list of existing categories for autocomplete
  var _catDropdownActiveIdx = -1; // Active index in category dropdown
  var _defaultPomodoroCount = 1;
  try { var _dpc = parseInt(localStorage.getItem('dm-default-pomo-count'), 10); if (_dpc >= 0) _defaultPomodoroCount = _dpc; } catch(e) {}
  var _addFormPomodoroCount = _defaultPomodoroCount; // Number of pomodoro sessions for new task
  var _pomodoroConfigPopover = null; // Currently open pomodoro config popover

  // Global pomodoro mode settings — short & long work/break durations (minutes)
  var _globalPomoShortWork = 25;
  try { var stored = parseInt(localStorage.getItem('dm-pomo-short-work'), 10); if (stored > 0) _globalPomoShortWork = stored; } catch(e) {}
  var _globalPomoShortBreak = 5;
  try { var stored = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (stored > 0) _globalPomoShortBreak = stored; } catch(e) {}
  var _globalPomoLongWork = 50;
  try { var stored = parseInt(localStorage.getItem('dm-pomo-long-work'), 10); if (stored > 0) _globalPomoLongWork = stored; } catch(e) {}
  var _globalPomoLongBreak = 10;
  try { var stored = parseInt(localStorage.getItem('dm-pomo-long-break'), 10); if (stored > 0) _globalPomoLongBreak = stored; } catch(e) {}
  // Migrate old single-key format
  try {
    var _oldLen = parseInt(localStorage.getItem('dm-pomodoro-length'), 10);
    if (_oldLen > 0) { _globalPomoShortWork = _oldLen; localStorage.removeItem('dm-pomodoro-length'); }
  } catch(e) {}
  // Current add-form pomodoro mode ("short"|"long")
  var _addFormPomoMode = 'short';

  // Listen for settings changes from sidebar settings panel
  window.addEventListener('dm-settings-changed', function(e) {
    var detail = e.detail || {};
    if (detail.key === 'dm-pomo-short-work' && detail.value > 0) _globalPomoShortWork = detail.value;
    if (detail.key === 'dm-pomo-short-break' && detail.value > 0) _globalPomoShortBreak = detail.value;
    if (detail.key === 'dm-pomo-long-work' && detail.value > 0) _globalPomoLongWork = detail.value;
    if (detail.key === 'dm-pomo-long-break' && detail.value > 0) _globalPomoLongBreak = detail.value;
    if (detail.key === 'dm-default-pomo-count' && detail.value >= 0) {
      _defaultPomodoroCount = detail.value;
    }
    if (detail.key === 'dm-auto-schedule-today') {
      if (detail.value) {
        if (!_addFormDate) { _addFormDate = getTodayStr(); updateDateChip(); }
      } else {
        _addFormDate = null;
        updateDateChip();
      }
    }
  });

  // Clear just-completed animation flags after animation duration
  function clearJustCompletedIds() {
    setTimeout(function() { _justCompletedIds = {}; }, 400);
  }

  // ─── Delete confirmation modal (appended to document.body to avoid CSS containing-block issues) ───
  var _deleteModal = null;
  var _deleteModalHeading = null;
  var _deleteModalMessage = null;
  var _deleteModalConfirmBtn = null;
  var _deleteOnConfirm = null;

  function ensureDeleteModal() {
    if (_deleteModal) return;
    _deleteModal = document.createElement('div');
    _deleteModal.className = 'todo-delete-modal';
    _deleteModal.setAttribute('role', 'dialog');
    _deleteModal.setAttribute('aria-modal', 'true');
    _deleteModal.style.display = 'none';
    _deleteModal.innerHTML =
      '<div class="todo-delete-backdrop"></div>'
      + '<div class="todo-delete-dialog">'
      + '<div class="todo-delete-header">'
      + '<h3 class="todo-delete-heading">Delete Task</h3>'
      + '<button type="button" class="todo-delete-close">&times;</button>'
      + '</div>'
      + '<p class="todo-delete-message"></p>'
      + '<div class="todo-delete-actions">'
      + '<button type="button" class="todo-delete-btn-cancel">Cancel</button>'
      + '<button type="button" class="todo-delete-btn-confirm">Delete</button>'
      + '</div>'
      + '<div class="todo-delete-hints">'
      + '<kbd>Esc</kbd> cancel &middot; <kbd>Enter</kbd> delete'
      + '</div>'
      + '</div>';
    document.body.appendChild(_deleteModal);

    _deleteModalHeading = _deleteModal.querySelector('.todo-delete-heading');
    _deleteModalMessage = _deleteModal.querySelector('.todo-delete-message');
    _deleteModalConfirmBtn = _deleteModal.querySelector('.todo-delete-btn-confirm');
    var cancelBtn = _deleteModal.querySelector('.todo-delete-btn-cancel');
    var closeBtn = _deleteModal.querySelector('.todo-delete-close');
    var backdrop = _deleteModal.querySelector('.todo-delete-backdrop');

    _deleteModalConfirmBtn.addEventListener('click', function() {
      if (_deleteOnConfirm) _deleteOnConfirm();
      closeDeleteModal();
    });
    cancelBtn.addEventListener('click', closeDeleteModal);
    closeBtn.addEventListener('click', closeDeleteModal);
    backdrop.addEventListener('click', closeDeleteModal);
    _deleteModal.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeDeleteModal();
      }
      if (e.key === 'Enter') {
        e.preventDefault();
        _deleteModalConfirmBtn.click();
      }
    });
  }

  function showDeleteConfirm(message, onConfirm, title) {
    ensureDeleteModal();
    _deleteModalHeading.textContent = title || 'Delete Task';
    _deleteModalMessage.textContent = message;
    _deleteOnConfirm = onConfirm;
    _deleteModal.style.display = '';
    setTimeout(function() { _deleteModalConfirmBtn.focus({ preventScroll: true }); }, 50);
  }

  function closeDeleteModal() {
    if (_deleteModal) _deleteModal.style.display = 'none';
    _deleteOnConfirm = null;
  }

  // ─── Speech-to-text (mic dictation) ───
  var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  var _speechRecognition = null;
  var _speechIsRecording = false;

  function initSpeech() {
    if (!SpeechRecognition || !addMicBtn) return;
    // Show the mic button only when browser supports speech
    addMicBtn.style.display = '';

    _speechRecognition = new SpeechRecognition();
    _speechRecognition.continuous = false;
    _speechRecognition.interimResults = true;
    _speechRecognition.lang = navigator.language || 'en-US';
    _speechRecognition.maxAlternatives = 1;

    _speechRecognition.onresult = function(event) {
      var transcript = '';
      for (var i = 0; i < event.results.length; i++) {
        transcript += event.results[i][0].transcript;
      }
      if (addTitleInput) {
        addTitleInput.value = transcript;
      }
    };

    _speechRecognition.onend = function() {
      _speechIsRecording = false;
      addMicBtn.classList.remove('recording');
      // Parse natural language date/time from the transcript
      if (addTitleInput && addTitleInput.value.trim()) {
        var parsed = parseSpeechDateTime(addTitleInput.value.trim());
        if (parsed.date || parsed.reminderMs) {
          addTitleInput.value = parsed.cleanTitle;
          if (parsed.date) {
            _addFormDate = parsed.date;
            updateDateChip();
          }
          if (parsed.reminderMs) {
            _addFormReminderMs = parsed.reminderMs;
            updateReminderChip();
          }
        }
        addTitleInput.focus();
      }
    };

    _speechRecognition.onerror = function(event) {
      _speechIsRecording = false;
      addMicBtn.classList.remove('recording');
      if (event.error === 'not-allowed') {
        showTodoError('Microphone access denied');
      } else if (event.error !== 'aborted' && event.error !== 'no-speech') {
        showTodoError('Speech error: ' + event.error);
      }
    };

    addMicBtn.addEventListener('click', function() {
      if (_speechIsRecording) {
        _speechRecognition.stop();
        return;
      }
      // Clear input before starting
      if (addTitleInput) addTitleInput.value = '';
      _speechIsRecording = true;
      addMicBtn.classList.add('recording');
      try {
        _speechRecognition.start();
      } catch(e) {
        // Already started — ignore
        _speechIsRecording = false;
        addMicBtn.classList.remove('recording');
      }
    });
  }

  initSpeech();

  // ─── Date helpers ───
  function getTodayStr() {
    var d = new Date();
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
  }

  function getDateOffset(offset) {
    var d = new Date();
    d.setDate(d.getDate() + offset);
    return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
  }

  function getReminderMs(type) {
    var now = new Date();
    if (type === '30') {
      return now.getTime() + 30 * 60 * 1000;
    } else if (type === '60') {
      return now.getTime() + 60 * 60 * 1000;
    } else if (type === 'tomorrow9') {
      var tmrw = new Date(now);
      tmrw.setDate(tmrw.getDate() + 1);
      tmrw.setHours(9, 0, 0, 0);
      return tmrw.getTime();
    }
    return null;
  }

  function toDatetimeLocalStr(ms) {
    var d = new Date(ms);
    var pad = function(n) { return String(n).padStart(2, '0'); };
    return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate()) +
      'T' + pad(d.getHours()) + ':' + pad(d.getMinutes());
  }

  function formatReminderTime(ms) {
    var d = new Date(ms);
    var now = new Date();
    var pad = function(n) { return String(n).padStart(2, '0'); };
    var time = pad(d.getHours()) + ':' + pad(d.getMinutes());
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    var dayStr = months[d.getMonth()] + ' ' + d.getDate();
    if (d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate()) {
      return 'Today ' + time;
    }
    var tmrw = new Date(now); tmrw.setDate(tmrw.getDate() + 1);
    if (d.getFullYear() === tmrw.getFullYear() && d.getMonth() === tmrw.getMonth() && d.getDate() === tmrw.getDate()) {
      return 'Tmrw ' + time;
    }
    return dayStr + ' ' + time;
  }

  function formatDayHeader(dateStr) {
    var today = getTodayStr();
    var tomorrow = getDateOffset(1);
    var parts = dateStr.split('-');
    var date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var dayName = dayNames[date.getDay()];
    var monthDay = monthNames[date.getMonth()] + ' ' + date.getDate();

    if (dateStr === today) {
      return { label: 'Today — ' + dayName + ', ' + monthDay, cssClass: 'today', badge: 'Today' };
    }
    if (dateStr === tomorrow) {
      return { label: 'Tomorrow — ' + dayName + ', ' + monthDay, cssClass: 'tomorrow', badge: 'Tomorrow' };
    }
    if (dateStr < today) {
      return { label: dayName + ', ' + monthDay, cssClass: 'overdue', badge: 'Overdue' };
    }
    return { label: dayName + ', ' + monthDay, cssClass: '', badge: '' };
  }

  // ─── Natural language date/time parsing for speech input ───
  function parseSpeechDateTime(text) {
    // Returns { cleanTitle: string, date: 'YYYY-MM-DD'|null, reminderMs: number|null }
    // Delegates date/time parsing to the shared NLP in window.dmAI._parseDate,
    // and handles speech-specific logic: "remind me" prefix, "in X minutes/hours",
    // reminder timestamp computation, and title cleanup.
    var now = new Date();
    var date = null;   // YYYY-MM-DD string
    var time = null;   // { hours: N, minutes: N } in 24h format
    var cleaned = text;

    // Helper: format Date as YYYY-MM-DD
    function fmtDate(d) {
      return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
    }

    // Normalize: lowercase, collapse whitespace
    var lower = cleaned.toLowerCase().replace(/\s+/g, ' ').trim();

    // ── 1. Strip "remind me (to|for|about)" prefix ──
    lower = lower.replace(/^remind me\s+/, '');
    cleaned = cleaned.replace(/^remind me\s+/i, '');

    // ── 2. Relative durations: "in X minutes/hours" (speech-specific, not in AI parseDate) ──
    var relMatch = lower.match(/\bin\s+(\d+)\s+(minute|minutes|min|hour|hours|hr|hrs)\b/);
    if (relMatch) {
      var amount = parseInt(relMatch[1], 10);
      var unit = relMatch[2];
      var ms = amount * (/^(hour|hours|hr|hrs)$/.test(unit) ? 3600000 : 60000);
      var target = new Date(now.getTime() + ms);
      date = fmtDate(target);
      time = { hours: target.getHours(), minutes: target.getMinutes() };
      var relRe = new RegExp('\\bin\\s+' + relMatch[1] + '\\s+' + relMatch[2] + '\\b', 'i');
      cleaned = cleaned.replace(relRe, '');
    }

    // ── 3. Delegate date and time-of-day parsing to shared AI NLP ──
    if (!date && window.dmAI && window.dmAI._parseDate) {
      var parsed = window.dmAI._parseDate(cleaned);
      if (parsed) {
        date = parsed.date;
        // Strip the matched date phrase from the title
        if (parsed.matched) {
          cleaned = cleaned.replace(new RegExp(parsed.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'), '');
        }
        // Extract time info
        if (parsed.time) {
          time = { hours: parsed.time.hour, minutes: parsed.time.minute };
          // Strip the matched time phrase from the title
          if (parsed.time.matched && parsed.time.matched !== parsed.matched) {
            cleaned = cleaned.replace(new RegExp(parsed.time.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'), '');
          }
        }
      }
    } else if (!date) {
      // Fallback: minimal inline parsing if dmAI is not available yet
      if (/\btoday\b/.test(lower)) {
        date = fmtDate(now);
        cleaned = cleaned.replace(/\btoday\b/i, '');
      } else if (/\btonight\b/.test(lower)) {
        date = fmtDate(now);
        if (!time) time = { hours: 21, minutes: 0 };
        cleaned = cleaned.replace(/\btonight\b/i, '');
      } else if (/\btomorrow\b/.test(lower)) {
        var tmrw = new Date(now); tmrw.setDate(tmrw.getDate() + 1);
        date = fmtDate(tmrw);
        cleaned = cleaned.replace(/\btomorrow\b/i, '');
      }
    }

    // ── 4. Parse standalone time if not yet found (delegate to AI) ──
    if (!time && window.dmAI && window.dmAI._parseTimeOfDay) {
      var timeResult = window.dmAI._parseTimeOfDay(cleaned);
      if (timeResult) {
        time = { hours: timeResult.hour, minutes: timeResult.minute };
        if (timeResult.matched) {
          cleaned = cleaned.replace(new RegExp(timeResult.matched.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'), '');
        }
        if (!date) date = fmtDate(now); // time-only → assume today
      }
    }

    // ── 5. Strip connectors: leading "to", "for", "about", "that" ──
    cleaned = cleaned.replace(/\s+/g, ' ').trim();
    cleaned = cleaned.replace(/^(to|for|about|that)\s+/i, '');
    // Also strip trailing connectors
    cleaned = cleaned.replace(/\s+(to|for|about|that)$/i, '');
    cleaned = cleaned.replace(/\s+/g, ' ').trim();

    // If nothing was parsed, return unchanged
    if (!date && !time) {
      return { cleanTitle: text, date: null, reminderMs: null };
    }

    // ── 6. Build the reminder timestamp ──
    var reminderDate;
    if (date) {
      var parts = date.split('-');
      reminderDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    } else {
      reminderDate = new Date(now);
    }

    if (time) {
      reminderDate.setHours(time.hours, time.minutes, 0, 0);
    } else {
      // Date-only: default reminder to 9 AM
      reminderDate.setHours(9, 0, 0, 0);
    }

    // If the computed time is in the past (e.g. "today" with 9 AM already passed), bump to tomorrow
    if (reminderDate.getTime() <= now.getTime() && !time) {
      reminderDate.setDate(reminderDate.getDate() + 1);
    }

    // Final date string (may have been adjusted)
    var finalDate = fmtDate(reminderDate);

    // Capitalize first letter of cleaned title
    if (cleaned.length > 0) {
      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
    }

    return {
      cleanTitle: cleaned,
      date: finalDate,
      reminderMs: reminderDate.getTime()
    };
  }

  // ─── Add-form state (internal, not DOM inputs) ───
  var _autoScheduleToday = true;
  try { var _ast = localStorage.getItem('dm-auto-schedule-today'); if (_ast === 'false') _autoScheduleToday = false; } catch(e) {}
  var _addFormDate = _autoScheduleToday ? getTodayStr() : null;   // conditional default
  var _addFormReminderMs = null;
  var _addFormPopover = null;         // currently open popover element

  // ─── Chip display helpers ───
  function formatDateChip(dateStr) {
    var today = getTodayStr();
    var tomorrow = getDateOffset(1);
    if (dateStr === today) return 'Today';
    if (dateStr === tomorrow) return 'Tomorrow';
    var parts = dateStr.split('-');
    var d = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[d.getMonth()] + ' ' + d.getDate();
  }

  function updateDateChip() {
    if (_addFormDate) {
      addDateChipText.textContent = formatDateChip(_addFormDate);
      addDateChip.style.display = '';
      addDateIcon.classList.add('active');
    } else {
      addDateChip.style.display = 'none';
      addDateIcon.classList.remove('active');
    }
  }

  function formatReminderChip(ms) {
    return formatReminderTime(ms);
  }

  function updateReminderChip() {
    if (_addFormReminderMs) {
      addReminderChipText.textContent = formatReminderChip(_addFormReminderMs);
      addReminderChip.style.display = '';
      addReminderIcon.classList.add('active');
    } else {
      addReminderChip.style.display = 'none';
      addReminderIcon.classList.remove('active');
    }
  }

  // ─── Unified popover for add-form icons ───
  function closeAddFormPopover() {
    if (_addFormPopover) {
      _addFormPopover.remove();
      _addFormPopover = null;
    }
  }

  function showAddFormDatePopover() {
    closeAddFormPopover();
    closeReminderPopover(); // close any task-row popover too

    var pop = document.createElement('div');
    pop.className = 'todo-add-popover';

    var html = '<div class="todo-add-popover-title">Schedule</div>';
    html += '<button type="button" class="todo-add-popover-shortcut" data-date-offset="0">Today</button>';
    html += '<button type="button" class="todo-add-popover-shortcut" data-date-offset="1">Tomorrow</button>';
    html += '<div class="todo-add-popover-custom">';
    html += '<input type="date" class="todo-add-popover-input" value="' + (_addFormDate || '') + '">';
    html += '<button type="button" class="todo-add-popover-set" title="Set date">';
    html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    html += '</button>';
    html += '</div>';

    pop.innerHTML = html;
    addIconRow.appendChild(pop);
    _addFormPopover = pop;

    // Shortcut buttons
    pop.querySelectorAll('[data-date-offset]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var offset = parseInt(btn.getAttribute('data-date-offset'), 10);
        _addFormDate = getDateOffset(offset);
        updateDateChip();
        closeAddFormPopover();
      });
    });

    // Custom date set
    var customInput = pop.querySelector('.todo-add-popover-input');
    var setBtn = pop.querySelector('.todo-add-popover-set');
    setBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (!customInput.value) return;
      _addFormDate = customInput.value;
      updateDateChip();
      closeAddFormPopover();
    });
    customInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); setBtn.click(); }
    });

    setupPopoverDismiss(pop);
  }

  function showAddFormReminderPopover() {
    closeAddFormPopover();
    closeReminderPopover();

    var pop = document.createElement('div');
    pop.className = 'todo-add-popover';

    var html = '<div class="todo-add-popover-title">Remind me</div>';
    html += '<button type="button" class="todo-add-popover-shortcut" data-rtype="30">In 30 minutes</button>';
    html += '<button type="button" class="todo-add-popover-shortcut" data-rtype="60">In 1 hour</button>';
    html += '<button type="button" class="todo-add-popover-shortcut" data-rtype="tomorrow9">Tomorrow 9 AM</button>';
    html += '<div class="todo-add-popover-custom">';
    html += '<input type="datetime-local" class="todo-add-popover-input" value="' + (_addFormReminderMs ? toDatetimeLocalStr(_addFormReminderMs) : '') + '">';
    html += '<button type="button" class="todo-add-popover-set" title="Set reminder">';
    html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    html += '</button>';
    html += '</div>';

    pop.innerHTML = html;
    addIconRow.appendChild(pop);
    _addFormPopover = pop;

    // Shortcut buttons
    pop.querySelectorAll('[data-rtype]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var type = btn.getAttribute('data-rtype');
        var ms = getReminderMs(type);
        if (ms) {
          _addFormReminderMs = ms;
          updateReminderChip();
          closeAddFormPopover();
        }
      });
    });

    // Custom datetime set
    var customInput = pop.querySelector('.todo-add-popover-input');
    var setBtn = pop.querySelector('.todo-add-popover-set');
    setBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (!customInput.value) return;
      var ms = new Date(customInput.value).getTime();
      if (isNaN(ms) || ms <= Date.now()) {
        customInput.style.borderColor = 'var(--color-danger)';
        return;
      }
      _addFormReminderMs = ms;
      updateReminderChip();
      closeAddFormPopover();
    });
    customInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); setBtn.click(); }
    });

    setupPopoverDismiss(pop);
  }

  function setupPopoverDismiss(pop) {
    function onDocClick(e) {
      if (pop && !pop.contains(e.target) && e.target !== addDateIcon && e.target !== addReminderIcon) {
        closeAddFormPopover();
        document.removeEventListener('click', onDocClick, true);
      }
    }
    setTimeout(function() {
      document.addEventListener('click', onDocClick, true);
    }, 0);
    function onKey(e) {
      if (e.key === 'Escape') {
        closeAddFormPopover();
        document.removeEventListener('keydown', onKey);
      }
    }
    document.addEventListener('keydown', onKey);
  }

  // ─── Wire up add-form icon buttons and chip clears ───

  // BuJo type toggle in add form
  var bujoTypeToggle = document.getElementById('todo-add-bujo-type-toggle');
  var addPomoGroup = document.getElementById('todo-add-pomodoro-group');
  if (bujoTypeToggle) {
    bujoTypeToggle.querySelectorAll('.todo-add-bujo-type-btn').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var type = btn.getAttribute('data-bujo-type');
        _addFormBujoType = type;
        bujoTypeToggle.querySelectorAll('.todo-add-bujo-type-btn').forEach(function(b) { b.classList.remove('active'); });
        btn.classList.add('active');
        // Show/hide pomodoro controls (tasks only)
        if (addPomoGroup) {
          addPomoGroup.style.display = type === 'task' ? '' : 'none';
        }
        if (addCustomMinInput) {
          addCustomMinInput.style.display = type === 'task' ? '' : 'none';
        }
        // Update placeholder
        if (type === 'event') {
          addTitleInput.placeholder = 'What event is happening?';
        } else if (type === 'note') {
          addTitleInput.placeholder = 'Jot down a note...';
        } else {
          addTitleInput.placeholder = 'What needs to be done?';
        }
        addTitleInput.focus();
      });
    });
  }

  addDateIcon.addEventListener('click', function(e) {
    e.stopPropagation();
    if (_addFormPopover && _addFormPopover.parentNode === addIconRow && _addFormPopover.querySelector('[data-date-offset]')) {
      closeAddFormPopover();
    } else {
      showAddFormDatePopover();
    }
  });

  addReminderIcon.addEventListener('click', function(e) {
    e.stopPropagation();
    if (_addFormPopover && _addFormPopover.parentNode === addIconRow && _addFormPopover.querySelector('[data-rtype]')) {
      closeAddFormPopover();
    } else {
      showAddFormReminderPopover();
    }
  });

  addDateChipClear.addEventListener('click', function(e) {
    e.stopPropagation();
    _addFormDate = null;
    updateDateChip();
  });

  addReminderChipClear.addEventListener('click', function(e) {
    e.stopPropagation();
    _addFormReminderMs = null;
    updateReminderChip();
  });

  // ─── Category icon + popover for add-form ───
  function loadAddFormCategories() {
    _existingCategories = [];
    if (!window.dmSync) return Promise.resolve();
    return window.dmSync.getAllTodos().then(function(todos) {
      var catMap = {};
      todos.forEach(function(t) {
        if (t.category) {
          var ts = t.updatedAt || t.createdAt || 0;
          t.category.split(',').forEach(function(c) {
            var trimmed = c.trim().toLowerCase();
            if (trimmed) {
              if (!catMap[trimmed]) {
                catMap[trimmed] = { lastUsed: ts, count: 1 };
              } else {
                catMap[trimmed].count++;
                if (ts > catMap[trimmed].lastUsed) catMap[trimmed].lastUsed = ts;
              }
            }
          });
        }
      });
      _existingCategories = Object.keys(catMap).sort(function(a, b) {
        return catMap[b].lastUsed - catMap[a].lastUsed;
      });
    });
  }

  function getCatFilteredSuggestions(query) {
    var q = query.trim().toLowerCase();
    if (!q) return _existingCategories.slice();
    return _existingCategories.filter(function(c) {
      return c.indexOf(q) !== -1;
    });
  }

  function catHighlightMatch(text, query) {
    var q = query.trim().toLowerCase();
    if (!q) return escapeHtml(text);
    var idx = text.toLowerCase().indexOf(q);
    if (idx === -1) return escapeHtml(text);
    return escapeHtml(text.substring(0, idx)) +
      '<span class="cat-highlight">' + escapeHtml(text.substring(idx, idx + q.length)) + '</span>' +
      escapeHtml(text.substring(idx + q.length));
  }

  function updateCategoryChip() {
    if (_addFormCategory) {
      addCategoryChipText.textContent = _addFormCategory;
      addCategoryChip.style.display = '';
      addCategoryIcon.classList.add('active');
    } else {
      addCategoryChip.style.display = 'none';
      addCategoryIcon.classList.remove('active');
    }
  }

  function hideCatDropdown() {
    addCategoryDropdown.classList.remove('show');
    addCategoryDropdown.innerHTML = '';
    _catDropdownActiveIdx = -1;
  }

  function showCatDropdown() {
    loadAddFormCategories().then(function() {
      var query = addCategoryInput.value.trim().toLowerCase();
      var suggestions = getCatFilteredSuggestions(query);
      _catDropdownActiveIdx = -1;
      if (suggestions.length === 0) {
        hideCatDropdown();
        return;
      }
      addCategoryDropdown.innerHTML = '';
      suggestions.forEach(function(cat) {
        var chip = document.createElement('span');
        chip.className = 'todo-add-category-chip';
        chip.innerHTML = catHighlightMatch(cat, query);
        chip.setAttribute('data-cat', cat);
        chip.addEventListener('mousedown', function(e) {
          e.preventDefault();
          selectCat(cat);
        });
        addCategoryDropdown.appendChild(chip);
      });
      addCategoryDropdown.classList.add('show');
    });
  }

  function selectCat(cat) {
    _addFormCategory = cat;
    updateCategoryChip();
    var shouldSubmit = _addFormCategoryPrompted;
    _addFormCategoryPrompted = false;
    hideCatPopover();
    if (shouldSubmit) {
      addFromForm();
    }
  }

  function navigateCatDropdown(direction) {
    var chips = addCategoryDropdown.querySelectorAll('.todo-add-category-chip');
    if (chips.length === 0) return;
    if (_catDropdownActiveIdx >= 0 && _catDropdownActiveIdx < chips.length) {
      chips[_catDropdownActiveIdx].classList.remove('active');
    }
    _catDropdownActiveIdx += direction;
    if (_catDropdownActiveIdx < 0) _catDropdownActiveIdx = chips.length - 1;
    if (_catDropdownActiveIdx >= chips.length) _catDropdownActiveIdx = 0;
    chips[_catDropdownActiveIdx].classList.add('active');
    chips[_catDropdownActiveIdx].scrollIntoView({ block: 'nearest' });
  }

  function showCatPopover() {
    addCategoryPopover.style.display = '';
    addCategoryInput.value = '';
    showCatDropdown();
    setTimeout(function() { addCategoryInput.focus(); }, 30);
  }

  function hideCatPopover() {
    addCategoryPopover.style.display = 'none';
    hideCatDropdown();
    addCategoryInput.value = '';
    _addFormCategoryPrompted = false;
  }

  addCategoryIcon.addEventListener('click', function(e) {
    e.stopPropagation();
    if (addCategoryPopover.style.display !== 'none') {
      hideCatPopover();
    } else {
      showCatPopover();
    }
  });

  addCategoryInput.addEventListener('input', function() {
    showCatDropdown();
  });

  addCategoryInput.addEventListener('blur', function() {
    setTimeout(function() {
      // Commit whatever is typed on blur
      var val = addCategoryInput.value.trim().toLowerCase();
      if (val) {
        _addFormCategory = val;
        updateCategoryChip();
      }
      hideCatPopover();
    }, 150);
  });

  addCategoryInput.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (!addCategoryDropdown.classList.contains('show')) showCatDropdown();
      else navigateCatDropdown(1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      navigateCatDropdown(-1);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      var chips = addCategoryDropdown.querySelectorAll('.todo-add-category-chip');
      if (_catDropdownActiveIdx >= 0 && _catDropdownActiveIdx < chips.length) {
        selectCat(chips[_catDropdownActiveIdx].getAttribute('data-cat'));
      } else if (addCategoryInput.value.trim()) {
        selectCat(addCategoryInput.value.trim().toLowerCase());
      } else {
        // Empty Enter = skip category
        var shouldSubmit = _addFormCategoryPrompted;
        _addFormCategoryPrompted = false;
        hideCatPopover();
        if (shouldSubmit) {
          addFromForm();
        }
      }
    } else if (e.key === 'Escape') {
      e.preventDefault();
      hideCatPopover();
    }
  });

  // Click the × on the category chip to clear
  addCategoryChipClear.addEventListener('click', function(e) {
    e.stopPropagation();
    _addFormCategory = null;
    updateCategoryChip();
  });

  // Click the chip text to re-open popover for editing
  addCategoryChip.addEventListener('click', function(e) {
    if (e.target === addCategoryChipClear || e.target.closest('.todo-add-chip-clear')) return;
    showCatPopover();
    addCategoryInput.value = _addFormCategory || '';
    setTimeout(function() { addCategoryInput.select(); }, 50);
  });

  // Close popover on outside click
  document.addEventListener('click', function(e) {
    if (addCategoryPopover.style.display !== 'none' &&
        !addCategoryIconWrap.contains(e.target) &&
        !addCategoryChip.contains(e.target)) {
      hideCatPopover();
    }
  });

  // ─── Pomodoro count button handlers ───
  function updatePomodoroCountDisplay() {
    addPomodoroCountEl.textContent = _addFormPomodoroCount;
    if (_addFormPomodoroCount > 0) {
      addPomodoroBtn.classList.add('has-count');
      addPomoMinusBtn.disabled = false;
    } else {
      addPomodoroBtn.classList.remove('has-count');
      addPomoMinusBtn.disabled = true;
    }
    // Swap tomato icon based on mode
    var isLong = _addFormPomoMode === 'long';
    var shortIcon = addPomodoroBtn.querySelector('.todo-pomo-icon-short');
    var longIcon = addPomodoroBtn.querySelector('.todo-pomo-icon-long');
    if (shortIcon) shortIcon.style.display = isLong ? 'none' : '';
    if (longIcon) longIcon.style.display = isLong ? '' : 'none';
    var workMin = isLong ? _globalPomoLongWork : _globalPomoShortWork;
    var breakMin = isLong ? _globalPomoLongBreak : _globalPomoShortBreak;
    addPomodoroBtn.title = (isLong ? 'Long' : 'Short') + ' session (' + workMin + '/' + breakMin + 'min) \u2014 click tomato to switch';
  }

  // Plus button: increment pomodoro count
  addPomoPlusBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    e.preventDefault();
    _addFormPomodoroCount++;
    updatePomodoroCountDisplay();
  });

  // Minus button: decrement pomodoro count (min 0)
  addPomoMinusBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    e.preventDefault();
    if (_addFormPomodoroCount > 0) {
      _addFormPomodoroCount--;
      updatePomodoroCountDisplay();
    }
  });

  // Click on pomodoro button: toggle between short/long mode
  addPomodoroBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    _addFormPomoMode = _addFormPomoMode === 'long' ? 'short' : 'long';
    updatePomodoroCountDisplay();
  });

  function closePomodoroConfigPopover() {
    if (_pomodoroConfigPopover && _pomodoroConfigPopover.parentNode) {
      _pomodoroConfigPopover.remove();
    }
    _pomodoroConfigPopover = null;
  }

  // Initialize pomodoro count display
  updatePomodoroCountDisplay();

  // Initialize chips — default to Today
  updateDateChip();
  updateReminderChip();
  updateCategoryChip();

  // ─── Toast notifications ───
  function showTodoError(msg) {
    var toast = document.createElement('div');
    toast.className = 'todo-toast todo-toast-error';
    toast.textContent = msg;
    document.body.appendChild(toast);
    setTimeout(function() { toast.classList.add('show'); }, 10);
    setTimeout(function() {
      toast.classList.remove('show');
      setTimeout(function() { toast.remove(); }, 300);
    }, 4000);
  }

  // ─── Render ───
  function buildTodoItemHtml(todo, isSubtask, hasChildren, finishAtLabel, isOverdue) {
    var doneClass = todo.done ? ' done' : '';
    var justCompletedClass = _justCompletedIds[todo.id] ? ' just-completed' : '';
    var justAddedClass = _justAddedIds[todo.id] ? ' just-added' : '';
    var bujoState = todo.bujoState || 'open';
    var bujoType = todo.bujoType || 'task';
    var stateClass = bujoState === 'migrated' ? ' migrated' : (bujoState === 'scheduled' ? ' scheduled' : '');
    var html = '<div class="todo-item' + doneClass + justCompletedClass + justAddedClass + stateClass + '" data-todo-id="' + todo.id + '">';

    // Drag handle (only on active tasks — not done, migrated, or scheduled)
    if (!todo.done && bujoState !== 'migrated' && bujoState !== 'scheduled') {
      html += '<span class="todo-drag-handle" title="Drag to reorder"><svg width="10" height="14" viewBox="0 0 10 14" fill="currentColor"><circle cx="3" cy="2" r="1.2"/><circle cx="7" cy="2" r="1.2"/><circle cx="3" cy="7" r="1.2"/><circle cx="7" cy="7" r="1.2"/><circle cx="3" cy="12" r="1.2"/><circle cx="7" cy="12" r="1.2"/></svg></span>';
    } else {
      html += '<span class="todo-drag-handle-spacer"></span>';
    }

    // Subtask collapse toggle for parents with children
    if (!isSubtask && hasChildren) {
      var isCollapsed = false;
      try { isCollapsed = localStorage.getItem('dm-todo-subtask-collapsed-' + todo.id) === '1'; } catch(e) {}
      html += '<button type="button" class="todo-subtask-toggle' + (isCollapsed ? ' collapsed' : '') + '" data-toggle-parent="' + todo.id + '" title="Toggle subtasks" aria-label="Toggle subtasks">';
      html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
      html += '</button>';
    } else if (!isSubtask) {
      // Spacer to align with items that have a collapse toggle
      html += '<div class="todo-subtask-spacer"></div>';
    }

    // BuJo bullet icon
    var bulletClass = 'todo-bujo-bullet';
    var bulletSvg = '';
    var bulletTitle = '';
    if (bujoType === 'event') {
      if (bujoState === 'done') {
        bulletClass += ' bujo-event-done';
        // Circle with checkmark inside — retains event identity when done
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8" r="5.5" stroke-width="1.5"/><polyline points="4.5,8 7,10.5 11.5,5.5" stroke-width="2"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="8" cy="8" r="5.5"/></svg>';
        bulletTitle = 'Done (click to reopen)';
      } else {
        bulletClass += ' bujo-event';
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><circle cx="8" cy="8" r="5.5"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>';
        bulletTitle = 'Event (click to complete)';
      }
    } else if (bujoType === 'note') {
      if (bujoState === 'done') {
        bulletClass += ' bujo-note-done';
        // Dash with checkmark overlay — retains note identity when done
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="2" y1="10" x2="9" y2="10" stroke-width="2.2"/><polyline points="8,8 10,10.5 14,5" stroke-width="2"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="8" x2="13" y2="8"/></svg>';
        bulletTitle = 'Done (click to reopen)';
      } else {
        bulletClass += ' bujo-note';
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="8" x2="13" y2="8"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>';
        bulletTitle = 'Note (click to complete)';
      }
    } else {
      // Task — varies by bujoState
      if (bujoState === 'done') {
        bulletClass += ' bujo-task-done';
        // Two SVGs: checkmark shown at rest, dot shown on hover (hints "click to reopen")
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16"><circle cx="8" cy="8" r="4" fill="currentColor"/></svg>';
        bulletTitle = 'Done (click to reopen)';
      } else if (bujoState === 'migrated') {
        bulletClass += ' bujo-task-migrated';
        bulletSvg = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,3 13,8 6,13"/></svg>';
        bulletTitle = 'Migrated';
      } else if (bujoState === 'scheduled') {
        bulletClass += ' bujo-task-scheduled';
        bulletSvg = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="10,3 3,8 10,13"/></svg>';
        bulletTitle = 'Scheduled';
      } else {
        bulletClass += ' bujo-task-open';
        // Two SVGs: dot shown at rest, checkmark shown on hover (CSS handles swap)
        bulletSvg = '<svg class="bujo-icon-rest" width="14" height="14" viewBox="0 0 16 16"><circle cx="8" cy="8" r="4" fill="currentColor"/></svg>'
          + '<svg class="bujo-icon-hover" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>';
        bulletTitle = 'Click to complete';
      }
    }
    html += '<button type="button" class="' + bulletClass + '" data-bullet-id="' + todo.id + '" title="' + bulletTitle + '" aria-label="' + bulletTitle + '">' + bulletSvg + '</button>';
    html += '<div class="todo-item-content">';
    html += '<div class="todo-item-title">';
    if (todo.source === 'ai') {
      html += '<span class="todo-item-ai-badge" title="Created by AI"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275L21 12l-5.813 1.912a2 2 0 0 0-1.275 1.275L12 21l-1.912-5.813a2 2 0 0 0-1.275-1.275L3 12l5.813-1.912a2 2 0 0 0 1.275-1.275L12 3z"></path></svg></span>';
    }
    html += escapeHtml(todo.title) + '</div>';
    html += '<div class="todo-item-meta">';

    if (todo.estimatedMin) {
      var pCount = todo.pomodoroCount || 1;
      var pLen = todo.pomodoroLength || _globalPomoShortWork;
      if (pCount > 1) {
        html += '<span class="todo-item-estimate">' + pCount + '× ' + pLen + 'min</span>';
      } else {
        html += '<span class="todo-item-estimate">est: ' + todo.estimatedMin + 'min</span>';
      }
    }
    if (todo.done && todo.actualMin != null) {
      var actualClass = '';
      if (todo.estimatedMin) {
        actualClass = todo.actualMin > todo.estimatedMin ? ' over' : ' under';
      }
      html += '<span class="todo-item-actual' + actualClass + '">actual: ' + todo.actualMin + 'min</span>';
    }
    // Active pomodoro indicator
    if (!todo.done && window.dmPomodoro && window.dmPomodoro.isActive(todo.id)) {
      var timerRunning = window.dmPomodoro.isTimerRunning();
      var sessionInfo = window.dmPomodoro.getSessionInfo ? window.dmPomodoro.getSessionInfo() : null;
      var timerLabel = timerRunning ? 'timing' : 'paused';
      if (sessionInfo && sessionInfo.total > 1) {
        timerLabel = (timerRunning ? '' : 'paused ') + sessionInfo.current + '/' + sessionInfo.total;
      }
      html += '<span class="todo-item-timer-active' + (timerRunning ? '' : ' paused') + '"><svg width="10" height="10" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10"/></svg> ' + timerLabel + '</span>';
    }

    // Inline pomodoro start/pause/stop buttons (only for undone tasks, not events/notes)
    if (!todo.done && bujoType === 'task') {
      var isTimerActive = window.dmPomodoro && window.dmPomodoro.isActive(todo.id);
      var isTimerRunning = isTimerActive && window.dmPomodoro.isTimerRunning();
      if (isTimerActive) {
        // Pause/Resume button
        var pomoBtnTitle = isTimerRunning ? 'Pause timer' : 'Resume timer';
        html += '<button type="button" class="todo-item-pomo-inline pomodoro-start active" data-pomodoro-id="' + todo.id + '" title="' + pomoBtnTitle + '" aria-label="' + pomoBtnTitle + '">';
        if (isTimerRunning) {
          html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="5" y="3" width="5" height="18" rx="1"></rect><rect x="14" y="3" width="5" height="18" rx="1"></rect></svg>';
        } else {
          html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="6 3 20 12 6 21 6 3"></polygon></svg>';
        }
        html += '</button>';
        // Stop button
        html += '<button type="button" class="todo-item-pomo-inline pomo-stop" data-pomodoro-stop-id="' + todo.id + '" title="Stop &amp; record time" aria-label="Stop timer">';
        html += '<svg width="10" height="10" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>';
        html += '</button>';
      } else {
        // Start button (no active timer)
        html += '<button type="button" class="todo-item-pomo-inline pomodoro-start" data-pomodoro-id="' + todo.id + '" title="Start Pomodoro" aria-label="Start Pomodoro">';
        html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="6 3 20 12 6 21 6 3"></polygon></svg>';
        html += '</button>';
      }
    }
    if (todo.category) {
      html += '<span class="todo-item-category">' + escapeHtml(todo.category) + '</span>';
    }

    // Estimated finish time (computed per day group for undone tasks)
    if (finishAtLabel && !todo.done) {
      html += '<span class="todo-item-finish-at"><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>' + finishAtLabel + '</span>';
    }

    // Reminder info
    if (todo.reminderAt && !todo.reminderFired && !todo.done) {
      var reminderOverdue = todo.reminderAt < Date.now();
      html += '<span class="todo-item-reminder' + (reminderOverdue ? ' overdue' : '') + '">';
      html += '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>';
      html += formatReminderTime(todo.reminderAt);
      html += '</span>';
    }

    html += '</div></div>';

    // Action buttons
    html += '<div class="todo-item-actions">';
    if (!todo.done && bujoType === 'task') {
      var hasReminder = todo.reminderAt && !todo.reminderFired;
      html += '<button type="button" class="todo-item-action-btn reminder-bell' + (hasReminder ? ' has-reminder' : '') + '" data-reminder-id="' + todo.id + '" title="' + (hasReminder ? 'Edit reminder' : 'Set reminder') + '" aria-label="Set reminder">';
      if (hasReminder) {
        // Filled bell
        html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>';
      } else {
        // Outline bell
        html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>';
      }
      html += '</button>';
    }
    if (!isSubtask && !todo.done && bujoType === 'task') {
      html += '<button type="button" class="todo-item-action-btn add-subtask" data-parent-id="' + todo.id + '" title="Add subtask" aria-label="Add subtask">';
      html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
      html += '</button>';
    }
    // Archive button (only for done tasks)
    if (todo.done) {
      html += '<button type="button" class="todo-item-action-btn archive" data-archive-id="' + todo.id + '" title="Archive task" aria-label="Archive task">';
      html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 8v13H3V8"></path><path d="M1 3h22v5H1z"></path><path d="M10 12h4"></path></svg>';
      html += '</button>';
    }
    // Migrate to Today button (for open tasks in overdue groups)
    if (isOverdue && !todo.done && bujoState === 'open') {
      html += '<button type="button" class="todo-item-action-btn migrate-today" data-migrate-id="' + todo.id + '" title="Migrate to today" aria-label="Migrate to today">';
      html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,3 13,8 6,13"/></svg>';
      html += '</button>';
    }
    // Edit button (for all tasks, done or not)
    html += '<button type="button" class="todo-item-action-btn edit" data-edit-id="' + todo.id + '" title="Edit task" aria-label="Edit task">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>';
    html += '</button>';
    html += '<button type="button" class="todo-item-action-btn delete" data-delete-id="' + todo.id + '" title="Delete task" aria-label="Delete task">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
    html += '</button>';
    html += '</div>';
    html += '</div>';
    return html;
  }

  function render() {
    container.style.display = '';

    // Filter to only active and done tasks (exclude archived and deleted)
    var visibleTodos = allTodos.filter(function(t) {
      var s = t.status || 'active';
      return s === 'active' || s === 'done';
    });

    // Separate parents and children
    var parents = [];
    var childrenMap = {}; // parentId -> [children]
    visibleTodos.forEach(function(t) {
      if (t.parentId) {
        if (!childrenMap[t.parentId]) childrenMap[t.parentId] = [];
        childrenMap[t.parentId].push(t);
      } else {
        parents.push(t);
      }
    });

    // Sort children by order, done tasks at bottom
    Object.keys(childrenMap).forEach(function(pid) {
      childrenMap[pid].sort(function(a, b) {
        if (a.done !== b.done) return a.done ? 1 : -1;
        return (a.order || 0) - (b.order || 0);
      });
    });

    // Group parents by scheduledDate
    var dateGroups = {}; // dateStr -> [parents]
    var unscheduled = [];
    parents.forEach(function(p) {
      if (p.scheduledDate) {
        if (!dateGroups[p.scheduledDate]) dateGroups[p.scheduledDate] = [];
        dateGroups[p.scheduledDate].push(p);
      } else {
        unscheduled.push(p);
      }
    });

    // Sort dates
    var sortedDates = Object.keys(dateGroups).sort();

    // Sort parents within each group by order, done tasks at bottom
    sortedDates.forEach(function(dateStr) {
      dateGroups[dateStr].sort(function(a, b) {
        if (a.done !== b.done) return a.done ? 1 : -1;
        return (a.order || 0) - (b.order || 0);
      });
    });
    unscheduled.sort(function(a, b) {
      if (a.done !== b.done) return a.done ? 1 : -1;
      return (a.order || 0) - (b.order || 0);
    });

    var html = '';
    var totalParents = parents.length;

    if (totalParents === 0) {
      html = '<div class="todo-empty">No tasks yet. Add one above to get started.</div>';
    }

    var today = getTodayStr();
    var tomorrow = getDateOffset(1);

    // Helper: build a day group with header, chevron, progress, collapse
    function buildDayGroup(groupKey, headerInfo, tasksInGroup) {
      // Calculate progress (count leaf tasks — parent tasks with children are excluded)
      var doneInGroup = 0;
      var totalInGroup = 0;
      tasksInGroup.forEach(function(p) {
        var ch = childrenMap[p.id] || [];
        if (ch.length > 0) {
          ch.forEach(function(c) { totalInGroup++; if (c.done) doneInGroup++; });
        } else {
          totalInGroup++;
          if (p.done) doneInGroup++;
        }
      });

      // Fix 6: overdue styling only when group has at least one incomplete task
      var cssClass = headerInfo.cssClass;
      var badge = headerInfo.badge;
      if (cssClass === 'overdue' && doneInGroup === totalInGroup) {
        cssClass = ''; // all done, no overdue accent
        badge = '';
      }

      // Fix 3: auto-collapse logic
      var storageKey = 'dm-todo-daygroup-' + groupKey;
      var stored = null;
      try { stored = localStorage.getItem(storageKey); } catch(e) {}
      var isCollapsed;
      if (stored !== null) {
        isCollapsed = stored === '1';
      } else {
        // Default: collapse future dates and unscheduled; expand today, tomorrow, overdue
        if (groupKey === '_unscheduled') {
          isCollapsed = true;
        } else {
          isCollapsed = groupKey > tomorrow;
        }
      }

      var g = '<div class="todo-day-group' + (isCollapsed ? ' collapsed' : '') + '" data-day-group="' + escapeHtml(groupKey) + '">';
      g += '<div class="todo-day-header ' + cssClass + '" data-day-toggle="' + escapeHtml(groupKey) + '">';
      g += '<span class="todo-day-chevron"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>';
      if (badge) {
        g += '<span class="todo-day-badge">' + escapeHtml(badge) + '</span>';
      }
      g += '<span class="todo-day-label">' + escapeHtml(headerInfo.label) + '</span>';
      g += '<span class="todo-day-progress">' + doneInGroup + '/' + totalInGroup + '</span>';
      // Migrate to Today button for overdue groups with open tasks
      if (cssClass === 'overdue' && doneInGroup < totalInGroup) {
        g += '<button type="button" class="todo-day-migrate-btn" data-migrate-group="' + escapeHtml(groupKey) + '" title="Migrate open tasks to today">';
        g += '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,3 13,8 6,13"/></svg>';
        g += ' Migrate to Today';
        g += '</button>';
      }
      g += '</div>';
      g += '<div class="todo-day-group-items">';

      // Compute cumulative finish times for undone tasks in this group
      var finishAtMap = {}; // { todoId: "Finish at: HH:MM (X.Xh)" }
      var cumulativeMin = 0;
      var baseTime = (groupKey === today) ? Date.now() : null;

      // Collect undone leaf tasks in display order (parents then their children)
      tasksInGroup.forEach(function(parent) {
        var children = childrenMap[parent.id] || [];
        if (children.length > 0) {
          // Parent with children: count children only
          children.forEach(function(child) {
            if (!child.done && child.estimatedMin > 0) {
              var taskMin = child.estimatedMin;
              // If pomodoro timer is active on this task, subtract elapsed time
              if (window.dmPomodoro && window.dmPomodoro.isActive(child.id) && window.dmPomodoro.getSessionInfo) {
                var si = window.dmPomodoro.getSessionInfo();
                if (si && si.elapsedSec > 0) {
                  taskMin = Math.max(0, taskMin - Math.floor(si.elapsedSec / 60));
                }
              }
              cumulativeMin += taskMin;
              if (baseTime) {
                var finishMs = baseTime + cumulativeMin * 60000;
                var fd = new Date(finishMs);
                var hh = String(fd.getHours()).length < 2 ? '0' + fd.getHours() : '' + fd.getHours();
                var mm = String(fd.getMinutes()).length < 2 ? '0' + fd.getMinutes() : '' + fd.getMinutes();
                var hrs = (cumulativeMin / 60).toFixed(1);
                finishAtMap[child.id] = hh + ':' + mm + ' (' + hrs + 'h)';
              } else {
                var hrs = (cumulativeMin / 60).toFixed(1);
                finishAtMap[child.id] = '+' + hrs + 'h';
              }
            }
          });
        } else {
          // Leaf parent (no children)
          if (!parent.done && parent.estimatedMin > 0) {
            var taskMin = parent.estimatedMin;
            if (window.dmPomodoro && window.dmPomodoro.isActive(parent.id) && window.dmPomodoro.getSessionInfo) {
              var si = window.dmPomodoro.getSessionInfo();
              if (si && si.elapsedSec > 0) {
                taskMin = Math.max(0, taskMin - Math.floor(si.elapsedSec / 60));
              }
            }
            cumulativeMin += taskMin;
            if (baseTime) {
              var finishMs = baseTime + cumulativeMin * 60000;
              var fd = new Date(finishMs);
              var hh = String(fd.getHours()).length < 2 ? '0' + fd.getHours() : '' + fd.getHours();
              var mm = String(fd.getMinutes()).length < 2 ? '0' + fd.getMinutes() : '' + fd.getMinutes();
              var hrs = (cumulativeMin / 60).toFixed(1);
              finishAtMap[parent.id] = hh + ':' + mm + ' (' + hrs + 'h)';
            } else {
              var hrs = (cumulativeMin / 60).toFixed(1);
              finishAtMap[parent.id] = '+' + hrs + 'h';
            }
          }
        }
      });

      var _isOverdueGroup = (cssClass === 'overdue');

      tasksInGroup.forEach(function(parent) {
        var children = childrenMap[parent.id] || [];
        g += '<div class="todo-item-group" data-group-id="' + parent.id + '">';
        g += buildTodoItemHtml(parent, false, children.length > 0, finishAtMap[parent.id] || null, _isOverdueGroup);
        if (children.length > 0) {
          var subCollapsed = false;
          try { subCollapsed = localStorage.getItem('dm-todo-subtask-collapsed-' + parent.id) === '1'; } catch(e) {}
          g += '<div class="todo-subtasks-wrapper' + (subCollapsed ? ' collapsed' : '') + '" data-subtasks-parent="' + parent.id + '">';
          g += '<div class="todo-subtasks" data-parent-id="' + parent.id + '">';
          children.forEach(function(child) {
            g += buildTodoItemHtml(child, true, false, finishAtMap[child.id] || null, _isOverdueGroup);
          });
          g += '</div>';
          g += '</div>';
        }
        g += '</div>';
      });
      g += '</div>';
      g += '</div>';
      return g;
    }

    // Render date groups
    sortedDates.forEach(function(dateStr) {
      var info = formatDayHeader(dateStr);
      html += buildDayGroup(dateStr, info, dateGroups[dateStr]);
    });

    // Render unscheduled
    if (unscheduled.length > 0) {
      html += buildDayGroup('_unscheduled', { label: 'Unscheduled', cssClass: '', badge: '' }, unscheduled);
    }

    // Archive all completed bar (shown when there are completed/done tasks)
    var doneStatusCount = 0;
    visibleTodos.forEach(function(t) { if (t.status === 'done') doneStatusCount++; });
    if (doneStatusCount > 0) {
      html += '<div class="todo-clear-all-bar">';
      html += '<span class="todo-clear-all-count">' + doneStatusCount + ' completed</span>';
      html += '<button type="button" class="todo-clear-all-btn" id="todo-archive-all" title="Archive all completed tasks">';
      html += '<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 8v13H3V8"></path><path d="M1 3h22v5H1z"></path><path d="M10 12h4"></path></svg>';
      html += ' Archive all';
      html += '</button>';
      html += '</div>';
    }

    itemsEl.innerHTML = html;

    // Summary (counts visible tasks only — active + done, not archived/deleted)
    var totalEst = 0, totalActual = 0, doneCount = 0, totalCount = 0;
    visibleTodos.forEach(function(t) {
      // Only count leaf tasks (no children or subtasks themselves)
      var hasChildren = childrenMap[t.id] && childrenMap[t.id].length > 0;
      if (!hasChildren) {
        totalCount++;
        if (t.estimatedMin) totalEst += t.estimatedMin;
        if (t.done) {
          doneCount++;
          if (t.actualMin != null) totalActual += t.actualMin;
        }
      }
    });

    if (totalCount > 0) {
      var pomEst = (totalEst / _globalPomoShortWork).toFixed(1);
      var pomActual = (totalActual / _globalPomoShortWork).toFixed(1);
      summaryEl.innerHTML =
        '<span class="todo-summary-item"><strong>' + doneCount + '/' + totalCount + '</strong> tasks done</span>' +
        (totalEst ? '<span class="todo-summary-item">Est: <strong>' + totalEst + 'min</strong> (' + pomEst + ' pom)</span>' : '') +
        (totalActual ? '<span class="todo-summary-item">Actual: <strong>' + totalActual + 'min</strong> (' + pomActual + ' pom)</span>' : '');
      summaryEl.style.display = '';
    } else {
      summaryEl.style.display = 'none';
    }

    // Attach event listeners
    attachEventListeners();

    // Initialize drag-and-drop reordering
    initSortable();
  }

  function escapeHtml(text) {
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // ─── Migrate to Today ───
  function migrateToToday(todoId) {
    var todo = allTodos.find(function(t) { return t.id === todoId; });
    if (!todo) return;
    var today = getTodayStr();
    changeBujoState(todo, 'migrated', today);
    // Also migrate children (subtasks)
    allTodos.forEach(function(t) {
      if (t.parentId === todoId && !t.done) {
        changeBujoState(t, 'migrated', today);
      }
    });
  }

  function migrateGroupToToday(groupDateStr) {
    var today = getTodayStr();
    // Find all open (not done, not already migrated/scheduled) tasks in this date group
    var tasksToMigrate = allTodos.filter(function(t) {
      return t.scheduledDate === groupDateStr && !t.done && (t.bujoState || 'open') === 'open' && !t.parentId;
    });
    tasksToMigrate.forEach(function(parent) {
      changeBujoState(parent, 'migrated', today);
      // Migrate children too
      allTodos.forEach(function(t) {
        if (t.parentId === parent.id && !t.done) {
          changeBujoState(t, 'migrated', today);
        }
      });
    });
    // render() is called inside changeBujoState — but it fires for each task.
    // Call one final render to ensure clean state.
    render();
  }

  // ─── BuJo state picker ───
  var _activeStatePicker = null;
  var _activeMigratePrompt = null;

  function closeStatePicker() {
    if (_activeStatePicker) {
      _activeStatePicker.remove();
      _activeStatePicker = null;
    }
  }

  function closeMigratePrompt() {
    if (_activeMigratePrompt) {
      _activeMigratePrompt.remove();
      _activeMigratePrompt = null;
    }
  }

  function changeBujoState(todo, newState, newDate) {
    var firestoreUpdates = { bujoState: newState, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
    var localUpdates = { bujoState: newState, updatedAt: Date.now() };

    if (newState === 'done') {
      firestoreUpdates.done = true;
      firestoreUpdates.status = 'done';
      localUpdates.done = true;
      localUpdates.status = 'done';
    } else if (newState === 'open') {
      firestoreUpdates.done = false;
      firestoreUpdates.status = 'active';
      localUpdates.done = false;
      localUpdates.status = 'active';
    } else {
      // migrated / scheduled — keep status active (still visible)
      firestoreUpdates.done = false;
      firestoreUpdates.status = 'active';
      localUpdates.done = false;
      localUpdates.status = 'active';
    }

    if (newDate !== undefined) {
      firestoreUpdates.scheduledDate = newDate;
      localUpdates.scheduledDate = newDate;
    }

    updateTodoField(todo.id, firestoreUpdates, localUpdates);
    render();
  }

  function showMigratePrompt(anchorEl, todo, stateType) {
    closeMigratePrompt();
    closeStatePicker();

    var prompt = document.createElement('div');
    prompt.className = 'todo-migrate-prompt';

    var label = stateType === 'migrated' ? 'Migrate to date:' : 'Schedule for date:';
    var tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    var defaultDate = tomorrow.toISOString().split('T')[0];

    prompt.innerHTML = '<label>' + label + '</label>' +
      '<input type="date" value="' + defaultDate + '">' +
      '<div class="todo-migrate-prompt-actions">' +
      '<button type="button" class="cancel">Cancel</button>' +
      '<button type="button" class="primary">Confirm</button>' +
      '</div>';

    var rect = anchorEl.getBoundingClientRect();
    prompt.style.left = rect.left + 'px';
    prompt.style.top = (rect.bottom + 4) + 'px';
    prompt.style.position = 'fixed';

    document.body.appendChild(prompt);
    _activeMigratePrompt = prompt;

    var dateInput = prompt.querySelector('input[type="date"]');
    dateInput.focus();

    prompt.querySelector('.cancel').addEventListener('click', function() {
      closeMigratePrompt();
    });

    prompt.querySelector('.primary').addEventListener('click', function() {
      var selectedDate = dateInput.value;
      if (!selectedDate) return;
      changeBujoState(todo, stateType, selectedDate);
      closeMigratePrompt();
    });

    dateInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        var selectedDate = dateInput.value;
        if (!selectedDate) return;
        changeBujoState(todo, stateType, selectedDate);
        closeMigratePrompt();
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        closeMigratePrompt();
      }
    });

    // Close on outside click
    setTimeout(function() {
      document.addEventListener('click', function closeOnOutside(e) {
        if (_activeMigratePrompt && !_activeMigratePrompt.contains(e.target)) {
          closeMigratePrompt();
          document.removeEventListener('click', closeOnOutside);
        }
      });
    }, 0);
  }

  function showStatePicker(anchorEl, todo) {
    closeStatePicker();
    closeMigratePrompt();

    var bujoType = todo.bujoType || 'task';
    var bujoState = todo.bujoState || 'open';

    var picker = document.createElement('div');
    picker.className = 'todo-state-picker';

    var items = [];
    if (bujoType === 'task') {
      items = [
        { state: 'open', label: 'Open', icon: '<svg width="14" height="14" viewBox="0 0 16 16"><circle cx="8" cy="8" r="4" fill="#3d3d3d"/></svg>' },
        { state: 'done', label: 'Done', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#7a7a7a" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>' },
        { state: 'migrated', label: 'Migrate...', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#8b6e4e" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,3 13,8 6,13"/></svg>' },
        { state: 'scheduled', label: 'Schedule...', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#5b7a8a" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="10,3 3,8 10,13"/></svg>' }
      ];
    } else {
      // Events and notes get open/done state options
      items = [
        { state: 'open', label: 'Open', icon: bujoType === 'event' ? '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#4a7a9b" stroke-width="2"><circle cx="8" cy="8" r="5.5"/></svg>' : '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#888" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="8" x2="13" y2="8"/></svg>' },
        { state: 'done', label: 'Done', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#7a7a7a" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,8 7,12 13,4"/></svg>' }
      ];
    }
    // Events/notes get a separator + type change options
    items.push({ sep: true });
    items.push({ type: 'task', label: 'Task', icon: '<svg width="14" height="14" viewBox="0 0 16 16"><circle cx="8" cy="8" r="4" fill="#3d3d3d"/></svg>' });
    items.push({ type: 'event', label: 'Event', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#4a7a9b" stroke-width="2"><circle cx="8" cy="8" r="5.5"/></svg>' });
    items.push({ type: 'note', label: 'Note', icon: '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="#888" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="8" x2="13" y2="8"/></svg>' });

    var html = '';
    items.forEach(function(item) {
      if (item.sep) {
        html += '<div class="todo-state-picker-sep"></div>';
        return;
      }
      var isActive = '';
      if (item.state && item.state === bujoState) isActive = ' active';
      if (item.type && item.type === bujoType && !item.state) isActive = ' active';
      var dataAttr = item.state ? 'data-state="' + item.state + '"' : 'data-type="' + item.type + '"';
      html += '<button type="button" class="todo-state-picker-item' + isActive + '" ' + dataAttr + '>' + item.icon + ' ' + item.label + '</button>';
    });

    picker.innerHTML = html;

    var rect = anchorEl.getBoundingClientRect();
    picker.style.left = rect.left + 'px';
    picker.style.top = (rect.bottom + 4) + 'px';
    picker.style.position = 'fixed';

    document.body.appendChild(picker);
    _activeStatePicker = picker;

    // Bind state/type clicks
    picker.querySelectorAll('.todo-state-picker-item').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var newState = btn.getAttribute('data-state');
        var newType = btn.getAttribute('data-type');

        if (newState) {
          if (newState === bujoState) {
            closeStatePicker();
            return;
          }
          if (newState === 'migrated' || newState === 'scheduled') {
            closeStatePicker();
            showMigratePrompt(anchorEl, todo, newState);
            return;
          }
          if (newState === 'done' && bujoType === 'task') {
            closeStatePicker();
            // Use completion modal for tasks
            if (window.dmTodoComplete) {
              window.dmTodoComplete.open(todo, function(result) {
                if (!result) { render(); return; }
                completeTodo(todo, result.actualMin, result.category);
              });
            }
            return;
          }
          if (newState === 'done' && bujoType !== 'task') {
            closeStatePicker();
            // Events and notes complete directly
            completeTodo(todo, null, null);
            return;
          }
          changeBujoState(todo, newState);
        }

        if (newType) {
          if (newType === bujoType) {
            closeStatePicker();
            return;
          }
          var firestoreUpdates = { bujoType: newType, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
          var localUpdates = { bujoType: newType, updatedAt: Date.now() };
          // If switching to event/note from a non-open task state, reset to open
          if (newType !== 'task' && bujoState !== 'open') {
            firestoreUpdates.bujoState = 'open';
            firestoreUpdates.done = false;
            firestoreUpdates.status = 'active';
            localUpdates.bujoState = 'open';
            localUpdates.done = false;
            localUpdates.status = 'active';
          }
          updateTodoField(todo.id, firestoreUpdates, localUpdates);
          render();
        }

        closeStatePicker();
      });
    });

    // Close on outside click
    setTimeout(function() {
      document.addEventListener('click', function closePickerOutside(e) {
        if (_activeStatePicker && !_activeStatePicker.contains(e.target)) {
          closeStatePicker();
          document.removeEventListener('click', closePickerOutside);
        }
      });
    }, 0);

    // Close on Escape
    function closePickerOnEsc(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeStatePicker();
        document.removeEventListener('keydown', closePickerOnEsc);
      }
    }
    document.addEventListener('keydown', closePickerOnEsc);
  }

  // Close pickers on Escape
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      if (_activeMigratePrompt) { closeMigratePrompt(); e.preventDefault(); return; }
      if (_activeStatePicker) { closeStatePicker(); e.preventDefault(); return; }
    }
  });

  // ─── Event listeners ───
  function attachEventListeners() {
    // Day group collapse toggle
    itemsEl.querySelectorAll('.todo-day-header[data-day-toggle]').forEach(function(header) {
      header.addEventListener('click', function() {
        var groupKey = header.getAttribute('data-day-toggle');
        var group = itemsEl.querySelector('.todo-day-group[data-day-group="' + groupKey + '"]');
        if (!group) return;
        var isCollapsed = group.classList.toggle('collapsed');
        try { localStorage.setItem('dm-todo-daygroup-' + groupKey, isCollapsed ? '1' : '0'); } catch(e) {}
      });
    });

    // Subtask collapse toggle
    itemsEl.querySelectorAll('.todo-subtask-toggle').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var parentId = btn.getAttribute('data-toggle-parent');
        var wrapper = itemsEl.querySelector('.todo-subtasks-wrapper[data-subtasks-parent="' + parentId + '"]');
        var isCollapsed = btn.classList.toggle('collapsed');
        if (wrapper) wrapper.classList.toggle('collapsed', isCollapsed);
        try { localStorage.setItem('dm-todo-subtask-collapsed-' + parentId, isCollapsed ? '1' : '0'); } catch(e) {}
      });
    });

    // Migrate group to today (button in overdue day group header)
    itemsEl.querySelectorAll('.todo-day-migrate-btn[data-migrate-group]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation(); // Don't toggle collapse
        var groupDate = btn.getAttribute('data-migrate-group');
        migrateGroupToToday(groupDate);
      });
    });

    // Migrate individual task to today
    itemsEl.querySelectorAll('.todo-item-action-btn.migrate-today[data-migrate-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-migrate-id');
        migrateToToday(todoId);
      });
    });

    // BuJo bullet click — toggle open/done
    itemsEl.querySelectorAll('.todo-bujo-bullet[data-bullet-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-bullet-id');
        var todo = allTodos.find(function(t) { return t.id === todoId; });
        if (!todo) { console.warn('[bujo-click] todo not found for id:', todoId); return; }
        var bujoType = todo.bujoType || 'task';
        var bujoState = todo.bujoState || 'open';


        if (bujoState === 'open') {
          if (bujoType === 'task') {
            // Tasks use the completion modal (for time tracking)
            var pomodoroMinutes = 0;
            if (window.dmPomodoro && window.dmPomodoro.isActive(todoId)) {
              pomodoroMinutes = _pomodoroTrackedMinutes[todoId] || 0;
              window.dmPomodoro.stop();
              if (_pomodoroTrackedMinutes[todoId]) {
                pomodoroMinutes = _pomodoroTrackedMinutes[todoId];
              }
            } else if (_pomodoroTrackedMinutes[todoId]) {
              pomodoroMinutes = _pomodoroTrackedMinutes[todoId];
            }

            if (window.dmTodoComplete) {
              var modalOpts = {};
              if (pomodoroMinutes > 0) {
                modalOpts.trackedMinutes = pomodoroMinutes;
              }
              window.dmTodoComplete.open(todo, function(result) {
                if (!result) {
                  render();
                  return;
                }
                completeTodo(todo, result.actualMin, result.category);
                delete _pomodoroTrackedMinutes[todoId];
                try {
                  var _tracked = JSON.parse(localStorage.getItem('dm-pomodoro-tracked') || '{}');
                  delete _tracked[todoId];
                  if (Object.keys(_tracked).length === 0) {
                    localStorage.removeItem('dm-pomodoro-tracked');
                  } else {
                    localStorage.setItem('dm-pomodoro-tracked', JSON.stringify(_tracked));
                  }
                } catch(e) {}
              }, modalOpts);
            }
          } else {
            // Events and notes complete directly (no time tracking)
            completeTodo(todo, null, null);
          }
        } else if (bujoState === 'done') {
          // Reopen
          reopenTodo(todo);
        } else if (bujoState === 'migrated' || bujoState === 'scheduled') {
          // Reopen migrated/scheduled tasks back to open
          reopenTodo(todo);
        }
      });
    });

    // BuJo bullet right-click — open state picker
    itemsEl.querySelectorAll('.todo-bujo-bullet[data-bullet-id]').forEach(function(btn) {
      btn.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
        var todoId = btn.getAttribute('data-bullet-id');
        var todo = allTodos.find(function(t) { return t.id === todoId; });
        if (!todo) return;
        showStatePicker(btn, todo);
      });
    });

    // Add subtask button
    itemsEl.querySelectorAll('.add-subtask').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var parentId = btn.getAttribute('data-parent-id');
        showSubtaskInput(parentId);
      });
    });

    // Delete button — instant delete with undo toast (no confirmation modal)
    itemsEl.querySelectorAll('[data-delete-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-delete-id');
        deleteTodoWithUndo(todoId);
      });
    });

    // Archive button (individual done tasks)
    itemsEl.querySelectorAll('[data-archive-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-archive-id');
        archiveTodo(todoId);
      });
    });

    // Shared edit handler — opens the edit modal for a given todo ID
    function openEditForTodo(todoId) {
      var todo = allTodos.find(function(t) { return t.id === todoId; });
      if (!todo || !window.dmTodoEdit) return;
      window.dmTodoEdit.open(todo, function(result) {
        if (!result) return;
        var firestoreUpdates = {};
        var localUpdates = {};
        if (result.title !== todo.title) {
          firestoreUpdates.title = result.title;
          localUpdates.title = result.title;
        }
        if (result.scheduledDate !== (todo.scheduledDate || null)) {
          firestoreUpdates.scheduledDate = result.scheduledDate || null;
          localUpdates.scheduledDate = result.scheduledDate || null;
        }
        if (result.estimatedMin !== (todo.estimatedMin || null)) {
          firestoreUpdates.estimatedMin = result.estimatedMin || null;
          localUpdates.estimatedMin = result.estimatedMin || null;
          // Also update pomodoroLength so the timer uses the new estimate as
          // the per-session work duration.
          if (result.estimatedMin && result.estimatedMin > 0) {
            firestoreUpdates.pomodoroLength = result.estimatedMin;
            localUpdates.pomodoroLength = result.estimatedMin;
          }
        }
        if (result.category !== (todo.category || null)) {
          firestoreUpdates.category = result.category || null;
          localUpdates.category = result.category || null;
        }
        // BuJo type
        if (result.bujoType && result.bujoType !== (todo.bujoType || 'task')) {
          firestoreUpdates.bujoType = result.bujoType;
          localUpdates.bujoType = result.bujoType;
        }
        // BuJo state — sync with done/status
        if (result.bujoState && result.bujoState !== (todo.bujoState || 'open')) {
          firestoreUpdates.bujoState = result.bujoState;
          localUpdates.bujoState = result.bujoState;
          if (result.bujoState === 'done') {
            firestoreUpdates.done = true;
            firestoreUpdates.status = 'done';
            localUpdates.done = true;
            localUpdates.status = 'done';
          } else if (result.bujoState === 'open') {
            firestoreUpdates.done = false;
            firestoreUpdates.status = 'active';
            localUpdates.done = false;
            localUpdates.status = 'active';
          } else {
            // migrated / scheduled — keep active so item stays visible
            firestoreUpdates.done = false;
            firestoreUpdates.status = 'active';
            localUpdates.done = false;
            localUpdates.status = 'active';
          }
        }
        if (Object.keys(firestoreUpdates).length > 0) {
          firestoreUpdates.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
          localUpdates.updatedAt = Date.now();
          updateTodoField(todoId, firestoreUpdates, localUpdates);
          render();
        }
      });
    }

    // Edit button
    itemsEl.querySelectorAll('[data-edit-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        openEditForTodo(btn.getAttribute('data-edit-id'));
      });
    });

    // Double-click on task item to edit
    itemsEl.querySelectorAll('.todo-item[data-todo-id]').forEach(function(item) {
      item.addEventListener('dblclick', function(e) {
        // Don't trigger if double-clicking on checkbox, buttons, or links
        if (e.target.closest('input, button, a, .todo-drag-handle')) return;
        e.preventDefault();
        openEditForTodo(item.getAttribute('data-todo-id'));
      });
    });

    // Reminder bell button
    itemsEl.querySelectorAll('.reminder-bell[data-reminder-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-reminder-id');
        showReminderPopover(btn, todoId);
      });
    });

    // Pomodoro timer button
    itemsEl.querySelectorAll('.pomodoro-start[data-pomodoro-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var todoId = btn.getAttribute('data-pomodoro-id');
        var todo = allTodos.find(function(t) { return t.id === todoId; });
        if (!todo) return;
        if (window.dmPomodoro) {
          if (window.dmPomodoro.isActive(todoId)) {
            // Toggle pause/resume
            window.dmPomodoro.togglePause();
            render();
            return;
          }
          window.dmPomodoro.start(todoId, todo.title);
          render();
        }
      });
    });

    // Pomodoro stop button on todo item
    itemsEl.querySelectorAll('[data-pomodoro-stop-id]').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (window.dmPomodoro) {
          window.dmPomodoro.stop();
          render();
        }
      });
    });

    // Archive all completed button
    var archiveAllBtn = document.getElementById('todo-archive-all');
    if (archiveAllBtn) {
      archiveAllBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        var doneIds = [];
        allTodos.forEach(function(t) {
          if (t.status === 'done') doneIds.push(t.id);
        });
        if (doneIds.length === 0) return;
        var msg = 'Archive ' + doneIds.length + ' completed task' + (doneIds.length > 1 ? 's' : '') + '? They will be preserved in your stats and archive.';
        showDeleteConfirm(msg, function() {
          archiveAllCompleted(doneIds);
        }, 'Archive All');
      });
    }
  }

  // ─── Drag-and-drop reordering (SortableJS) ───
  var _sortableInstances = [];

  function initSortable() {
    // Destroy previous instances
    _sortableInstances.forEach(function(s) { try { s.destroy(); } catch(e) {} });
    _sortableInstances = [];

    if (typeof Sortable === 'undefined') return;

    // Sortable for parent tasks across day groups
    itemsEl.querySelectorAll('.todo-day-group-items').forEach(function(groupEl) {
      var s = Sortable.create(groupEl, {
        group: 'parent-todos',
        handle: '.todo-drag-handle',
        draggable: '.todo-item-group',
        ghostClass: 'todo-drag-ghost',
        chosenClass: 'todo-drag-chosen',
        dragClass: 'todo-drag-active',
        animation: 150,
        fallbackOnBody: true,
        swapThreshold: 0.65,
        filter: '.done, .migrated, .scheduled',
        onEnd: function(evt) {
          handleParentDrop(evt);
        }
      });
      _sortableInstances.push(s);
    });

    // Sortable for subtasks within each parent
    itemsEl.querySelectorAll('.todo-subtasks').forEach(function(subEl) {
      var s = Sortable.create(subEl, {
        handle: '.todo-drag-handle',
        draggable: '.todo-item',
        ghostClass: 'todo-drag-ghost',
        chosenClass: 'todo-drag-chosen',
        dragClass: 'todo-drag-active',
        animation: 150,
        filter: '.done, .migrated, .scheduled',
        onEnd: function(evt) {
          handleSubtaskDrop(evt);
        }
      });
      _sortableInstances.push(s);
    });
  }

  function handleParentDrop(evt) {
    var itemGroupEl = evt.item; // .todo-item-group
    var todoId = itemGroupEl.getAttribute('data-group-id');
    var todo = allTodos.find(function(t) { return t.id === todoId; });
    if (!todo) return;

    // Determine new day group from the target container
    var targetGroupItems = evt.to; // .todo-day-group-items
    var dayGroupEl = targetGroupItems.closest('.todo-day-group');
    var targetDayKey = dayGroupEl ? dayGroupEl.getAttribute('data-day-group') : null;

    // Calculate new scheduledDate
    var newScheduledDate = null;
    if (targetDayKey && targetDayKey !== '_unscheduled') {
      newScheduledDate = targetDayKey; // YYYY-MM-DD string
    }

    // Calculate new order based on position among siblings
    var siblings = targetGroupItems.querySelectorAll('.todo-item-group');
    var newOrder = calculateOrderForPosition(siblings, evt.newIndex, todoId);

    // Build update
    var updates = { order: newOrder, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
    var localUpdates = { order: newOrder, updatedAt: Date.now() };

    // Update scheduledDate if moved to a different group
    if (todo.scheduledDate !== newScheduledDate) {
      updates.scheduledDate = newScheduledDate;
      localUpdates.scheduledDate = newScheduledDate;
      // Also update children's scheduledDate
      var children = allTodos.filter(function(t) { return t.parentId === todoId; });
      children.forEach(function(child) {
        child.scheduledDate = newScheduledDate;
        updateTodoField(child.id, { scheduledDate: newScheduledDate, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { scheduledDate: newScheduledDate, updatedAt: Date.now() });
      });
    }

    // Apply locally
    todo.order = newOrder;
    if (localUpdates.scheduledDate !== undefined) todo.scheduledDate = localUpdates.scheduledDate;
    todo.updatedAt = Date.now();

    // Write to Firestore
    updateTodoField(todoId, updates, localUpdates);

    // Re-render to reflect sorted state
    render();
  }

  function handleSubtaskDrop(evt) {
    var itemEl = evt.item; // .todo-item
    var todoId = itemEl.getAttribute('data-todo-id');
    var todo = allTodos.find(function(t) { return t.id === todoId; });
    if (!todo) return;

    // Calculate new order based on position among siblings
    var siblings = evt.to.querySelectorAll('.todo-item');
    var newOrder = calculateOrderForPosition(siblings, evt.newIndex, todoId);

    todo.order = newOrder;
    todo.updatedAt = Date.now();

    updateTodoField(todoId, { order: newOrder, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { order: newOrder, updatedAt: Date.now() });

    render();
  }

  function calculateOrderForPosition(siblingEls, newIndex, movedId) {
    // Get the order values of neighbors, excluding the moved item
    var orders = [];
    siblingEls.forEach(function(el) {
      var id = el.getAttribute('data-group-id') || el.getAttribute('data-todo-id');
      if (id === movedId) return;
      var t = allTodos.find(function(todo) { return todo.id === id; });
      if (t) orders.push(t.order || 0);
    });
    orders.sort(function(a, b) { return a - b; });

    if (orders.length === 0) return 1;

    // Adjust index since we excluded the moved item
    var adjustedIndex = newIndex;
    // Find the orders of the items before and after the new position
    var prevOrder = adjustedIndex > 0 ? orders[adjustedIndex - 1] : null;
    var nextOrder = adjustedIndex < orders.length ? orders[adjustedIndex] : null;

    if (prevOrder === null && nextOrder !== null) {
      // Moved to first position
      return nextOrder - 1;
    } else if (nextOrder === null && prevOrder !== null) {
      // Moved to last position
      return prevOrder + 1;
    } else if (prevOrder !== null && nextOrder !== null) {
      // Moved between two items
      return (prevOrder + nextOrder) / 2;
    }
    return 1;
  }

  function updateTodoField(todoId, firestoreUpdates, localUpdates) {
    if (!window.dmSync) return;
    // Update local allTodos
    var todo = allTodos.find(function(t) { return t.id === todoId; });
    if (todo && localUpdates) {
      Object.keys(localUpdates).forEach(function(key) {
        todo[key] = localUpdates[key];
      });
    }
    window.dmSync.firestoreWrite({
      collection: 'todos',
      docId: todoId,
      op: 'update',
      data: firestoreUpdates,
      localOp: function() {
        if (todo) return window.dmSync.putTodo(todo);
        return Promise.resolve();
      }
    }).catch(function(err) {
      console.error('Error updating todo order:', err);
    });
  }

  function showSubtaskInput(parentId) {
    // Remove any existing subtask input
    var existing = document.querySelector('.todo-add-subtask-row');
    if (existing) existing.remove();

    // Expand subtasks if collapsed
    var toggleBtn = itemsEl.querySelector('.todo-subtask-toggle[data-toggle-parent="' + parentId + '"]');
    var wrapper = itemsEl.querySelector('.todo-subtasks-wrapper[data-subtasks-parent="' + parentId + '"]');
    if (toggleBtn && toggleBtn.classList.contains('collapsed')) {
      toggleBtn.classList.remove('collapsed');
      if (wrapper) wrapper.classList.remove('collapsed');
      try { localStorage.setItem('dm-todo-subtask-collapsed-' + parentId, '0'); } catch(e) {}
    }

    // Find where to insert
    var subtasksEl = itemsEl.querySelector('.todo-subtasks[data-parent-id="' + parentId + '"]');
    var parentItem = itemsEl.querySelector('.todo-item[data-todo-id="' + parentId + '"]');
    if (!parentItem) return;

    var row = document.createElement('div');
    row.className = 'todo-add-subtask-row';
    row.innerHTML =
      '<input type="text" class="todo-add-subtask-input" placeholder="Subtask...">' +
      '<input type="number" class="todo-add-subtask-estimate" min="1" placeholder="25">' +
      '<button type="button" class="todo-add-subtask-btn" title="Add subtask" aria-label="Add subtask">' +
        '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>' +
      '</button>';

    if (subtasksEl) {
      subtasksEl.appendChild(row);
    } else if (wrapper) {
      wrapper.appendChild(row);
    } else {
      parentItem.insertAdjacentElement('afterend', row);
    }

    var subInput = row.querySelector('.todo-add-subtask-input');
    var subEstInput = row.querySelector('.todo-add-subtask-estimate');
    var subAddBtn = row.querySelector('.todo-add-subtask-btn');
    subInput.focus();

    function addSubtask(keepOpen) {
      var title = subInput.value.trim();
      if (!title) { subInput.focus(); return; }
      var est = parseInt(subEstInput.value, 10) || 25;
      // Subtasks inherit parent's scheduledDate
      var parent = allTodos.find(function(t) { return t.id === parentId; });
      var scheduledDate = parent ? parent.scheduledDate : null;
      createTodo(title, est, parentId, scheduledDate, null, null, false, 1, null, function() {
        if (keepOpen) showSubtaskInput(parentId);
      });
      if (!keepOpen) row.remove();
      else {
        subInput.value = '';
        subEstInput.value = '';
        subInput.focus();
      }
    }

    subInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        addSubtask(e.metaKey || e.ctrlKey);
      }
      if (e.key === 'Escape') { row.remove(); }
    });
    subEstInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        addSubtask(e.metaKey || e.ctrlKey);
      }
      if (e.key === 'Escape') { row.remove(); }
    });
    subAddBtn.addEventListener('click', function() { addSubtask(false); });
  }

  // ─── Reminder popover ───
  var _activePopover = null;

  function closeReminderPopover() {
    if (_activePopover) {
      _activePopover.remove();
      _activePopover = null;
    }
  }

  function showReminderPopover(anchorBtn, todoId) {
    // Close any existing popover (both types)
    closeReminderPopover();
    closeAddFormPopover();

    var todo = allTodos.find(function(t) { return t.id === todoId; });
    if (!todo) return;

    var hasReminder = todo.reminderAt && !todo.reminderFired;

    var popover = document.createElement('div');
    popover.className = 'todo-reminder-popover';

    var html = '<div class="todo-reminder-popover-title">Remind me</div>';
    html += '<div class="todo-reminder-shortcuts">';
    html += '<button type="button" class="todo-reminder-shortcut-btn" data-rtype="30">In 30 minutes</button>';
    html += '<button type="button" class="todo-reminder-shortcut-btn" data-rtype="60">In 1 hour</button>';
    html += '<button type="button" class="todo-reminder-shortcut-btn" data-rtype="tomorrow9">Tomorrow 9 AM</button>';
    html += '</div>';
    html += '<div class="todo-reminder-custom">';
    html += '<input type="datetime-local" class="todo-reminder-datetime" value="' + (hasReminder ? toDatetimeLocalStr(todo.reminderAt) : '') + '">';
    html += '<button type="button" class="todo-reminder-set-btn" title="Set custom time">';
    html += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    html += '</button>';
    html += '</div>';
    if (hasReminder) {
      html += '<button type="button" class="todo-reminder-clear-btn">Clear reminder</button>';
    }

    popover.innerHTML = html;

    // Append to .todo-item (not button) so inputs are interactive
    var todoItem = anchorBtn.closest('.todo-item');
    if (!todoItem) { todoItem = anchorBtn.parentNode; }
    todoItem.style.position = 'relative';

    // Calculate position: align to the right edge of the actions area, below the button
    var btnRect = anchorBtn.getBoundingClientRect();
    var parentRect = todoItem.getBoundingClientRect();
    popover.style.top = (btnRect.bottom - parentRect.top + 4) + 'px';
    popover.style.right = Math.max(0, parentRect.right - btnRect.right) + 'px';

    todoItem.appendChild(popover);
    _activePopover = popover;

    // Shortcut buttons
    popover.querySelectorAll('.todo-reminder-shortcut-btn').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var type = btn.getAttribute('data-rtype');
        var ms = getReminderMs(type);
        if (ms && window.dmSync) {
          window.dmSync.setReminder(todoId, ms).then(function() {
            closeReminderPopover();
            loadTodos();
          });
        }
      });
    });

    // Custom datetime set button
    var customInput = popover.querySelector('.todo-reminder-datetime');
    var setBtn = popover.querySelector('.todo-reminder-set-btn');
    setBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (!customInput.value) return;
      var ms = new Date(customInput.value).getTime();
      if (isNaN(ms) || ms <= Date.now()) {
        customInput.style.borderColor = 'var(--color-danger)';
        return;
      }
      if (window.dmSync) {
        window.dmSync.setReminder(todoId, ms).then(function() {
          closeReminderPopover();
          loadTodos();
        });
      }
    });

    // Clear reminder button
    var clearBtn = popover.querySelector('.todo-reminder-clear-btn');
    if (clearBtn) {
      clearBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (window.dmSync) {
          window.dmSync.clearReminder(todoId).then(function() {
            closeReminderPopover();
            loadTodos();
          });
        }
      });
    }

    // Close on outside click
    function onDocClick(e) {
      if (popover && !popover.contains(e.target) && e.target !== anchorBtn) {
        closeReminderPopover();
        document.removeEventListener('click', onDocClick, true);
      }
    }
    // Delay to avoid immediate close from the current click
    setTimeout(function() {
      document.addEventListener('click', onDocClick, true);
    }, 0);

    // Close on Escape
    function onKeyDown(e) {
      if (e.key === 'Escape') {
        closeReminderPopover();
        document.removeEventListener('keydown', onKeyDown);
      }
    }
    document.addEventListener('keydown', onKeyDown);
  }

  // ─── CRUD operations ───
  function getNextOrder(parentId) {
    var siblings = allTodos.filter(function(t) {
      return parentId ? t.parentId === parentId : !t.parentId;
    });
    var maxOrder = 0;
    siblings.forEach(function(t) {
      if (t.order > maxOrder) maxOrder = t.order;
    });
    return maxOrder + 1;
  }

  function getMinOrder(parentId) {
    var siblings = allTodos.filter(function(t) {
      return parentId ? t.parentId === parentId : !t.parentId;
    });
    var minOrder = 1;
    siblings.forEach(function(t) {
      if (t.order < minOrder) minOrder = t.order;
    });
    return minOrder - 1;
  }

  function createTodo(title, estimatedMin, parentId, scheduledDate, reminderAtMs, category, atTop, pomodoroCount, pomodoroLength, onDone, source, breakLength, bujoType) {
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser) {
      showTodoError('Not signed in — please sign in to add tasks');
      if (onDone) onDone();
      return;
    }

    var user = window.dmAuth.currentUser;
    var order = atTop ? getMinOrder(parentId || null) : getNextOrder(parentId || null);

    // Request notification permission early if setting a reminder
    if (reminderAtMs && typeof Notification !== 'undefined' && Notification.permission === 'default') {
      try { Notification.requestPermission(); } catch(e) {}
    }

    var pCount = pomodoroCount || 1;
    var pLength = pomodoroLength || (_addFormPomoMode === 'long' ? _globalPomoLongWork : _globalPomoShortWork);

    var todoData = {
      userId: user.uid,
      title: title,
      estimatedMin: estimatedMin || (pCount * pLength),
      actualMin: null,
      category: category || null,
      pomodoroCount: pCount,
      pomodoroLength: pLength,
      breakLength: breakLength || null,
      done: false,
      status: 'active',
      parentId: parentId || null,
      order: order,
      scheduledDate: scheduledDate || null,
      reminderAt: reminderAtMs ? firebase.firestore.Timestamp.fromMillis(reminderAtMs) : null,
      reminderFired: false,
      source: source || null,
      bujoType: bujoType || 'task',
      bujoState: 'open',
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      completedAt: null
    };

    // Generate client-side ID so we can write locally even when offline
    var newDocId = window.dmDb ? window.dmDb.collection('todos').doc().id : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    var localTodo = {
      id: newDocId,
      userId: user.uid,
      title: title,
      estimatedMin: estimatedMin || (pCount * pLength),
      actualMin: null,
      category: category || null,
      pomodoroCount: pCount,
      pomodoroLength: pLength,
      breakLength: breakLength || null,
      done: false,
      status: 'active',
      parentId: parentId || null,
      order: order,
      scheduledDate: scheduledDate || null,
      reminderAt: reminderAtMs || null,
      reminderFired: false,
      source: source || null,
      bujoType: bujoType || 'task',
      bujoState: 'open',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      completedAt: null
    };

    if (window.dmSync) {
      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: newDocId,
        op: 'set',
        data: todoData,
        localOp: function() {
          allTodos.push(localTodo);
          return window.dmSync.putTodo(localTodo);
        }
      }).then(function() {
        _justAddedIds[newDocId] = true;
        if (onDone) onDone();
        render();
        // Clear flash class after animation completes
        setTimeout(function() { delete _justAddedIds[newDocId]; }, 1600);
      }).catch(function(err) {
        console.error('Error creating todo:', err);
        showTodoError('Failed to add task — check console');
        if (onDone) onDone();
      });
    }
  }

  function completeTodo(todo, actualMin, category) {
    var updateData = {
      done: true,
      status: 'done',
      bujoState: 'done',
      actualMin: actualMin,
      category: category,
      completedAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    // Optimistic local update
    todo.done = true;
    todo.status = 'done';
    todo.bujoState = 'done';
    todo.actualMin = actualMin;
    todo.category = category;
    todo.completedAt = Date.now();
    todo.updatedAt = Date.now();

    if (window.dmSync) {
      _justCompletedIds[todo.id] = true;
      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: todo.id,
        op: 'update',
        data: updateData,
        localOp: function() {
          return window.dmSync.putTodo(todo);
        }
      }).then(function() {
        // Check if parent should auto-complete
        checkParentAutoComplete(todo.parentId);
        render();
        clearJustCompletedIds();
      }).catch(function(err) {
        console.error('Error completing todo:', err);
        showTodoError('Failed to complete task — check console');
        // Revert local state so UI reflects the failure
        todo.done = false;
        todo.status = 'active';
        todo.bujoState = 'open';
        todo.actualMin = null;
        todo.category = null;
        todo.completedAt = null;
        delete _justCompletedIds[todo.id];
        render();
      });
    }
  }

  function checkParentAutoComplete(parentId) {
    if (!parentId) return;

    var parent = allTodos.find(function(t) { return t.id === parentId; });
    if (!parent || parent.done) return;

    var children = allTodos.filter(function(t) { return t.parentId === parentId; });
    if (children.length === 0) return;

    var allDone = children.every(function(t) { return t.done; });
    if (!allDone) return;

    // Calculate parent's actual time = sum of children
    var totalActual = 0;
    var categories = [];
    children.forEach(function(c) {
      if (c.actualMin != null) totalActual += c.actualMin;
      if (c.category && categories.indexOf(c.category) === -1) {
        categories.push(c.category);
      }
    });

    var updateData = {
      done: true,
      status: 'done',
      actualMin: totalActual,
      category: categories.join(', ') || null,
      completedAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    // Optimistic local update
    parent.done = true;
    parent.status = 'done';
    parent.actualMin = totalActual;
    parent.category = categories.join(', ') || null;
    parent.completedAt = Date.now();
    parent.updatedAt = Date.now();

    if (window.dmSync) {
      _justCompletedIds[parent.id] = true;
      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: parent.id,
        op: 'update',
        data: updateData,
        localOp: function() {
          return window.dmSync.putTodo(parent);
        }
      }).then(function() {
        render();
        clearJustCompletedIds();
      }).catch(function(err) {
        console.error('Error auto-completing parent:', err);
        showTodoError('Failed to auto-complete parent task');
        delete _justCompletedIds[parent.id];
      });
    }
  }

  function reopenTodo(todo) {
    var updateData = {
      done: false,
      status: 'active',
      bujoState: 'open',
      actualMin: null,
      category: null,
      completedAt: null,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    // Optimistic local update
    todo.done = false;
    todo.status = 'active';
    todo.bujoState = 'open';
    todo.actualMin = null;
    todo.category = null;
    todo.completedAt = null;
    todo.updatedAt = Date.now();

    if (window.dmSync) {
      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: todo.id,
        op: 'update',
        data: updateData,
        localOp: function() {
          return window.dmSync.putTodo(todo);
        }
      }).then(function() {
        // If this is a subtask, reopen parent too
        if (todo.parentId) {
          var parent = allTodos.find(function(t) { return t.id === todo.parentId; });
          if (parent && parent.done) {
            reopenTodo(parent);
            return;
          }
        }
        render();
      }).catch(function(err) {
        console.error('Error reopening todo:', err);
      });
    }
  }

  function deleteTodo(todoId) {
    // Also soft-delete children
    var toDelete = [todoId];
    allTodos.forEach(function(t) {
      if (t.parentId === todoId) toDelete.push(t.id);
    });

    if (!window.dmSync) return;

    var chain = Promise.resolve();
    toDelete.forEach(function(id) {
      chain = chain.then(function() {
        var todo = allTodos.find(function(t) { return t.id === id; });
        if (!todo) return Promise.resolve();
        var updateData = {
          done: false,
          status: 'deleted',
          bujoState: null,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        // Optimistic local update
        todo.done = false;
        todo.status = 'deleted';
        todo.bujoState = null;
        todo.updatedAt = Date.now();
        return window.dmSync.firestoreWrite({
          collection: 'todos',
          docId: id,
          op: 'update',
          data: updateData,
          localOp: function() {
            return window.dmSync.putTodo(todo);
          }
        });
      });
    });

    chain.then(function() {
      render();
    }).catch(function(err) {
      console.error('Error deleting todo:', err);
      showTodoError('Failed to delete task — check console');
    });
  }

  // ─── Instant delete with undo toast ───
  var _undoTimer = null;
  var _undoToast = null;

  function deleteTodoWithUndo(todoId) {
    // Snapshot the state of all affected todos before deleting (for undo)
    var affectedIds = [todoId];
    allTodos.forEach(function(t) {
      if (t.parentId === todoId) affectedIds.push(t.id);
    });

    var snapshots = [];
    affectedIds.forEach(function(id) {
      var todo = allTodos.find(function(t) { return t.id === id; });
      if (todo) {
        snapshots.push({
          id: id,
          done: todo.done,
          status: todo.status,
          bujoState: todo.bujoState
        });
      }
    });

    var todoTitle = '';
    var mainTodo = allTodos.find(function(t) { return t.id === todoId; });
    if (mainTodo) {
      todoTitle = mainTodo.title || '';
      if (todoTitle.length > 32) todoTitle = todoTitle.substring(0, 32) + '...';
    }

    // Perform the delete immediately
    deleteTodo(todoId);

    // Show undo toast
    showUndoToast(todoTitle, function() {
      undoDelete(snapshots);
    });
  }

  function undoDelete(snapshots) {
    if (!window.dmSync || !snapshots || !snapshots.length) return;

    var chain = Promise.resolve();
    snapshots.forEach(function(snap) {
      chain = chain.then(function() {
        var todo = allTodos.find(function(t) { return t.id === snap.id; });
        if (!todo) return Promise.resolve();

        var updateData = {
          done: snap.done,
          status: snap.status,
          bujoState: snap.bujoState,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        // Restore local state
        todo.done = snap.done;
        todo.status = snap.status;
        todo.bujoState = snap.bujoState;
        todo.updatedAt = Date.now();

        return window.dmSync.firestoreWrite({
          collection: 'todos',
          docId: snap.id,
          op: 'update',
          data: updateData,
          localOp: function() {
            return window.dmSync.putTodo(todo);
          }
        });
      });
    });

    chain.then(function() {
      render();
    }).catch(function(err) {
      console.error('Error undoing delete:', err);
      showTodoError('Failed to undo delete — check console');
    });
  }

  function showUndoToast(taskTitle, onUndo) {
    // Clear any existing undo toast
    dismissUndoToast();

    var toast = document.createElement('div');
    toast.className = 'todo-toast todo-toast-undo';
    var label = taskTitle ? 'Deleted "' + taskTitle + '"' : 'Task deleted';
    toast.innerHTML =
      '<span class="todo-undo-label">' + label + '</span>' +
      '<button type="button" class="todo-undo-btn">Undo</button>';
    document.body.appendChild(toast);
    _undoToast = toast;

    // Wire undo button
    toast.querySelector('.todo-undo-btn').addEventListener('click', function(e) {
      e.stopPropagation();
      dismissUndoToast();
      if (onUndo) onUndo();
    });

    // Slide in
    setTimeout(function() { toast.classList.add('show'); }, 10);

    // Auto-dismiss after 5 seconds
    _undoTimer = setTimeout(function() {
      dismissUndoToast();
    }, 5000);
  }

  function dismissUndoToast() {
    if (_undoTimer) { clearTimeout(_undoTimer); _undoTimer = null; }
    if (_undoToast) {
      _undoToast.classList.remove('show');
      var t = _undoToast;
      setTimeout(function() { t.remove(); }, 300);
      _undoToast = null;
    }
  }

  function archiveAllCompleted(ids) {
    if (!window.dmSync || ids.length === 0) return;

    var chain = Promise.resolve();
    ids.forEach(function(id) {
      chain = chain.then(function() {
        var todo = allTodos.find(function(t) { return t.id === id; });
        if (!todo) return Promise.resolve();
        var updateData = {
          status: 'archived',
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        // Optimistic local update
        todo.status = 'archived';
        todo.updatedAt = Date.now();
        return window.dmSync.firestoreWrite({
          collection: 'todos',
          docId: id,
          op: 'update',
          data: updateData,
          localOp: function() {
            return window.dmSync.putTodo(todo);
          }
        });
      });
    });

    chain.then(function() {
      render();
    }).catch(function(err) {
      console.error('Error archiving completed:', err);
      showTodoError('Failed to archive completed tasks — check console');
    });
  }

  function archiveTodo(todoId) {
    // Archive a single task and its children
    var toArchive = [todoId];
    allTodos.forEach(function(t) {
      if (t.parentId === todoId) toArchive.push(t.id);
    });

    if (!window.dmSync) return;

    var chain = Promise.resolve();
    toArchive.forEach(function(id) {
      chain = chain.then(function() {
        var todo = allTodos.find(function(t) { return t.id === id; });
        if (!todo) return Promise.resolve();
        var updateData = {
          status: 'archived',
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        // Optimistic local update
        todo.status = 'archived';
        todo.updatedAt = Date.now();
        return window.dmSync.firestoreWrite({
          collection: 'todos',
          docId: id,
          op: 'update',
          data: updateData,
          localOp: function() {
            return window.dmSync.putTodo(todo);
          }
        });
      });
    });

    chain.then(function() {
      render();
    }).catch(function(err) {
      console.error('Error archiving todo:', err);
      showTodoError('Failed to archive task — check console');
    });
  }

  // ─── Add form ───
  function addFromForm(keepOpen) {
    var title = addTitleInput.value.trim();
    if (!title) { addTitleInput.focus(); return; }
    var customMin = addCustomMinInput.value ? parseInt(addCustomMinInput.value, 10) : null;
    var pomCount = _addFormPomodoroCount;
    var pomLen = _addFormPomoMode === 'long' ? _globalPomoLongWork : _globalPomoShortWork;
    var pomBreakLen = _addFormPomoMode === 'long' ? _globalPomoLongBreak : _globalPomoShortBreak;
    var est;
    if (customMin != null && customMin >= 0) {
      // Custom minutes override: set pomodoroLength to the custom value so the
      // timer uses this as the per-session work duration.  Keep pomCount as-is
      // so multiple sessions of this custom length are supported.
      pomLen = customMin;
      est = pomCount > 0 ? pomCount * customMin : customMin;
    } else if (pomCount > 0) {
      est = pomCount * pomLen;
    } else {
      est = 0;
    }
    var scheduledDate = _addFormDate || null;
    var reminderAtMs = _addFormReminderMs && _addFormReminderMs > Date.now() ? _addFormReminderMs : null;
    var category = _addFormCategory || null;
    addBtn.disabled = true;
    createTodo(title, est, null, scheduledDate, reminderAtMs, category, true, pomCount, pomLen, function() {
      addBtn.disabled = false;
    }, null, pomBreakLen, _addFormBujoType);
    addTitleInput.value = '';
    addCustomMinInput.value = '';
    // Reset pomodoro count to default but keep date and category sticky for rapid task creation
    _addFormPomodoroCount = _defaultPomodoroCount;
    updatePomodoroCountDisplay();
    // Clear reminder but keep date and category so user can rapidly add tasks
    _addFormReminderMs = null;
    updateReminderChip();
    // Reset bujo type back to task
    _addFormBujoType = 'task';
    if (bujoTypeToggle) {
      bujoTypeToggle.querySelectorAll('.todo-add-bujo-type-btn').forEach(function(b) { b.classList.remove('active'); });
      var taskBtn = bujoTypeToggle.querySelector('[data-bujo-type="task"]');
      if (taskBtn) taskBtn.classList.add('active');
    }
    if (addPomoGroup) addPomoGroup.style.display = '';
    if (addCustomMinInput) addCustomMinInput.style.display = '';
    addTitleInput.placeholder = 'What needs to be done?';
    closeAddFormPopover();
    hideCatPopover();
    closePomodoroConfigPopover();
    if (keepOpen) {
      addTitleInput.focus();
    } else {
      collapseForm();
      addTitleInput.blur();
    }
  }

  addBtn.addEventListener('click', function() { addFromForm(false); });
  // Prevent Enter in custom min input from submitting; Tab moves focus to title
  addCustomMinInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') { e.preventDefault(); addTitleInput.focus(); }
  });
  addTitleInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      var title = addTitleInput.value.trim();
      if (!title) { addTitleInput.focus(); return; }
      // If no category set yet, prompt user to pick one first
      if (!_addFormCategory) {
        _addFormCategoryPrompted = true;
        showCatPopover();
        return;
      }
      // Cmd+Enter or Shift+Enter → submit and keep form open for rapid add
      var keepOpen = e.metaKey || e.shiftKey;
      addFromForm(keepOpen);
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      collapseForm();
      addTitleInput.blur();
    }
  });

  // ─── Elevated add-form focus mode ───
  var addFormEl = document.getElementById('todo-add-form');
  var addBackdrop = document.getElementById('todo-add-backdrop');
  var _formElevated = false;
  var _formPlaceholder = null;

  function elevateForm() {
    if (_formElevated) return;
    _formElevated = true;
    // Insert a placeholder to preserve layout space
    _formPlaceholder = document.createElement('div');
    _formPlaceholder.style.height = addFormEl.offsetHeight + 'px';
    _formPlaceholder.style.marginBottom = getComputedStyle(addFormEl).marginBottom;
    addFormEl.parentNode.insertBefore(_formPlaceholder, addFormEl);
    addFormEl.classList.add('elevated');
    addBackdrop.classList.add('visible');
  }

  function collapseForm() {
    if (!_formElevated) return;
    _formElevated = false;
    addFormEl.classList.remove('elevated');
    addBackdrop.classList.remove('visible');
    if (_formPlaceholder && _formPlaceholder.parentNode) {
      _formPlaceholder.parentNode.removeChild(_formPlaceholder);
      _formPlaceholder = null;
    }
  }

  addTitleInput.addEventListener('focus', function() {
    elevateForm();
  });

  if (addBackdrop) {
    addBackdrop.addEventListener('click', function() {
      collapseForm();
      addTitleInput.blur();
    });
  }

  // Document-level Escape to close elevated form from any focus context
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && _formElevated) {
      e.preventDefault();
      e.stopPropagation();
      collapseForm();
      addTitleInput.blur();
    }
  });

  // ─── Load todos ───
  function loadTodos() {
    if (!window.dmSync) return;

    window.dmSync.getAllTodos().then(function(todos) {
      // Migrate legacy todos: backfill status field from done boolean
      var needsMigration = [];
      todos.forEach(function(t) {
        var migrated = false;
        if (!t.status) {
          // Legacy done=true tasks become 'done' (still visible) so user can review/archive them
          t.status = t.done ? 'done' : 'active';
          t.done = t.status === 'done';
          migrated = true;
        }
        // Backfill bujoType and bujoState for tasks created before BuJo system
        if (!t.bujoType) {
          t.bujoType = 'task';
          migrated = true;
        }
        if (!t.bujoState) {
          t.bujoState = t.done ? 'done' : 'open';
          migrated = true;
        }
        if (migrated) needsMigration.push(t);
      });
      // Persist migrated todos to IDB (fire-and-forget)
      if (needsMigration.length > 0 && window.dmSync) {
        console.log('[todo-list] Migrating ' + needsMigration.length + ' legacy tasks to status field');
        needsMigration.forEach(function(t) {
          window.dmSync.putTodo(t);
        });
      }
      allTodos = todos;
      render();
    });
  }

  // Listen for todo updates
  window.addEventListener('dm-todos-updated', loadTodos);
  window.addEventListener('dm-sync-complete', loadTodos);

  // Listen for AI-suggested task creation
  window.addEventListener('dm-ai-create-task', function(e) {
    var detail = e.detail || {};
    var title = (detail.title || '').trim();
    if (!title) return;
    // AI-created tasks default to today if no date specified (proactive scheduling)
    var scheduledDate = detail.scheduledDate || getTodayStr();
    createTodo(title, detail.estimatedMin || null, null, scheduledDate, null, detail.category || null, true, null, null, function() {
      loadTodos();
    }, detail.source || 'ai', null, detail.bujoType || 'task');
  });

  // Listen for AI-suggested subtask creation (from edit modal)
  window.addEventListener('dm-ai-create-subtask', function(e) {
    var detail = e.detail || {};
    var title = (detail.title || '').trim();
    if (!title || !detail.parentId) return;
    var scheduledDate = detail.scheduledDate || getTodayStr();
    createTodo(title, detail.estimatedMin || null, detail.parentId, scheduledDate, null, detail.category || null, false, null, null, function() {
      loadTodos();
    }, detail.source || 'ai');
  });

  // Listen for Pomodoro timer stop — store tracked time and re-render
  window.addEventListener('dm-pomodoro-stopped', function(e) {
    var detail = e.detail || {};
    if (detail.todoId && detail.trackedMinutes > 0) {
      _pomodoroTrackedMinutes[detail.todoId] = detail.trackedMinutes;
      // Also saved to localStorage by pomodoro-timer.html, but sync in-memory copy
    }
    render();
  });

  // Listen for Pomodoro timer state changes (pause/resume/reset/skip) — re-render inline indicators
  window.addEventListener('dm-pomodoro-state-changed', function() {
    render();
  });

  // Initial load when auth is ready
  if (window.dmAuth) {
    function subscribeAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        if (user) {
          loadTodos();
        } else {
          allTodos = [];
          render();
        }
      });
    }
    // On localhost, wait for redirect result to settle before subscribing
    // to avoid the null→user double-fire flash
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeAuth);
    } else {
      subscribeAuth();
    }
  }

})();
</script>
