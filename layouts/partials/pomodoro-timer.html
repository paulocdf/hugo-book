<!-- Pomodoro Timer: Floating countdown widget for TODO tasks -->
<div id="pomodoro-timer" class="pomodoro-timer" style="display: none;">
  <div class="pomodoro-timer-header">
    <span class="pomodoro-timer-phase" id="pomodoro-phase">Work</span>
    <button type="button" class="pomodoro-timer-close" id="pomodoro-close" title="Cancel &amp; discard time" aria-label="Cancel timer">&times;</button>
  </div>
  <div class="pomodoro-timer-category" id="pomodoro-category" style="display:none;"></div>
  <div class="pomodoro-timer-title" id="pomodoro-title"></div>
  <div class="pomodoro-timer-display" id="pomodoro-display">25:00</div>
  <div class="pomodoro-timer-progress">
    <div class="pomodoro-timer-progress-bar" id="pomodoro-progress"></div>
  </div>
  <div class="pomodoro-timer-controls">
    <button type="button" class="pomodoro-btn pomodoro-btn-secondary" id="pomodoro-reset" title="Reset">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-primary" id="pomodoro-toggle">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="pomodoro-play-icon"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="pomodoro-pause-icon" style="display:none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-secondary" id="pomodoro-skip" title="Skip to next phase">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-stop" id="pomodoro-stop" title="Stop &amp; record time">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>
    </button>
  </div>
  <div class="pomodoro-timer-session" id="pomodoro-session">Session 1</div>
  <div class="pomodoro-timer-info" id="pomodoro-info" style="display:none;">
    <span id="pomodoro-started-at"></span>
    <span id="pomodoro-remaining"></span>
    <span id="pomodoro-est-finish"></span>
  </div>
  <div class="pomodoro-timer-subtasks" id="pomodoro-subtasks" style="display:none;"></div>
</div>

<style>
.pomodoro-timer {
  position: fixed;
  bottom: 100px;
  right: 24px;
  width: 220px;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 14px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
  z-index: 1050;
  padding: 14px 16px;
  user-select: none;
  transition: box-shadow 0.3s;
}
.pomodoro-timer:hover {
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}
.pomodoro-timer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
  cursor: grab;
}
.pomodoro-timer-header:active {
  cursor: grabbing;
}
.pomodoro-timer-phase {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--accent-blue);
}
.pomodoro-timer-phase.break {
  color: var(--color-success, #34a853);
}
.pomodoro-timer-close {
  background: none;
  border: none;
  font-size: 1.1rem;
  color: var(--gray-400);
  cursor: pointer;
  padding: 0 2px;
  line-height: 1;
}
.pomodoro-timer-close:hover { color: var(--color-danger); }
.pomodoro-timer-category {
  font-size: 0.68rem;
  font-weight: 500;
  color: var(--color-link);
  background: rgba(0, 105, 255, 0.08);
  padding: 1px 7px;
  border-radius: 4px;
  display: inline-block;
  max-width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}
.pomodoro-timer-title {
  font-size: 0.8rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 8px;
}
.pomodoro-timer-display {
  font-size: 2.2rem;
  font-weight: 700;
  text-align: center;
  font-variant-numeric: tabular-nums;
  color: var(--body-font-color);
  line-height: 1.2;
}
.pomodoro-timer-progress {
  height: 4px;
  background: var(--gray-200);
  border-radius: 2px;
  margin: 8px 0;
  overflow: hidden;
}
.pomodoro-timer-progress-bar {
  height: 100%;
  width: 0%;
  background: var(--accent-blue);
  border-radius: 2px;
  transition: width 1s linear;
}
.pomodoro-timer-progress-bar.break {
  background: var(--color-success, #34a853);
}
.pomodoro-timer-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-top: 6px;
}
.pomodoro-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
}
.pomodoro-btn:active { transform: scale(0.92); }
.pomodoro-btn-primary {
  width: 40px;
  height: 40px;
  background: var(--accent-blue);
  color: #fff;
}
.pomodoro-btn-primary:hover { opacity: 0.9; }
.pomodoro-btn-secondary {
  width: 30px;
  height: 30px;
  background: var(--gray-100);
  color: var(--gray-500);
}
.pomodoro-btn-secondary:hover {
  background: var(--gray-200);
  color: var(--body-font-color);
}
.pomodoro-btn-stop {
  width: 30px;
  height: 30px;
  background: var(--gray-100);
  color: var(--color-danger, #ea4335);
}
.pomodoro-btn-stop:hover {
  background: rgba(234, 67, 53, 0.12);
  color: var(--color-danger, #ea4335);
}
.pomodoro-timer-session {
  text-align: center;
  font-size: 0.7rem;
  color: var(--text-faint);
  margin-top: 6px;
}
/* Active timer indicator on todo item */
.todo-item-timer-active {
  font-size: 0.7rem;
  color: var(--accent-blue);
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 3px;
  animation: pomo-pulse 2s ease-in-out infinite;
}
.todo-item-timer-active.paused {
  animation: none;
  opacity: 0.65;
}
@keyframes pomo-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
@media (max-width: 600px) {
  .pomodoro-timer {
    right: 12px;
    bottom: 80px;
    width: 190px;
  }
}
/* Info section: started-at, remaining, est. finish */
.pomodoro-timer-info {
  display: flex;
  flex-direction: column;
  gap: 1px;
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--gray-200);
  font-size: 0.65rem;
  color: var(--text-faint);
  line-height: 1.4;
}
.pomodoro-timer-info span::before {
  display: inline-block;
  width: 56px;
  font-weight: 600;
  color: var(--gray-400);
}
#pomodoro-started-at::before { content: 'Started'; }
#pomodoro-remaining::before { content: 'Left'; }
#pomodoro-est-finish::before { content: 'Finish'; }
/* Subtask checklist inside pomodoro popup */
.pomodoro-timer-subtasks {
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--gray-200);
  max-height: 120px;
  overflow-y: auto;
  font-size: 0.7rem;
}
.pomodoro-subtask-item {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 2px 0;
  cursor: pointer;
  transition: opacity 0.15s;
}
.pomodoro-subtask-item:hover {
  opacity: 0.8;
}
.pomodoro-subtask-item input[type="checkbox"] {
  width: 13px;
  height: 13px;
  margin: 0;
  flex-shrink: 0;
  cursor: pointer;
  accent-color: var(--color-link);
}
.pomodoro-subtask-item label {
  cursor: pointer;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.pomodoro-subtask-item.done label {
  text-decoration: line-through;
  opacity: 0.5;
}
</style>

<script>
(function() {
  'use strict';

  var WORK_SECONDS = 25 * 60;
  var BREAK_SECONDS = 5 * 60;

  var timerEl = document.getElementById('pomodoro-timer');
  var phaseEl = document.getElementById('pomodoro-phase');
  var categoryEl = document.getElementById('pomodoro-category');
  var titleEl = document.getElementById('pomodoro-title');
  var displayEl = document.getElementById('pomodoro-display');
  var progressEl = document.getElementById('pomodoro-progress');
  var toggleBtn = document.getElementById('pomodoro-toggle');
  var playIcon = document.getElementById('pomodoro-play-icon');
  var pauseIcon = document.getElementById('pomodoro-pause-icon');
  var resetBtn = document.getElementById('pomodoro-reset');
  var skipBtn = document.getElementById('pomodoro-skip');
  var stopBtn = document.getElementById('pomodoro-stop');
  var closeBtn = document.getElementById('pomodoro-close');
  var sessionEl = document.getElementById('pomodoro-session');
  var infoEl = document.getElementById('pomodoro-info');
  var startedAtEl = document.getElementById('pomodoro-started-at');
  var remainingEl = document.getElementById('pomodoro-remaining');
  var estFinishEl = document.getElementById('pomodoro-est-finish');
  var subtasksEl = document.getElementById('pomodoro-subtasks');

  var activeTodoId = null;
  var activeTodoTitle = '';
  var phase = 'work'; // 'work' | 'break'
  var secondsLeft = WORK_SECONDS;
  var totalPhaseSeconds = WORK_SECONDS;
  var isRunning = false;
  var intervalId = null;
  var sessionCount = 1;
  var totalSessions = 1; // total pomodoro sessions for this task
  var accumulatedWorkSeconds = 0; // total work seconds done for this todo
  var startedAt = null; // Date.now() when timer started
  var activeTodoCategory = ''; // category for restored timer display

  // ── State persistence (survives page navigation) ──
  var STATE_KEY = 'dm-pomodoro-state';
  var TRACKED_KEY = 'dm-pomodoro-tracked';

  function saveState() {
    try {
      localStorage.setItem(STATE_KEY, JSON.stringify({
        activeTodoId: activeTodoId,
        activeTodoTitle: activeTodoTitle,
        activeTodoCategory: activeTodoCategory,
        phase: phase,
        secondsLeft: secondsLeft,
        totalPhaseSeconds: totalPhaseSeconds,
        sessionCount: sessionCount,
        totalSessions: totalSessions,
        accumulatedWorkSeconds: accumulatedWorkSeconds,
        startedAt: startedAt,
        WORK_SECONDS: WORK_SECONDS,
        BREAK_SECONDS: BREAK_SECONDS,
        isRunning: isRunning,
        savedAt: Date.now()
      }));
    } catch(e) {}
  }

  function clearState() {
    try { localStorage.removeItem(STATE_KEY); } catch(e) {}
  }

  function saveTrackedMinutes(todoId, minutes) {
    try {
      var tracked = {};
      var raw = localStorage.getItem(TRACKED_KEY);
      if (raw) tracked = JSON.parse(raw);
      tracked[todoId] = minutes;
      localStorage.setItem(TRACKED_KEY, JSON.stringify(tracked));
    } catch(e) {}
  }

  function formatTime(s) {
    var m = Math.floor(s / 60);
    var sec = s % 60;
    return (m < 10 ? '0' : '') + m + ':' + (sec < 10 ? '0' : '') + sec;
  }

  function updateDisplay() {
    displayEl.textContent = formatTime(secondsLeft);
    var pct = ((totalPhaseSeconds - secondsLeft) / totalPhaseSeconds) * 100;
    progressEl.style.width = pct + '%';

    phaseEl.textContent = phase === 'work' ? 'Work' : 'Break';
    phaseEl.className = 'pomodoro-timer-phase' + (phase === 'break' ? ' break' : '');
    progressEl.className = 'pomodoro-timer-progress-bar' + (phase === 'break' ? ' break' : '');

    var sessionText = 'Session ' + sessionCount;
    if (totalSessions > 1) {
      sessionText += '/' + totalSessions;
    }
    sessionText += ' \u00b7 ' + Math.round(accumulatedWorkSeconds / 60) + 'min tracked';
    sessionEl.textContent = sessionText;

    // Update info section
    if (startedAt) {
      infoEl.style.display = '';
      var startDate = new Date(startedAt);
      startedAtEl.textContent = padTime(startDate.getHours()) + ':' + padTime(startDate.getMinutes());

      // Calculate total remaining seconds across all sessions
      var remainingSec = secondsLeft;
      if (phase === 'work') {
        // remaining work in current session + remaining sessions (work + break each)
        var sessionsLeft = totalSessions - sessionCount;
        remainingSec += sessionsLeft * (WORK_SECONDS + BREAK_SECONDS);
      } else {
        // break phase: remaining break + remaining work sessions
        var sessionsLeft = totalSessions - sessionCount; // sessions after current
        remainingSec += sessionsLeft * (WORK_SECONDS + BREAK_SECONDS);
      }

      var remMin = Math.ceil(remainingSec / 60);
      if (remMin >= 60) {
        remainingEl.textContent = Math.floor(remMin / 60) + 'h ' + (remMin % 60) + 'm';
      } else {
        remainingEl.textContent = remMin + 'm';
      }

      var finishMs = Date.now() + remainingSec * 1000;
      var finishDate = new Date(finishMs);
      estFinishEl.textContent = '~' + padTime(finishDate.getHours()) + ':' + padTime(finishDate.getMinutes());
    }

    // Update document title while running
    if (isRunning) {
      document.title = formatTime(secondsLeft) + ' \u2014 ' + (phase === 'work' ? 'Work' : 'Break') + ' | Digital Memory';
    }
  }

  function padTime(n) { return (n < 10 ? '0' : '') + n; }

  function showPlayIcon() {
    playIcon.style.display = '';
    pauseIcon.style.display = 'none';
  }

  function showPauseIcon() {
    playIcon.style.display = 'none';
    pauseIcon.style.display = '';
  }

  function playChime() {
    try {
      var ctx = new (window.AudioContext || window.webkitAudioContext)();
      var notes = [
        { freq: 830, start: 0, dur: 0.12 },
        { freq: 1050, start: 0.13, dur: 0.12 },
        { freq: 1250, start: 0.26, dur: 0.18 }
      ];
      notes.forEach(function(n) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = n.freq;
        gain.gain.setValueAtTime(0.15, ctx.currentTime + n.start);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + n.start + n.dur);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + n.start);
        osc.stop(ctx.currentTime + n.start + n.dur + 0.05);
      });
      setTimeout(function() { ctx.close(); }, 600);
    } catch(e) {}
  }

  function tick() {
    if (secondsLeft <= 0) {
      clearInterval(intervalId);
      intervalId = null;
      isRunning = false;
      showPlayIcon();
      playChime();

      if (phase === 'work') {
        accumulatedWorkSeconds += totalPhaseSeconds;

        // If all sessions are complete, auto-stop
        if (totalSessions > 1 && sessionCount >= totalSessions) {
          updateDisplay();
          closeTimer();
          return;
        }

        // Switch to break
        phase = 'break';
        secondsLeft = BREAK_SECONDS;
        totalPhaseSeconds = BREAK_SECONDS;
        updateDisplay();
        saveState();
        // Auto-start break
        startTimer();
      } else {
        // Break finished, start next work session
        sessionCount++;
        phase = 'work';
        secondsLeft = WORK_SECONDS;
        totalPhaseSeconds = WORK_SECONDS;
        updateDisplay();
        saveState();
        // Don't auto-start — wait for user
      }
      return;
    }
    secondsLeft--;
    updateDisplay();
    // Persist every 5 seconds to avoid excessive writes
    if (secondsLeft % 5 === 0) saveState();
  }

  function startTimer() {
    if (intervalId) return;
    isRunning = true;
    showPauseIcon();
    intervalId = setInterval(tick, 1000);
    updateDisplay();
    saveState();
  }

  function pauseTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    showPlayIcon();
    // Accumulate partial work time
    if (phase === 'work') {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
      totalPhaseSeconds = secondsLeft; // remaining becomes new total for progress tracking
    }
    // Restore page title
    document.title = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    updateDisplay();
    saveState();
  }

  function resetTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    // If resetting during work, accumulate partial work time
    if (phase === 'work' && totalPhaseSeconds > secondsLeft) {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
    }
    phase = 'work';
    secondsLeft = WORK_SECONDS;
    totalPhaseSeconds = WORK_SECONDS;
    showPlayIcon();
    updateDisplay();
    saveState();
  }

  function skipPhase() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;

    if (phase === 'work') {
      // Accumulate partial work time
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);

      // If this was the last session, auto-stop
      if (totalSessions > 1 && sessionCount >= totalSessions) {
        updateDisplay();
        closeTimer();
        return;
      }

      // Move to break
      phase = 'break';
      secondsLeft = BREAK_SECONDS;
      totalPhaseSeconds = BREAK_SECONDS;
    } else {
      // Move to next work session
      sessionCount++;
      phase = 'work';
      secondsLeft = WORK_SECONDS;
      totalPhaseSeconds = WORK_SECONDS;
    }
    showPlayIcon();
    updateDisplay();
    saveState();
  }

  function closeTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;

    // Accumulate any remaining partial work
    if (phase === 'work' && totalPhaseSeconds > secondsLeft) {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
    }

    timerEl.style.display = 'none';
    categoryEl.style.display = 'none';
    categoryEl.textContent = '';
    showPlayIcon();
    clearInfoAndSubtasks();

    // Restore page title
    var cleanTitle = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    document.title = cleanTitle;

    var trackedMinutes = Math.round(accumulatedWorkSeconds / 60);
    var closedTodoId = activeTodoId;
    activeTodoId = null;
    activeTodoTitle = '';
    activeTodoCategory = '';

    // Clear persisted timer state
    clearState();

    // Notify the todo list about tracked time
    if (closedTodoId && trackedMinutes > 0) {
      // Persist tracked minutes to localStorage so they survive navigation
      saveTrackedMinutes(closedTodoId, trackedMinutes);
      window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
        detail: { todoId: closedTodoId, trackedMinutes: trackedMinutes }
      }));
    }
  }

  function cancelTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    timerEl.style.display = 'none';
    categoryEl.style.display = 'none';
    categoryEl.textContent = '';
    clearInfoAndSubtasks();
    showPlayIcon();

    // Restore page title
    var cleanTitle = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    document.title = cleanTitle;

    activeTodoId = null;
    activeTodoTitle = '';
    activeTodoCategory = '';
    // Clear persisted timer state
    clearState();
    // No event fired — time is discarded
  }

  // ── Button handlers ──
  toggleBtn.addEventListener('click', function() {
    if (isRunning) {
      pauseTimer();
    } else {
      startTimer();
    }
  });

  resetBtn.addEventListener('click', resetTimer);
  skipBtn.addEventListener('click', skipPhase);

  // Stop button: confirm and record tracked time
  stopBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      var trackedSoFar = accumulatedWorkSeconds;
      if (phase === 'work') trackedSoFar += (totalPhaseSeconds - secondsLeft);
      var mins = Math.round(trackedSoFar / 60);
      if (mins > 0 && !confirm('Stop timer? ' + mins + ' minute' + (mins !== 1 ? 's' : '') + ' of work will be recorded.')) {
        return;
      }
    }
    closeTimer();
  });

  // Close (x) button: cancel without recording time
  closeBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      if (!confirm('Cancel timer? Tracked time will be discarded.')) {
        return;
      }
    }
    cancelTimer();
  });

  // ── Drag / move support ──
  var isDragging = false;
  var dragOffsetX = 0;
  var dragOffsetY = 0;
  var posRight = 24;  // initial CSS right
  var posBottom = 100; // initial CSS bottom
  var hasCustomPos = false;

  function onDragStart(e) {
    // Only drag from header area (not buttons)
    if (e.target.closest('button')) return;
    isDragging = true;
    var rect = timerEl.getBoundingClientRect();
    var clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
    var clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    timerEl.style.transition = 'none';
    timerEl.style.cursor = 'grabbing';
    e.preventDefault();
  }

  function onDragMove(e) {
    if (!isDragging) return;
    var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
    var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
    var newLeft = clientX - dragOffsetX;
    var newTop = clientY - dragOffsetY;
    // Clamp within viewport
    var rect = timerEl.getBoundingClientRect();
    var maxLeft = window.innerWidth - rect.width;
    var maxTop = window.innerHeight - rect.height;
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    // Switch from right/bottom to left/top positioning
    timerEl.style.right = 'auto';
    timerEl.style.bottom = 'auto';
    timerEl.style.left = newLeft + 'px';
    timerEl.style.top = newTop + 'px';
    hasCustomPos = true;
    e.preventDefault();
  }

  function onDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    timerEl.style.transition = '';
    timerEl.style.cursor = '';
  }

  // Attach drag listeners to the header
  var headerEl = timerEl.querySelector('.pomodoro-timer-header');
  headerEl.style.cursor = 'grab';
  headerEl.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);
  headerEl.addEventListener('touchstart', onDragStart, { passive: false });
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);

  function resetPosition() {
    timerEl.style.left = '';
    timerEl.style.top = '';
    timerEl.style.right = '';
    timerEl.style.bottom = '';
    hasCustomPos = false;
  }

  // ── Subtask loading for pomodoro popup ──
  function loadSubtasks(todoId) {
    if (!window.dmSync || !window.dmSync.getAllTodos) return;
    window.dmSync.getAllTodos().then(function(todos) {
      if (activeTodoId !== todoId) return; // timer was stopped meanwhile
      var subs = (todos || []).filter(function(t) { return t.parentId === todoId; });
      if (subs.length === 0) { subtasksEl.style.display = 'none'; return; }
      subs.sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
      subtasksEl.innerHTML = '';
      subs.forEach(function(sub) {
        var row = document.createElement('div');
        row.className = 'pomodoro-subtask-item' + (sub.done ? ' done' : '');
        row.innerHTML = '<input type="checkbox"' + (sub.done ? ' checked' : '') + '><label>' + escapeHtmlPomo(sub.title) + '</label>';
        var cb = row.querySelector('input');
        cb.addEventListener('change', function() {
          var newDone = cb.checked;
          row.className = 'pomodoro-subtask-item' + (newDone ? ' done' : '');
          toggleSubtaskDone(sub, newDone);
        });
        subtasksEl.appendChild(row);
      });
      subtasksEl.style.display = '';
    }).catch(function() {});
  }

  function escapeHtmlPomo(s) {
    var d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  function toggleSubtaskDone(sub, newDone) {
    sub.done = newDone;
    sub.updatedAt = Date.now();
    if (newDone) sub.completedAt = Date.now();
    else sub.completedAt = null;

    if (window.dmSync) {
      var updateData = {
        done: newDone,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (newDone) updateData.completedAt = firebase.firestore.FieldValue.serverTimestamp();
      else updateData.completedAt = null;

      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: sub.id,
        op: 'update',
        data: updateData,
        localOp: function() { return window.dmSync.putTodo(sub); }
      }).then(function() {
        // Notify todo list to re-render
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      }).catch(function(err) {
        console.error('Error toggling subtask:', err);
      });
    }
  }

  function clearInfoAndSubtasks() {
    startedAt = null;
    infoEl.style.display = 'none';
    subtasksEl.innerHTML = '';
    subtasksEl.style.display = 'none';
  }

  // ── Restore persisted timer state on page load ──
  function restoreState() {
    var raw;
    try { raw = localStorage.getItem(STATE_KEY); } catch(e) { return; }
    if (!raw) return;
    var s;
    try { s = JSON.parse(raw); } catch(e) { clearState(); return; }
    if (!s || !s.activeTodoId || !s.savedAt) { clearState(); return; }

    // Calculate elapsed time since state was saved
    var elapsedMs = Date.now() - s.savedAt;
    if (elapsedMs < 0) { clearState(); return; } // clock skew, discard
    var elapsedSec = Math.floor(elapsedMs / 1000);

    // Restore config
    WORK_SECONDS = s.WORK_SECONDS || 25 * 60;
    BREAK_SECONDS = s.BREAK_SECONDS || 5 * 60;
    activeTodoId = s.activeTodoId;
    activeTodoTitle = s.activeTodoTitle || 'Task';
    activeTodoCategory = s.activeTodoCategory || '';
    totalSessions = s.totalSessions || 1;
    startedAt = s.startedAt;

    // Restore mutable state
    var rPhase = s.phase || 'work';
    var rSecondsLeft = s.secondsLeft || 0;
    var rTotalPhase = s.totalPhaseSeconds || WORK_SECONDS;
    var rSessionCount = s.sessionCount || 1;
    var rAccWork = s.accumulatedWorkSeconds || 0;
    var wasRunning = s.isRunning;

    // If timer was running, simulate elapsed time
    if (wasRunning && elapsedSec > 0) {
      var result = simulateElapsed(rPhase, rSecondsLeft, rTotalPhase, rSessionCount, rAccWork, elapsedSec);
      if (result.finished) {
        // Timer completed entirely during navigation — auto-close
        var trackedMinutes = Math.round(result.accWork / 60);
        clearState();
        if (trackedMinutes > 0) {
          saveTrackedMinutes(activeTodoId, trackedMinutes);
          window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
            detail: { todoId: activeTodoId, trackedMinutes: trackedMinutes }
          }));
        }
        activeTodoId = null;
        activeTodoTitle = '';
        activeTodoCategory = '';
        return;
      }
      rPhase = result.phase;
      rSecondsLeft = result.secondsLeft;
      rTotalPhase = result.totalPhase;
      rSessionCount = result.sessionCount;
      rAccWork = result.accWork;
    }

    // Apply restored state
    phase = rPhase;
    secondsLeft = rSecondsLeft;
    totalPhaseSeconds = rTotalPhase;
    sessionCount = rSessionCount;
    accumulatedWorkSeconds = rAccWork;

    // Update UI
    titleEl.textContent = activeTodoTitle;
    if (activeTodoCategory) {
      categoryEl.textContent = activeTodoCategory;
      categoryEl.style.display = '';
    }
    updateDisplay();
    resetPosition();
    timerEl.style.display = '';

    // Load subtasks
    loadSubtasks(activeTodoId);

    // Resume or show paused state
    if (wasRunning) {
      startTimer();
    } else {
      showPlayIcon();
      saveState();
    }
  }

  /**
   * Simulate elapsed seconds across phase transitions.
   * Returns { phase, secondsLeft, totalPhase, sessionCount, accWork, finished }
   */
  function simulateElapsed(curPhase, curSecondsLeft, curTotalPhase, curSession, curAccWork, elapsed) {
    var remaining = elapsed;

    while (remaining > 0) {
      if (remaining >= curSecondsLeft) {
        // Phase completed during navigation
        remaining -= curSecondsLeft;

        if (curPhase === 'work') {
          curAccWork += curSecondsLeft; // work seconds remaining = work done to finish phase

          // Check if all sessions are done
          if (totalSessions > 1 && curSession >= totalSessions) {
            return { finished: true, accWork: curAccWork };
          }

          // Switch to break (auto-started)
          curPhase = 'break';
          curSecondsLeft = BREAK_SECONDS;
          curTotalPhase = BREAK_SECONDS;
        } else {
          // Break finished — next work session does NOT auto-start
          curSession++;
          curPhase = 'work';
          curSecondsLeft = WORK_SECONDS;
          curTotalPhase = WORK_SECONDS;
          // Break → work transition doesn't auto-start, so stop consuming time
          break;
        }
      } else {
        // Elapsed time consumed within current phase
        if (curPhase === 'work') {
          // Track partial work done during elapsed time
          curAccWork += remaining;
          // Adjust totalPhase so progress bar is accurate
          curTotalPhase = curSecondsLeft; // total = what was left before elapsed
        }
        curSecondsLeft -= remaining;
        remaining = 0;
      }
    }

    return {
      finished: false,
      phase: curPhase,
      secondsLeft: curSecondsLeft,
      totalPhase: curTotalPhase,
      sessionCount: curSession,
      accWork: curAccWork
    };
  }

  // Restore on page load
  restoreState();

  // ── Public API ──
  window.dmPomodoro = {
    start: function(todoId, todoTitle) {
      // If a different todo is already being timed, close it first
      if (activeTodoId && activeTodoId !== todoId) {
        closeTimer();
      }
      activeTodoId = todoId;
      activeTodoTitle = todoTitle || 'Task';
      activeTodoCategory = '';
      titleEl.textContent = activeTodoTitle;

      // Look up category and pomodoro config from IndexedDB
      categoryEl.style.display = 'none';
      categoryEl.textContent = '';

      // Set defaults
      WORK_SECONDS = 25 * 60;
      BREAK_SECONDS = 5 * 60;
      totalSessions = 1;

      function initAndStart() {
        phase = 'work';
        secondsLeft = WORK_SECONDS;
        totalPhaseSeconds = WORK_SECONDS;
        sessionCount = 1;
        accumulatedWorkSeconds = 0;
        startedAt = Date.now();
        isRunning = false;
        showPlayIcon();
        updateDisplay();
        resetPosition();
        timerEl.style.display = '';
        startTimer();
      }

      // Clear subtasks from previous run
      subtasksEl.innerHTML = '';
      subtasksEl.style.display = 'none';

      if (window.dmSync && window.dmSync.getTodo) {
        window.dmSync.getTodo(todoId).then(function(todo) {
          if (todo && activeTodoId === todoId) {
            if (todo.category) {
              categoryEl.textContent = todo.category;
              categoryEl.style.display = '';
              activeTodoCategory = todo.category;
            }
            if (todo.pomodoroLength && todo.pomodoroLength > 0) {
              WORK_SECONDS = todo.pomodoroLength * 60;
            }
            if (todo.breakLength && todo.breakLength > 0) {
              BREAK_SECONDS = todo.breakLength * 60;
            } else {
              // Fall back to global short-break default
              try { var v = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (v > 0) BREAK_SECONDS = v * 60; } catch(e) {}
            }
            if (todo.pomodoroCount && todo.pomodoroCount > 0) {
              totalSessions = todo.pomodoroCount;
            }
          }
          // Load subtasks
          loadSubtasks(todoId);
          initAndStart();
        }).catch(function() {
          initAndStart();
        });
      } else {
        initAndStart();
      }
    },
    stop: closeTimer,
    pause: pauseTimer,
    resume: startTimer,
    togglePause: function() {
      if (isRunning) {
        pauseTimer();
      } else if (activeTodoId) {
        startTimer();
      }
    },
    isActive: function(todoId) {
      return activeTodoId === todoId;
    },
    isTimerRunning: function() {
      return isRunning;
    },
    getActiveTodoId: function() {
      return activeTodoId;
    },
    getSessionInfo: function() {
      return { current: sessionCount, total: totalSessions };
    },
    getStartedAt: function() {
      return startedAt;
    }
  };
})();
</script>
