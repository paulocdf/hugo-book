<!-- Pomodoro Timer: Floating countdown widget for TODO tasks -->
<div id="pomodoro-timer" class="pomodoro-timer" style="display: none;">
  <div class="pomodoro-timer-header">
    <span class="pomodoro-timer-phase" id="pomodoro-phase">Work</span>
    <div class="pomodoro-timer-header-actions">
      <button type="button" class="pomodoro-timer-expand" id="pomodoro-expand" title="Focus mode" aria-label="Focus mode">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
      </button>
      <button type="button" class="pomodoro-timer-close" id="pomodoro-close" title="Cancel &amp; discard time" aria-label="Cancel timer">&times;</button>
    </div>
  </div>
  <div class="pomodoro-timer-category" id="pomodoro-category" style="display:none;"></div>
  <div class="pomodoro-timer-title" id="pomodoro-title"></div>
  <div class="pomodoro-timer-display" id="pomodoro-display">25:00</div>
  <div class="pomodoro-timer-progress">
    <div class="pomodoro-timer-progress-bar" id="pomodoro-progress"></div>
  </div>
  <div class="pomodoro-timer-controls">
    <button type="button" class="pomodoro-btn pomodoro-btn-secondary" id="pomodoro-reset" title="Reset">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-primary" id="pomodoro-toggle">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="pomodoro-play-icon"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="pomodoro-pause-icon" style="display:none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-secondary" id="pomodoro-skip" title="Skip to next phase">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>
    </button>
    <button type="button" class="pomodoro-btn pomodoro-btn-stop" id="pomodoro-stop" title="Stop &amp; record time">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>
    </button>
  </div>
  <div class="pomodoro-timer-session" id="pomodoro-session">Session 1</div>
  <div class="pomodoro-timer-subtasks" id="pomodoro-subtasks" style="display:none;"></div>
  <div class="pomodoro-timer-info" id="pomodoro-info" style="display:none;">
    <span id="pomodoro-started-at"></span>
    <span id="pomodoro-remaining"></span>
    <span id="pomodoro-est-finish"></span>
  </div>
</div>

<!-- Focused / Zen mode overlay -->
<div id="pomodoro-focus-overlay" class="pomodoro-focus-overlay" style="display:none;">
  <div class="pomodoro-focus-backdrop"></div>
  <div class="pomodoro-focus-card">
    <!-- Top header strip with ambient visualizer canvas behind -->
    <div class="pomodoro-focus-header-strip">
      <canvas id="focus-viz-canvas" class="pomodoro-focus-viz-canvas"></canvas>
      <div class="pomodoro-focus-header">
        <div class="pomodoro-focus-header-left">
          <span class="pomodoro-focus-phase" id="focus-phase">Work</span>
          <div class="pomodoro-focus-category" id="focus-category" style="display:none;"></div>
        </div>
        <div class="pomodoro-focus-header-actions">
          <button type="button" class="pomodoro-focus-viz-toggle" id="focus-viz-toggle" title="Switch visualizer mode" aria-label="Switch visualizer mode">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
          </button>
          <button type="button" class="pomodoro-focus-collapse" id="focus-collapse" title="Exit focus mode" aria-label="Exit focus mode">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
          </button>
          <button type="button" class="pomodoro-focus-close-btn" id="focus-close" title="Cancel &amp; discard time" aria-label="Cancel timer">&times;</button>
        </div>
      </div>
    </div>

    <!-- Two-column body -->
    <div class="pomodoro-focus-body">
      <!-- Left column: timer core -->
      <div class="pomodoro-focus-left">
        <div class="pomodoro-focus-title" id="focus-title"></div>
        <div class="pomodoro-focus-display" id="focus-display">25:00</div>
        <div class="pomodoro-focus-progress">
          <div class="pomodoro-focus-progress-bar" id="focus-progress"></div>
        </div>
        <div class="pomodoro-focus-controls">
          <button type="button" class="pomodoro-btn pomodoro-focus-btn-secondary" id="focus-reset" title="Reset">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
          </button>
          <button type="button" class="pomodoro-btn pomodoro-focus-btn-primary" id="focus-toggle">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" id="focus-play-icon"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" id="focus-pause-icon" style="display:none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
          </button>
          <button type="button" class="pomodoro-btn pomodoro-focus-btn-secondary" id="focus-skip" title="Skip to next phase">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>
          </button>
          <button type="button" class="pomodoro-btn pomodoro-focus-btn-stop" id="focus-stop" title="Stop &amp; record time">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>
          </button>
        </div>
        <div class="pomodoro-focus-session" id="focus-session">Session 1</div>

        <!-- Session timeline: visual blocks for each pomodoro -->
        <div class="pomodoro-focus-timeline" id="focus-timeline" style="display:none;">
          <div class="pomodoro-focus-panel-label">Sessions</div>
          <div class="pomodoro-focus-timeline-blocks" id="focus-timeline-blocks"></div>
        </div>

        <div class="pomodoro-focus-subtasks" id="focus-subtasks" style="display:none;"></div>
        <div class="pomodoro-focus-info" id="focus-info" style="display:none;">
          <span id="focus-started-at"></span>
          <span id="focus-remaining"></span>
          <span id="focus-est-finish"></span>
        </div>
      </div>

      <!-- Right column: contextual panels -->
      <div class="pomodoro-focus-right">
        <!-- Task details panel -->
        <div class="pomodoro-focus-panel" id="focus-panel-details">
          <div class="pomodoro-focus-panel-label">Task Details</div>
          <div class="pomodoro-focus-details-grid" id="focus-details-grid"></div>
        </div>

        <!-- Today's stats panel -->
        <div class="pomodoro-focus-panel" id="focus-panel-stats">
          <div class="pomodoro-focus-panel-label">Today</div>
          <div class="pomodoro-focus-stats-grid" id="focus-stats-grid"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
.pomodoro-timer {
  position: fixed;
  bottom: 100px;
  right: 24px;
  width: 220px;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 14px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
  z-index: 1050;
  padding: 14px 16px;
  user-select: none;
  transition: box-shadow 0.3s;
}
.pomodoro-timer:hover {
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}
.pomodoro-timer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
  cursor: grab;
}
.pomodoro-timer-header:active {
  cursor: grabbing;
}
.pomodoro-timer-phase {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--accent-blue);
}
.pomodoro-timer-phase.break {
  color: var(--color-success, #34a853);
}
.pomodoro-timer-close {
  background: none;
  border: none;
  font-size: 1.1rem;
  color: var(--gray-400);
  cursor: pointer;
  padding: 0 2px;
  line-height: 1;
}
.pomodoro-timer-close:hover { color: var(--color-danger); }
.pomodoro-timer-header-actions {
  display: flex;
  align-items: center;
  gap: 2px;
}
.pomodoro-timer-expand {
  background: none;
  border: none;
  color: var(--gray-400);
  cursor: pointer;
  padding: 2px;
  line-height: 1;
  border-radius: 3px;
  transition: color 0.15s, background 0.15s;
}
.pomodoro-timer-expand:hover {
  color: var(--accent-blue);
  background: rgba(0, 105, 255, 0.08);
}
.pomodoro-timer-category {
  font-size: 0.68rem;
  font-weight: 500;
  color: var(--color-link);
  background: rgba(0, 105, 255, 0.08);
  padding: 1px 7px;
  border-radius: 4px;
  display: inline-block;
  max-width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}
.pomodoro-timer-title {
  font-size: 0.8rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 8px;
}
.pomodoro-timer-display {
  font-size: 2.2rem;
  font-weight: 700;
  text-align: center;
  font-variant-numeric: tabular-nums;
  color: var(--body-font-color);
  line-height: 1.2;
}
.pomodoro-timer-progress {
  height: 4px;
  background: var(--gray-200);
  border-radius: 2px;
  margin: 8px 0;
  overflow: hidden;
}
.pomodoro-timer-progress-bar {
  height: 100%;
  width: 0%;
  background: var(--accent-blue);
  border-radius: 2px;
  transition: width 1s linear;
}
.pomodoro-timer-progress-bar.break {
  background: var(--color-success, #34a853);
}
.pomodoro-timer-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-top: 6px;
}
.pomodoro-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
}
.pomodoro-btn:active { transform: scale(0.92); }
.pomodoro-btn-primary {
  width: 40px;
  height: 40px;
  background: var(--accent-blue);
  color: #fff;
}
.pomodoro-btn-primary:hover { opacity: 0.9; }
.pomodoro-btn-secondary {
  width: 30px;
  height: 30px;
  background: var(--gray-100);
  color: var(--gray-500);
}
.pomodoro-btn-secondary:hover {
  background: var(--gray-200);
  color: var(--body-font-color);
}
.pomodoro-btn-stop {
  width: 30px;
  height: 30px;
  background: var(--gray-100);
  color: var(--color-danger, #ea4335);
}
.pomodoro-btn-stop:hover {
  background: rgba(234, 67, 53, 0.12);
  color: var(--color-danger, #ea4335);
}
.pomodoro-timer-session {
  text-align: center;
  font-size: 0.7rem;
  color: var(--text-faint);
  margin-top: 6px;
}
/* Active timer indicator on todo item */
.todo-item-timer-active {
  font-size: 0.7rem;
  color: var(--accent-blue);
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 3px;
  animation: pomo-pulse 2s ease-in-out infinite;
}
.todo-item-timer-active.paused {
  animation: none;
  opacity: 0.65;
}
@keyframes pomo-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
@media (max-width: 600px) {
  .pomodoro-timer {
    right: 12px;
    bottom: 80px;
    width: 190px;
  }
}
/* Info section: started-at, remaining, est. finish */
.pomodoro-timer-info {
  display: flex;
  flex-direction: column;
  gap: 1px;
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--gray-200);
  font-size: 0.65rem;
  color: var(--text-faint);
  line-height: 1.4;
}
.pomodoro-timer-info span::before {
  display: inline-block;
  width: 56px;
  font-weight: 600;
  color: var(--gray-400);
}
#pomodoro-started-at::before { content: 'Started'; }
#pomodoro-remaining::before { content: 'Left'; }
#pomodoro-est-finish::before { content: 'Finish'; }
/* Subtask checklist inside pomodoro popup */
.pomodoro-timer-subtasks {
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--gray-200);
  max-height: 140px;
  overflow-y: auto;
  font-size: 0.7rem;
}
/* Progress header */
.pomo-subtask-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 4px;
  font-size: 0.62rem;
  font-weight: 600;
  color: var(--text-faint);
  text-transform: uppercase;
  letter-spacing: 0.04em;
}
.pomo-subtask-progress-bar {
  flex: 1;
  height: 3px;
  background: var(--gray-200);
  border-radius: 2px;
  margin-left: 8px;
  overflow: hidden;
}
.pomo-subtask-progress-fill {
  height: 100%;
  background: var(--color-success, #34a853);
  border-radius: 2px;
  transition: width 0.3s ease;
}
/* Subtask item rows */
.pomodoro-subtask-item {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 2px 3px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.15s;
}
.pomodoro-subtask-item:hover {
  background: var(--gray-100);
}
/* Checkbox-style indicator */
.pomo-subtask-checkbox {
  width: 12px;
  height: 12px;
  border-radius: 3px;
  border: 1.5px solid var(--gray-400);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.15s, background 0.15s;
}
.pomo-subtask-checkbox svg {
  display: none;
}
.pomodoro-subtask-item:hover .pomo-subtask-checkbox {
  border-color: var(--color-link);
}
.pomodoro-subtask-item.done .pomo-subtask-checkbox {
  border-color: var(--color-success, #34a853);
  background: var(--color-success, #34a853);
}
.pomodoro-subtask-item.done .pomo-subtask-checkbox svg {
  display: block;
}
/* Label */
.pomodoro-subtask-item label {
  cursor: pointer;
  color: var(--body-font-color);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 0.64rem;
  flex: 1;
  line-height: 1.3;
}
.pomodoro-subtask-item.done label {
  text-decoration: line-through;
  color: var(--text-faint);
}
/* Estimate pill */
.pomo-subtask-est {
  font-size: 0.56rem;
  color: var(--text-faint);
  background: var(--gray-100);
  padding: 0 4px;
  border-radius: 3px;
  flex-shrink: 0;
  line-height: 1.5;
  font-variant-numeric: tabular-nums;
}
.pomodoro-subtask-item.done .pomo-subtask-est {
  opacity: 0.5;
}
/* Active subtask highlight (the one being timed) */
.pomodoro-subtask-item.active {
  background: rgba(0, 105, 255, 0.07);
  border-left: 2px solid var(--accent-blue);
  padding-left: 5px;
}
.pomodoro-subtask-item.active label {
  font-weight: 600;
  color: var(--accent-blue);
}

/* ── Focus / Zen Mode Overlay ── */
.pomodoro-focus-overlay {
  position: fixed;
  inset: 0;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
}
.pomodoro-focus-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
.pomodoro-focus-card {
  position: relative;
  width: 85vw;
  max-width: 960px;
  height: 82vh;
  max-height: 720px;
  display: flex;
  flex-direction: column;
  background: var(--body-background);
  border: 1px solid var(--gray-200);
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  padding: 0 0 24px;
  user-select: none;
  overflow: hidden;
}
/* Header strip: visualizer canvas behind the header controls */
.pomodoro-focus-header-strip {
  position: relative;
  height: 56px;
  flex-shrink: 0;
  overflow: hidden;
  border-radius: 19px 19px 0 0;
  background: #0a0a14;
}
.pomodoro-focus-viz-canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
}
.pomodoro-focus-header {
  position: relative;
  z-index: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 100%;
  padding: 0 20px;
  flex-shrink: 0;
}
.pomodoro-focus-header-left {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}
.pomodoro-focus-phase {
  font-size: 0.82rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: rgba(255, 255, 255, 0.9);
  flex-shrink: 0;
  text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
}
.pomodoro-focus-phase.break {
  color: var(--color-success, #34a853);
}
.pomodoro-focus-header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}
.pomodoro-focus-collapse {
  background: none;
  border: none;
  color: rgba(255, 255, 255, 0.6);
  cursor: pointer;
  padding: 3px;
  line-height: 1;
  border-radius: 4px;
  transition: color 0.15s, background 0.15s;
}
.pomodoro-focus-collapse:hover {
  color: rgba(255, 255, 255, 0.95);
  background: rgba(255, 255, 255, 0.1);
}
.pomodoro-focus-close-btn {
  background: none;
  border: none;
  font-size: 1.3rem;
  color: rgba(255, 255, 255, 0.6);
  cursor: pointer;
  padding: 0 3px;
  line-height: 1;
}
.pomodoro-focus-close-btn:hover { color: var(--color-danger); }
.pomodoro-focus-category {
  font-size: 0.72rem;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.85);
  background: rgba(255, 255, 255, 0.12);
  padding: 2px 9px;
  border-radius: 5px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 180px;
}
/* Two-column body */
.pomodoro-focus-body {
  display: flex;
  gap: 28px;
  flex: 1;
  min-height: 0;
  overflow: hidden;
  padding: 16px 28px 0;
}
.pomodoro-focus-left {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 0;
  overflow-y: auto;
}
.pomodoro-focus-right {
  width: 260px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  gap: 14px;
  overflow-y: auto;
  padding-left: 24px;
  border-left: 1px solid var(--gray-200);
}
.pomodoro-focus-title {
  font-size: 1.15rem;
  font-weight: 600;
  color: var(--body-font-color);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 12px;
  max-width: 100%;
  text-align: center;
}
.pomodoro-focus-display {
  font-size: 5.5rem;
  font-weight: 700;
  text-align: center;
  font-variant-numeric: tabular-nums;
  color: var(--body-font-color);
  line-height: 1.1;
}
.pomodoro-focus-progress {
  height: 6px;
  background: var(--gray-200);
  border-radius: 3px;
  margin: 16px 0;
  overflow: hidden;
  width: 100%;
  max-width: 360px;
}
.pomodoro-focus-progress-bar {
  height: 100%;
  width: 0%;
  background: var(--accent-blue);
  border-radius: 3px;
  transition: width 1s linear;
}
.pomodoro-focus-progress-bar.break {
  background: var(--color-success, #34a853);
}
.pomodoro-focus-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-top: 8px;
}
.pomodoro-focus-btn-primary {
  width: 60px;
  height: 60px;
  background: var(--accent-blue);
  color: #fff;
}
.pomodoro-focus-btn-primary:hover { opacity: 0.9; }
.pomodoro-focus-btn-secondary {
  width: 42px;
  height: 42px;
  background: var(--gray-100);
  color: var(--gray-500);
}
.pomodoro-focus-btn-secondary:hover {
  background: var(--gray-200);
  color: var(--body-font-color);
}
.pomodoro-focus-btn-stop {
  width: 42px;
  height: 42px;
  background: var(--gray-100);
  color: var(--color-danger, #ea4335);
}
.pomodoro-focus-btn-stop:hover {
  background: rgba(234, 67, 53, 0.12);
  color: var(--color-danger, #ea4335);
}
.pomodoro-focus-session {
  text-align: center;
  font-size: 0.78rem;
  color: var(--text-faint);
  margin-top: 10px;
}
/* Session timeline */
.pomodoro-focus-timeline {
  margin-top: 12px;
  width: 100%;
  max-width: 360px;
}
.pomodoro-focus-timeline-blocks {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-top: 6px;
}
.pomodoro-focus-timeline-block {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.62rem;
  font-weight: 600;
  transition: transform 0.15s;
}
.pomodoro-focus-timeline-block.completed {
  background: var(--accent-blue);
  color: #fff;
}
.pomodoro-focus-timeline-block.current {
  background: var(--accent-blue);
  color: #fff;
  box-shadow: 0 0 0 2px var(--body-background), 0 0 0 4px var(--accent-blue);
  animation: focus-pulse-block 2s ease-in-out infinite;
}
.pomodoro-focus-timeline-block.remaining {
  background: var(--gray-100);
  color: var(--gray-400);
  border: 1px solid var(--gray-200);
}
.pomodoro-focus-timeline-block.break-block {
  width: 8px;
  height: 28px;
  border-radius: 3px;
  background: var(--gray-100);
  font-size: 0;
}
.pomodoro-focus-timeline-block.break-block.completed {
  background: var(--color-success, #34a853);
  opacity: 0.5;
}
@keyframes focus-pulse-block {
  0%, 100% { box-shadow: 0 0 0 2px var(--body-background), 0 0 0 4px var(--accent-blue); }
  50% { box-shadow: 0 0 0 2px var(--body-background), 0 0 0 6px rgba(0, 105, 255, 0.3); }
}
/* Focus subtask list */
.pomodoro-focus-subtasks {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--gray-200);
  max-height: 180px;
  overflow-y: auto;
  font-size: 0.8rem;
  width: 100%;
  max-width: 360px;
}
.pomodoro-focus-subtasks .pomo-subtask-header {
  font-size: 0.7rem;
  margin-bottom: 5px;
}
.pomodoro-focus-subtasks .pomodoro-subtask-item {
  padding: 3px 4px;
  gap: 6px;
}
.pomodoro-focus-subtasks .pomo-subtask-checkbox {
  width: 14px;
  height: 14px;
}
.pomodoro-focus-subtasks .pomodoro-subtask-item label {
  font-size: 0.74rem;
}
.pomodoro-focus-subtasks .pomo-subtask-est {
  font-size: 0.64rem;
}
/* Focus info section */
.pomodoro-focus-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--gray-200);
  font-size: 0.74rem;
  color: var(--text-faint);
  line-height: 1.4;
  width: 100%;
  max-width: 360px;
}
.pomodoro-focus-info span::before {
  display: inline-block;
  width: 56px;
  font-weight: 600;
  color: var(--gray-400);
}
#focus-started-at::before { content: 'Started'; }
#focus-remaining::before { content: 'Left'; }
#focus-est-finish::before { content: 'Finish'; }
/* Right-column panels */
.pomodoro-focus-panel {
  padding: 0;
}
.pomodoro-focus-panel-label {
  font-size: 0.68rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--gray-400);
  margin-bottom: 8px;
}
/* Task details grid */
.pomodoro-focus-details-grid {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.pomodoro-focus-detail-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.76rem;
  line-height: 1.4;
}
.pomodoro-focus-detail-label {
  color: var(--gray-400);
  font-weight: 500;
}
.pomodoro-focus-detail-value {
  color: var(--body-font-color);
  font-weight: 600;
  text-align: right;
  max-width: 140px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
/* Today's stats grid */
.pomodoro-focus-stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.pomodoro-focus-stat-card {
  background: var(--gray-100);
  border-radius: 8px;
  padding: 10px;
  text-align: center;
}
.pomodoro-focus-stat-value {
  font-size: 1.3rem;
  font-weight: 700;
  color: var(--body-font-color);
  line-height: 1.2;
}
.pomodoro-focus-stat-label {
  font-size: 0.62rem;
  color: var(--gray-400);
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.04em;
  margin-top: 2px;
}
/* Visualizer toggle in header strip */
.pomodoro-focus-viz-toggle {
  background: none;
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.5);
  cursor: pointer;
  padding: 3px 5px;
  line-height: 1;
  border-radius: 4px;
  transition: color 0.15s, border-color 0.15s;
  font-size: 0.6rem;
}
.pomodoro-focus-viz-toggle:hover {
  color: rgba(255, 255, 255, 0.95);
  border-color: rgba(255, 255, 255, 0.5);
}
/* Responsive: tablets / smaller desktops */
@media (max-width: 800px) {
  .pomodoro-focus-card {
    width: 92vw;
    height: 88vh;
    padding: 0 0 20px;
  }
  .pomodoro-focus-body {
    flex-direction: column;
    gap: 16px;
    padding: 12px 20px 0;
  }
  .pomodoro-focus-left {
    flex: none;
  }
  .pomodoro-focus-right {
    width: 100%;
    border-left: none;
    padding-left: 0;
    border-top: 1px solid var(--gray-200);
    padding-top: 14px;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 12px;
    overflow-y: visible;
  }
  .pomodoro-focus-right .pomodoro-focus-panel {
    flex: 1;
    min-width: 140px;
  }
  .pomodoro-focus-header-strip {
    height: 48px;
  }
  .pomodoro-focus-display {
    font-size: 4rem;
  }
}
/* Mobile: full-screen */
@media (max-width: 600px) {
  .pomodoro-focus-card {
    width: 100%;
    max-width: 100vw;
    max-height: 100vh;
    height: 100vh;
    border-radius: 0;
    padding: 0 0 16px;
  }
  .pomodoro-focus-header-strip {
    height: 44px;
    border-radius: 0;
  }
  .pomodoro-focus-body {
    flex-direction: column;
    gap: 12px;
    padding: 10px 16px 0;
  }
  .pomodoro-focus-left {
    flex: none;
    justify-content: flex-start;
    padding-top: 8px;
  }
  .pomodoro-focus-right {
    width: 100%;
    border-left: none;
    padding-left: 0;
    border-top: 1px solid var(--gray-200);
    padding-top: 12px;
    flex-direction: column;
    gap: 10px;
  }
  .pomodoro-focus-display {
    font-size: 3.5rem;
  }
  .pomodoro-focus-stats-grid {
    grid-template-columns: 1fr 1fr;
  }
}
</style>

<script>
(function() {
  'use strict';

  var WORK_SECONDS = 25 * 60;
  var BREAK_SECONDS = 5 * 60;

  var timerEl = document.getElementById('pomodoro-timer');
  var phaseEl = document.getElementById('pomodoro-phase');
  var categoryEl = document.getElementById('pomodoro-category');
  var titleEl = document.getElementById('pomodoro-title');
  var displayEl = document.getElementById('pomodoro-display');
  var progressEl = document.getElementById('pomodoro-progress');
  var toggleBtn = document.getElementById('pomodoro-toggle');
  var playIcon = document.getElementById('pomodoro-play-icon');
  var pauseIcon = document.getElementById('pomodoro-pause-icon');
  var resetBtn = document.getElementById('pomodoro-reset');
  var skipBtn = document.getElementById('pomodoro-skip');
  var stopBtn = document.getElementById('pomodoro-stop');
  var closeBtn = document.getElementById('pomodoro-close');
  var sessionEl = document.getElementById('pomodoro-session');
  var infoEl = document.getElementById('pomodoro-info');
  var startedAtEl = document.getElementById('pomodoro-started-at');
  var remainingEl = document.getElementById('pomodoro-remaining');
  var estFinishEl = document.getElementById('pomodoro-est-finish');
  var subtasksEl = document.getElementById('pomodoro-subtasks');

  // Focus overlay elements
  var focusOverlay = document.getElementById('pomodoro-focus-overlay');
  var expandBtn = document.getElementById('pomodoro-expand');
  var collapseBtn = document.getElementById('focus-collapse');
  var focusCloseBtn = document.getElementById('focus-close');
  var focusPhaseEl = document.getElementById('focus-phase');
  var focusCategoryEl = document.getElementById('focus-category');
  var focusTitleEl = document.getElementById('focus-title');
  var focusDisplayEl = document.getElementById('focus-display');
  var focusProgressEl = document.getElementById('focus-progress');
  var focusToggleBtn = document.getElementById('focus-toggle');
  var focusPlayIcon = document.getElementById('focus-play-icon');
  var focusPauseIcon = document.getElementById('focus-pause-icon');
  var focusResetBtn = document.getElementById('focus-reset');
  var focusSkipBtn = document.getElementById('focus-skip');
  var focusStopBtn = document.getElementById('focus-stop');
  var focusSessionEl = document.getElementById('focus-session');
  var focusInfoEl = document.getElementById('focus-info');
  var focusStartedAtEl = document.getElementById('focus-started-at');
  var focusRemainingEl = document.getElementById('focus-remaining');
  var focusEstFinishEl = document.getElementById('focus-est-finish');
  var focusSubtasksEl = document.getElementById('focus-subtasks');

  // Focus overlay — new panels
  var focusTimelineEl = document.getElementById('focus-timeline');
  var focusTimelineBlocksEl = document.getElementById('focus-timeline-blocks');
  var focusDetailsGridEl = document.getElementById('focus-details-grid');
  var focusStatsGridEl = document.getElementById('focus-stats-grid');
  var focusVizCanvas = document.getElementById('focus-viz-canvas');
  var focusVizToggle = document.getElementById('focus-viz-toggle');
  var focusVizContainer = focusVizCanvas ? focusVizCanvas.parentElement : null;

  var activeTodoId = null;
  var activeTodoTitle = '';
  var phase = 'work'; // 'work' | 'break'
  var secondsLeft = WORK_SECONDS;
  var totalPhaseSeconds = WORK_SECONDS;
  var isRunning = false;
  var intervalId = null;
  var sessionCount = 1;
  var totalSessions = 1; // total pomodoro sessions for this task
  var accumulatedWorkSeconds = 0; // total work seconds done for this todo
  var startedAt = null; // Date.now() when timer started
  var activeTodoCategory = ''; // category for restored timer display
  var subtaskRemainingMin = 0; // total estimated minutes of uncompleted subtasks
  var activeParentId = null; // parent context for subtask list (equals activeTodoId when timing a parent)
  var isFocusMode = false;

  // ── State persistence (survives page navigation) ──
  var STATE_KEY = 'dm-pomodoro-state';
  var TRACKED_KEY = 'dm-pomodoro-tracked';

  // ── Cross-device sync via Firestore ──
  // Each tab gets a unique deviceId to avoid re-applying its own writes.
  var _deviceId = 'dev-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6);
  var _fsDebounceTimer = null;
  var _fsUnsubscribe = null; // onSnapshot unsubscribe
  var _fsSyncing = false;    // guard: true while applying remote state
  var _lastFsSavedAt = 0;    // timestamp of last Firestore write (to skip stale snapshots)

  function _getTimerDocRef() {
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser) return null;
    return window.dmDb.collection('timerState').doc(window.dmAuth.currentUser.uid);
  }

  function _buildTimerState() {
    return {
      activeTodoId: activeTodoId,
      activeTodoTitle: activeTodoTitle,
      activeTodoCategory: activeTodoCategory,
      activeParentId: activeParentId,
      phase: phase,
      secondsLeft: secondsLeft,
      totalPhaseSeconds: totalPhaseSeconds,
      sessionCount: sessionCount,
      totalSessions: totalSessions,
      accumulatedWorkSeconds: accumulatedWorkSeconds,
      startedAt: startedAt,
      WORK_SECONDS: WORK_SECONDS,
      BREAK_SECONDS: BREAK_SECONDS,
      isRunning: isRunning,
      savedAt: Date.now(),
      deviceId: _deviceId
    };
  }

  // Write timer state to Firestore (debounced when running, immediate on key actions)
  function saveStateToFirestore(immediate) {
    if (_fsSyncing) return; // don't write back while applying remote state
    var ref = _getTimerDocRef();
    if (!ref) return;

    if (_fsDebounceTimer) {
      clearTimeout(_fsDebounceTimer);
      _fsDebounceTimer = null;
    }

    function doWrite() {
      var data = _buildTimerState();
      _lastFsSavedAt = data.savedAt;
      ref.set(data).catch(function(err) {
        console.warn('[pomo-sync] Firestore write failed:', err.message);
      });
    }

    if (immediate) {
      doWrite();
    } else {
      // Debounce to every 10 seconds when running (tick calls saveState every 5s)
      _fsDebounceTimer = setTimeout(doWrite, 10000);
    }
  }

  // Clear timer state from Firestore when timer is closed/cancelled
  function clearStateFromFirestore() {
    if (_fsDebounceTimer) {
      clearTimeout(_fsDebounceTimer);
      _fsDebounceTimer = null;
    }
    var ref = _getTimerDocRef();
    if (!ref) return;
    _lastFsSavedAt = Date.now();
    ref.delete().catch(function(err) {
      console.warn('[pomo-sync] Firestore delete failed:', err.message);
    });
  }

  function saveState() {
    try {
      localStorage.setItem(STATE_KEY, JSON.stringify({
        activeTodoId: activeTodoId,
        activeTodoTitle: activeTodoTitle,
        activeTodoCategory: activeTodoCategory,
        activeParentId: activeParentId,
        phase: phase,
        secondsLeft: secondsLeft,
        totalPhaseSeconds: totalPhaseSeconds,
        sessionCount: sessionCount,
        totalSessions: totalSessions,
        accumulatedWorkSeconds: accumulatedWorkSeconds,
        startedAt: startedAt,
        WORK_SECONDS: WORK_SECONDS,
        BREAK_SECONDS: BREAK_SECONDS,
        isRunning: isRunning,
        savedAt: Date.now()
      }));
    } catch(e) {}
    // Sync to Firestore for cross-device access (debounced)
    saveStateToFirestore(false);
  }

  // Immediate Firestore sync — called on key lifecycle events (start/pause/resume/skip/close)
  function saveStateImmediate() {
    saveState();
    // Override the debounce — write to Firestore immediately
    saveStateToFirestore(true);
  }

  function clearState() {
    try { localStorage.removeItem(STATE_KEY); } catch(e) {}
    clearStateFromFirestore();
  }

  function saveTrackedMinutes(todoId, minutes) {
    try {
      var tracked = {};
      var raw = localStorage.getItem(TRACKED_KEY);
      if (raw) tracked = JSON.parse(raw);
      tracked[todoId] = minutes;
      localStorage.setItem(TRACKED_KEY, JSON.stringify(tracked));
    } catch(e) {}
  }

  function formatTime(s) {
    var m = Math.floor(s / 60);
    var sec = s % 60;
    return (m < 10 ? '0' : '') + m + ':' + (sec < 10 ? '0' : '') + sec;
  }

  function updateDisplay() {
    var timeStr = formatTime(secondsLeft);
    displayEl.textContent = timeStr;
    focusDisplayEl.textContent = timeStr;

    var pct = ((totalPhaseSeconds - secondsLeft) / totalPhaseSeconds) * 100;
    progressEl.style.width = pct + '%';
    focusProgressEl.style.width = pct + '%';

    var phaseText = phase === 'work' ? 'Work' : 'Break';
    phaseEl.textContent = phaseText;
    focusPhaseEl.textContent = phaseText;
    phaseEl.className = 'pomodoro-timer-phase' + (phase === 'break' ? ' break' : '');
    focusPhaseEl.className = 'pomodoro-focus-phase' + (phase === 'break' ? ' break' : '');
    progressEl.className = 'pomodoro-timer-progress-bar' + (phase === 'break' ? ' break' : '');
    focusProgressEl.className = 'pomodoro-focus-progress-bar' + (phase === 'break' ? ' break' : '');

    var sessionText = 'Session ' + sessionCount;
    if (totalSessions > 1) {
      sessionText += '/' + totalSessions;
    }
    sessionText += ' \u00b7 ' + Math.round(accumulatedWorkSeconds / 60) + 'min tracked';
    sessionEl.textContent = sessionText;
    focusSessionEl.textContent = sessionText;

    // Update info section
    if (startedAt) {
      infoEl.style.display = '';
      focusInfoEl.style.display = '';
      var startDate = new Date(startedAt);
      var startedText = padTime(startDate.getHours()) + ':' + padTime(startDate.getMinutes());
      startedAtEl.textContent = startedText;
      focusStartedAtEl.textContent = startedText;

      // Calculate total remaining seconds across all sessions
      var remainingSec = secondsLeft;
      if (phase === 'work') {
        // remaining work in current session + remaining sessions (work + break each)
        var sessionsLeft = totalSessions - sessionCount;
        remainingSec += sessionsLeft * (WORK_SECONDS + BREAK_SECONDS);
      } else {
        // break phase: remaining break + remaining work sessions
        var sessionsLeft = totalSessions - sessionCount; // sessions after current
        remainingSec += sessionsLeft * (WORK_SECONDS + BREAK_SECONDS);
      }

      // Add uncompleted subtask estimated time to finish-at
      remainingSec += subtaskRemainingMin * 60;

      var remMin = Math.ceil(remainingSec / 60);
      var remText;
      if (remMin >= 60) {
        remText = Math.floor(remMin / 60) + 'h ' + (remMin % 60) + 'm';
      } else {
        remText = remMin + 'm';
      }
      remainingEl.textContent = remText;
      focusRemainingEl.textContent = remText;

      var finishMs = Date.now() + remainingSec * 1000;
      var finishDate = new Date(finishMs);
      var finishHrs = (remainingSec / 3600).toFixed(1);
      var finishText = '~' + padTime(finishDate.getHours()) + ':' + padTime(finishDate.getMinutes()) + ' (' + finishHrs + 'h)';
      estFinishEl.textContent = finishText;
      focusEstFinishEl.textContent = finishText;
    }

    // Update document title while running
    if (isRunning) {
      document.title = formatTime(secondsLeft) + ' \u2014 ' + (phase === 'work' ? 'Work' : 'Break') + ' | Digital Memory';
    }

    // Update focus-mode panels
    if (isFocusMode) {
      renderSessionTimeline();
    }
  }

  function padTime(n) { return (n < 10 ? '0' : '') + n; }

  function showPlayIcon() {
    playIcon.style.display = '';
    pauseIcon.style.display = 'none';
    focusPlayIcon.style.display = '';
    focusPauseIcon.style.display = 'none';
  }

  function showPauseIcon() {
    playIcon.style.display = 'none';
    pauseIcon.style.display = '';
    focusPlayIcon.style.display = 'none';
    focusPauseIcon.style.display = '';
  }

  // ── Sound system ──
  // Shared sound library exposed as window.dmSounds for use by settings panel, reminders, etc.
  var SOUND_PRESETS = {
    // ── Notification sounds (work end / break end) ──
    chime: { label: 'Chime', type: 'notification', play: function(ctx, vol) {
      var notes = [
        { freq: 830, start: 0, dur: 0.12 },
        { freq: 1050, start: 0.13, dur: 0.12 },
        { freq: 1250, start: 0.26, dur: 0.18 }
      ];
      playNotes(ctx, notes, 'sine', vol);
      return 500;
    }},
    bell: { label: 'Bell', type: 'notification', play: function(ctx, vol) {
      // Two-strike bell with harmonics
      [0, 0.35].forEach(function(offset) {
        [523, 1046, 1569].forEach(function(freq, i) {
          var osc = ctx.createOscillator();
          var gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          var ampScale = i === 0 ? 1 : (i === 1 ? 0.4 : 0.15);
          gain.gain.setValueAtTime(vol * 0.12 * ampScale, ctx.currentTime + offset);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + offset + 0.8);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(ctx.currentTime + offset);
          osc.stop(ctx.currentTime + offset + 0.85);
        });
      });
      return 1300;
    }},
    digital: { label: 'Digital', type: 'notification', play: function(ctx, vol) {
      // Quick triple beep
      [0, 0.12, 0.24].forEach(function(t) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.value = 1400;
        gain.gain.setValueAtTime(vol * 0.08, ctx.currentTime + t);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + t + 0.08);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + t);
        osc.stop(ctx.currentTime + t + 0.1);
      });
      return 450;
    }},
    bowl: { label: 'Singing bowl', type: 'notification', play: function(ctx, vol) {
      // Long resonant tone with beating harmonics
      var fundamentals = [280, 560, 845];
      fundamentals.forEach(function(freq, i) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        // Slight detune for beating effect
        osc.detune.value = (i === 1) ? 3 : (i === 2 ? -2 : 0);
        var ampScale = i === 0 ? 1 : (i === 1 ? 0.5 : 0.2);
        gain.gain.setValueAtTime(vol * 0.12 * ampScale, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 2.5);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 2.6);
      });
      return 2700;
    }},
    ascending: { label: 'Ascending', type: 'notification', play: function(ctx, vol) {
      // Five-note rising scale
      var freqs = [523, 587, 659, 784, 1047]; // C5-C6
      freqs.forEach(function(freq, i) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        var t = i * 0.12;
        gain.gain.setValueAtTime(vol * 0.13, ctx.currentTime + t);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + t + 0.2);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + t);
        osc.stop(ctx.currentTime + t + 0.25);
      });
      return 800;
    }},
    pulse: { label: 'Soft pulse', type: 'notification', play: function(ctx, vol) {
      // Two gentle low-freq pulses
      [0, 0.4].forEach(function(t) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 440;
        gain.gain.setValueAtTime(0, ctx.currentTime + t);
        gain.gain.linearRampToValueAtTime(vol * 0.15, ctx.currentTime + t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + t + 0.35);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + t);
        osc.stop(ctx.currentTime + t + 0.4);
      });
      return 900;
    }},

    // ── Tick sounds (during countdown) ──
    'tick-soft': { label: 'Soft tick', type: 'tick', play: function(ctx, vol) {
      var osc = ctx.createOscillator();
      var gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 800;
      gain.gain.setValueAtTime(vol * 0.04, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.03);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.04);
      return 60;
    }},
    'tick-click': { label: 'Click', type: 'tick', play: function(ctx, vol) {
      // White-noise click using buffer
      var bufLen = ctx.sampleRate * 0.015;
      var buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
      var data = buf.getChannelData(0);
      for (var i = 0; i < bufLen; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
      var src = ctx.createBufferSource();
      src.buffer = buf;
      var gain = ctx.createGain();
      gain.gain.setValueAtTime(vol * 0.12, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.015);
      src.connect(gain);
      gain.connect(ctx.destination);
      src.start(ctx.currentTime);
      return 40;
    }},
    'tick-woodblock': { label: 'Woodblock', type: 'tick', play: function(ctx, vol) {
      // Short percussive knock
      var osc = ctx.createOscillator();
      var gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.value = 1200;
      osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.03);
      gain.gain.setValueAtTime(vol * 0.08, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.04);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.05);
      return 60;
    }}
  };

  // Helper: play an array of { freq, start, dur } notes
  function playNotes(ctx, notes, oscType, vol) {
    notes.forEach(function(n) {
      var osc = ctx.createOscillator();
      var gain = ctx.createGain();
      osc.type = oscType || 'sine';
      osc.frequency.value = n.freq;
      gain.gain.setValueAtTime(vol * 0.15 / 0.15, ctx.currentTime + n.start); // normalize to vol
      gain.gain.setValueAtTime(vol * 0.15, ctx.currentTime + n.start);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + n.start + n.dur);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime + n.start);
      osc.stop(ctx.currentTime + n.start + n.dur + 0.05);
    });
  }

  // Shared AudioContext for tick sounds (avoid creating one per second)
  var tickAudioCtx = null;
  function getTickCtx() {
    if (!tickAudioCtx || tickAudioCtx.state === 'closed') {
      try { tickAudioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return null; }
    }
    if (tickAudioCtx.state === 'suspended') {
      tickAudioCtx.resume();
    }
    return tickAudioCtx;
  }

  // Read sound preferences from localStorage
  function getSoundPref(key, fallback) {
    try { var v = localStorage.getItem(key); if (v !== null) return v; } catch(e) {}
    return fallback;
  }
  function getSoundVolume() {
    try { var v = parseFloat(localStorage.getItem('dm-pomo-sound-volume')); if (v >= 0 && v <= 1) return v; } catch(e) {}
    return 0.8;
  }

  function playSound(soundId, volumeOverride) {
    if (!soundId || soundId === 'none') return;
    var preset = SOUND_PRESETS[soundId];
    if (!preset) return;
    try {
      var vol = (volumeOverride !== undefined) ? volumeOverride : getSoundVolume();
      if (vol <= 0) return;
      if (preset.type === 'tick') {
        var ctx = getTickCtx();
        if (ctx) preset.play(ctx, vol);
      } else {
        var ctx = new (window.AudioContext || window.webkitAudioContext)();
        var duration = preset.play(ctx, vol);
        setTimeout(function() { try { ctx.close(); } catch(e) {} }, (duration || 1000) + 100);
      }
    } catch(e) {}
  }

  // Convenience methods
  function playWorkEndSound() {
    playSound(getSoundPref('dm-pomo-sound-work', 'chime'));
  }
  function playBreakEndSound() {
    playSound(getSoundPref('dm-pomo-sound-break', 'chime'));
  }
  function playTickSound() {
    var tickId = getSoundPref('dm-pomo-sound-tick', 'none');
    if (tickId && tickId !== 'none') {
      playSound(tickId);
    }
  }

  // Expose globally for settings panel preview and dm-sync reminders
  window.dmSounds = {
    play: playSound,
    presets: SOUND_PRESETS,
    getVolume: getSoundVolume
  };

  // ── Push Notification Scheduling (PWA / Service Worker) ──
  var notifPermission = typeof Notification !== 'undefined' ? Notification.permission : 'denied';
  var notifIconUrl = '';
  (function() {
    var m = document.querySelector('link[rel="manifest"]');
    var base = m ? m.getAttribute('href').replace('/manifest.json', '') : '';
    notifIconUrl = base + '/favicon.png';
  })();

  function requestNotificationPermission() {
    if (typeof Notification === 'undefined') return;
    if (Notification.permission === 'default') {
      Notification.requestPermission().then(function(perm) {
        notifPermission = perm;
      });
    } else {
      notifPermission = Notification.permission;
    }
  }

  function scheduleNotification(delaySec, phaseLabel) {
    if (notifPermission !== 'granted') return;
    var title = phaseLabel === 'work' ? 'Work Session Complete' : 'Break Over';
    var body = activeTodoTitle || 'Pomodoro timer finished';
    if (phaseLabel === 'work') {
      body = activeTodoTitle ? activeTodoTitle + ' — time for a break!' : 'Time for a break!';
    } else {
      body = activeTodoTitle ? activeTodoTitle + ' — ready to focus?' : 'Ready to focus?';
    }

    // Try service worker first (works when app is backgrounded / screen locked)
    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'schedule-notification',
        delay: delaySec * 1000,
        title: title,
        body: body,
        tag: 'pomodoro-phase-end',
        icon: notifIconUrl
      });
      return;
    }

    // Fallback: in-page setTimeout + Notification API (only works if tab is open)
    if (typeof Notification !== 'undefined' && notifPermission === 'granted') {
      window._pomoNotifTimeout = setTimeout(function() {
        try { new Notification(title, { body: body, icon: notifIconUrl, tag: 'pomodoro-phase-end' }); }
        catch(e) { /* Notification constructor not supported on this device */ }
      }, delaySec * 1000);
    }
  }

  function cancelScheduledNotification() {
    // Cancel via service worker
    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'cancel-notification',
        tag: 'pomodoro-phase-end'
      });
    }
    // Cancel fallback timeout
    if (window._pomoNotifTimeout) {
      clearTimeout(window._pomoNotifTimeout);
      window._pomoNotifTimeout = null;
    }
  }

  function tick() {
    if (secondsLeft <= 0) {
      clearInterval(intervalId);
      intervalId = null;
      isRunning = false;
      showPlayIcon();

      if (phase === 'work') {
        playWorkEndSound();
        accumulatedWorkSeconds += totalPhaseSeconds;

        // If all sessions are complete
        if (totalSessions > 1 && sessionCount >= totalSessions) {
          updateDisplay();
          // If timing a subtask, try to advance to the next one
          if (activeParentId && activeParentId !== activeTodoId) {
            advanceToNextSubtask();
          } else {
            closeTimer();
          }
          return;
        }

        // Single-session task just completed — check for subtask auto-advance
        if (totalSessions <= 1) {
          // If timing a subtask, try to advance to the next one
          if (activeParentId && activeParentId !== activeTodoId) {
            advanceToNextSubtask();
            return;
          }
        }

        // Switch to break
        phase = 'break';
        secondsLeft = BREAK_SECONDS;
        totalPhaseSeconds = BREAK_SECONDS;
        updateDisplay();
        saveStateImmediate();
        // Auto-start break
        startTimer();
      } else {
        playBreakEndSound();
        // Break finished, start next work session
        sessionCount++;
        phase = 'work';
        secondsLeft = WORK_SECONDS;
        totalPhaseSeconds = WORK_SECONDS;
        updateDisplay();
        saveStateImmediate();
        // Don't auto-start — wait for user
      }
      return;
    }
    secondsLeft--;
    // Play tick sound if enabled (only during work phase to avoid annoyance during breaks)
    if (phase === 'work') {
      playTickSound();
    }
    updateDisplay();
    // Persist every 5 seconds to avoid excessive writes
    if (secondsLeft % 5 === 0) saveState();
    // Refresh today's stats every 60 seconds in focus mode
    if (isFocusMode && secondsLeft % 60 === 0) renderTodayStats();
  }

  function startTimer() {
    if (intervalId) return;
    isRunning = true;
    showPauseIcon();
    intervalId = setInterval(tick, 1000);
    updateDisplay();
    saveStateImmediate();
    notifyStateChanged();
    // Schedule push notification for when this phase ends
    scheduleNotification(secondsLeft, phase);
  }

  function pauseTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    showPlayIcon();
    cancelScheduledNotification();
    // Accumulate partial work time
    if (phase === 'work') {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
      totalPhaseSeconds = secondsLeft; // remaining becomes new total for progress tracking
    }
    // Restore page title
    document.title = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    updateDisplay();
    saveStateImmediate();
    notifyStateChanged();
  }

  function resetTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    cancelScheduledNotification();
    // If resetting during work, accumulate partial work time
    if (phase === 'work' && totalPhaseSeconds > secondsLeft) {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
    }
    phase = 'work';
    secondsLeft = WORK_SECONDS;
    totalPhaseSeconds = WORK_SECONDS;
    showPlayIcon();
    updateDisplay();
    saveStateImmediate();
    notifyStateChanged();
  }

  function skipPhase() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    cancelScheduledNotification();

    if (phase === 'work') {
      // Accumulate partial work time
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);

      // If this was the last session, auto-stop or auto-advance
      if (totalSessions > 1 && sessionCount >= totalSessions) {
        updateDisplay();
        if (activeParentId && activeParentId !== activeTodoId) {
          advanceToNextSubtask();
        } else {
          closeTimer();
        }
        return;
      }

      // Single-session subtask: advance to next
      if (totalSessions <= 1 && activeParentId && activeParentId !== activeTodoId) {
        advanceToNextSubtask();
        return;
      }

      // Move to break
      phase = 'break';
      secondsLeft = BREAK_SECONDS;
      totalPhaseSeconds = BREAK_SECONDS;
    } else {
      // Move to next work session
      sessionCount++;
      phase = 'work';
      secondsLeft = WORK_SECONDS;
      totalPhaseSeconds = WORK_SECONDS;
    }
    showPlayIcon();
    updateDisplay();
    saveStateImmediate();
    notifyStateChanged();
  }

  // ── Auto-advance: find next undone sibling subtask ──
  function getNextUndoneSubtask(currentTodoId) {
    if (!activeParentId || !window.dmSync || !window.dmSync.getAllTodos) {
      return Promise.resolve(null);
    }
    return window.dmSync.getAllTodos().then(function(todos) {
      var subs = (todos || []).filter(function(t) {
        return t.parentId === activeParentId && t.status !== 'deleted' && t.status !== 'archived';
      });
      // Sort by order
      subs.sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
      // Find the index of the current subtask
      var currentIdx = -1;
      for (var i = 0; i < subs.length; i++) {
        if (subs[i].id === currentTodoId) { currentIdx = i; break; }
      }
      // Look for the next undone subtask after the current one
      for (var j = currentIdx + 1; j < subs.length; j++) {
        if (!subs[j].done && subs[j].id !== currentTodoId) return subs[j];
      }
      // Wrap around: check undone subtasks before the current one
      for (var k = 0; k < currentIdx; k++) {
        if (!subs[k].done && subs[k].id !== currentTodoId) return subs[k];
      }
      return null;
    });
  }

  // ── Auto-advance: transition to the next subtask ──
  // Records tracked time for the completed subtask, marks it done,
  // then sets up the timer for the next subtask (paused, waiting for user).
  function advanceToNextSubtask() {
    var completedTodoId = activeTodoId;
    var trackedMinutes = Math.round(accumulatedWorkSeconds / 60);

    // Save tracked time for the completed subtask
    if (completedTodoId && trackedMinutes > 0) {
      saveTrackedMinutes(completedTodoId, trackedMinutes);
      window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
        detail: { todoId: completedTodoId, trackedMinutes: trackedMinutes }
      }));
    }

    // Auto-mark the completed subtask as done
    if (completedTodoId && window.dmSync && window.dmSync.getTodo) {
      window.dmSync.getTodo(completedTodoId).then(function(todo) {
        if (todo && !todo.done) {
          toggleSubtaskDone(todo, true);
        }
      });
    }

    // Find and advance to the next undone subtask
    getNextUndoneSubtask(completedTodoId).then(function(nextSub) {
      if (!nextSub) {
        // No more undone subtasks — close timer
        // Reset accumulatedWorkSeconds since we already recorded above
        accumulatedWorkSeconds = 0;
        closeTimer();
        return;
      }

      // Transition to the next subtask
      activeTodoId = nextSub.id;
      activeTodoTitle = nextSub.title || 'Task';
      titleEl.textContent = activeTodoTitle;
      focusTitleEl.textContent = activeTodoTitle;

      // Load next subtask's pomodoro config (reset to defaults first)
      WORK_SECONDS = 25 * 60;
      BREAK_SECONDS = 5 * 60;
      totalSessions = 1;
      if (nextSub.pomodoroLength && nextSub.pomodoroLength > 0) {
        WORK_SECONDS = nextSub.pomodoroLength * 60;
      }
      if (nextSub.breakLength && nextSub.breakLength > 0) {
        BREAK_SECONDS = nextSub.breakLength * 60;
      } else {
        // Fall back to global short-break default
        try { var v = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (v > 0) BREAK_SECONDS = v * 60; } catch(e) {}
      }
      if (nextSub.pomodoroCount && nextSub.pomodoroCount > 0) {
        totalSessions = nextSub.pomodoroCount;
      }

      // Reset timer state for the new subtask
      phase = 'work';
      secondsLeft = WORK_SECONDS;
      totalPhaseSeconds = WORK_SECONDS;
      sessionCount = 1;
      accumulatedWorkSeconds = 0;
      isRunning = false;
      showPlayIcon();

      // Refresh subtask list to show updated done states
      loadSubtasks(activeParentId);
      updateDisplay();
      saveStateImmediate();
      notifyStateChanged();
    });
  }

  function closeTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    cancelScheduledNotification();

    // Accumulate any remaining partial work
    if (phase === 'work' && totalPhaseSeconds > secondsLeft) {
      accumulatedWorkSeconds += (totalPhaseSeconds - secondsLeft);
    }

    timerEl.style.display = 'none';
    categoryEl.style.display = 'none';
    categoryEl.textContent = '';
    showPlayIcon();
    clearInfoAndSubtasks();
    // Hide focus overlay if open
    focusOverlay.style.display = 'none';
    isFocusMode = false;
    vizStop();

    // Restore page title
    var cleanTitle = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    document.title = cleanTitle;

    var trackedMinutes = Math.round(accumulatedWorkSeconds / 60);
    var closedTodoId = activeTodoId;
    activeTodoId = null;
    activeTodoTitle = '';
    activeTodoCategory = '';
    activeParentId = null;

    // Clear persisted timer state
    clearState();

    // Notify the todo list about tracked time
    if (closedTodoId && trackedMinutes > 0) {
      // Persist tracked minutes to localStorage so they survive navigation
      saveTrackedMinutes(closedTodoId, trackedMinutes);
      window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
        detail: { todoId: closedTodoId, trackedMinutes: trackedMinutes }
      }));
    } else {
      // Even if no time tracked, notify so inline indicators update
      notifyStateChanged();
    }
  }

  function cancelTimer() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    isRunning = false;
    cancelScheduledNotification();
    timerEl.style.display = 'none';
    categoryEl.style.display = 'none';
    categoryEl.textContent = '';
    clearInfoAndSubtasks();
    showPlayIcon();
    // Hide focus overlay if open
    focusOverlay.style.display = 'none';
    isFocusMode = false;
    vizStop();

    // Restore page title
    var cleanTitle = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
    document.title = cleanTitle;

    activeTodoId = null;
    activeTodoTitle = '';
    activeTodoCategory = '';
    activeParentId = null;
    // Clear persisted timer state
    clearState();
    // No event fired — time is discarded
    notifyStateChanged();
  }

  // ── Button handlers ──
  toggleBtn.addEventListener('click', function() {
    if (isRunning) {
      pauseTimer();
    } else {
      startTimer();
    }
  });

  resetBtn.addEventListener('click', resetTimer);
  skipBtn.addEventListener('click', skipPhase);

  // Stop button: confirm and record tracked time
  stopBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      var trackedSoFar = accumulatedWorkSeconds;
      if (phase === 'work') trackedSoFar += (totalPhaseSeconds - secondsLeft);
      var mins = Math.round(trackedSoFar / 60);
      if (mins > 0 && !confirm('Stop timer? ' + mins + ' minute' + (mins !== 1 ? 's' : '') + ' of work will be recorded.')) {
        return;
      }
    }
    closeTimer();
  });

  // Close (x) button: cancel without recording time
  closeBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      if (!confirm('Cancel timer? Tracked time will be discarded.')) {
        return;
      }
    }
    cancelTimer();
  });

  // ── Focus overlay helpers ──

  // Render session timeline blocks
  function renderSessionTimeline() {
    if (totalSessions <= 1) {
      focusTimelineEl.style.display = 'none';
      return;
    }
    focusTimelineEl.style.display = '';
    var html = '';
    for (var i = 1; i <= totalSessions; i++) {
      var cls = 'pomodoro-focus-timeline-block';
      if (i < sessionCount) {
        cls += ' completed';
      } else if (i === sessionCount) {
        cls += ' current';
      } else {
        cls += ' remaining';
      }
      html += '<div class="' + cls + '">' + i + '</div>';
      // Add break separator between sessions (not after last)
      if (i < totalSessions) {
        var breakCls = 'pomodoro-focus-timeline-block break-block';
        if (i < sessionCount) breakCls += ' completed';
        html += '<div class="' + breakCls + '"></div>';
      }
    }
    focusTimelineBlocksEl.innerHTML = html;
  }

  // Render task details panel from todo object
  function renderTaskDetails(todo) {
    if (!todo) {
      focusDetailsGridEl.innerHTML = '<div style="font-size:0.72rem;color:var(--gray-400);">No details available</div>';
      return;
    }
    var rows = [];
    // Estimated duration
    if (todo.estimatedMin && todo.estimatedMin > 0) {
      var estText = todo.estimatedMin >= 60
        ? Math.floor(todo.estimatedMin / 60) + 'h ' + (todo.estimatedMin % 60) + 'm'
        : todo.estimatedMin + 'm';
      rows.push({ label: 'Estimated', value: estText });
    }
    // Actual tracked
    if (todo.actualMin && todo.actualMin > 0) {
      var actText = todo.actualMin >= 60
        ? Math.floor(todo.actualMin / 60) + 'h ' + (todo.actualMin % 60) + 'm'
        : todo.actualMin + 'm';
      rows.push({ label: 'Tracked', value: actText });
    }
    // Pomodoro config
    var pomoLen = todo.pomodoroLength || Math.round(WORK_SECONDS / 60);
    var breakLen = todo.breakLength || Math.round(BREAK_SECONDS / 60);
    rows.push({ label: 'Work / Break', value: pomoLen + 'm / ' + breakLen + 'm' });
    if (totalSessions > 1) {
      rows.push({ label: 'Sessions', value: sessionCount + ' / ' + totalSessions });
    }
    // Scheduled date
    if (todo.scheduledDate) {
      var d = todo.scheduledDate;
      var today = new Date();
      var todayStr = today.getFullYear() + '-' + padTime(today.getMonth() + 1) + '-' + padTime(today.getDate());
      rows.push({ label: 'Scheduled', value: d === todayStr ? 'Today' : d });
    }
    // Category
    if (todo.category) {
      rows.push({ label: 'Category', value: todo.category });
    }
    // BuJo type
    if (todo.bujoType && todo.bujoType !== 'task') {
      rows.push({ label: 'Type', value: todo.bujoType.charAt(0).toUpperCase() + todo.bujoType.slice(1) });
    }

    var html = '';
    rows.forEach(function(r) {
      html += '<div class="pomodoro-focus-detail-row">'
        + '<span class="pomodoro-focus-detail-label">' + r.label + '</span>'
        + '<span class="pomodoro-focus-detail-value">' + r.value + '</span>'
        + '</div>';
    });
    focusDetailsGridEl.innerHTML = html || '<div style="font-size:0.72rem;color:var(--gray-400);">No details</div>';
  }

  // Compute and render today's stats
  function renderTodayStats() {
    if (!window.dmSync || !window.dmSync.getAllTodos) {
      focusStatsGridEl.innerHTML = '';
      return;
    }
    window.dmSync.getAllTodos().then(function(todos) {
      var today = new Date();
      var todayStr = today.getFullYear() + '-' + padTime(today.getMonth() + 1) + '-' + padTime(today.getDate());
      var todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();

      var completedToday = 0;
      var totalTrackedMin = 0;
      var totalEstMin = 0;
      var activeCount = 0;

      todos.forEach(function(t) {
        // Only top-level tasks (not subtasks)
        if (t.parentId) return;
        // Completed today
        if (t.done && t.completedAt && t.completedAt >= todayStart) {
          completedToday++;
        }
        // Active tasks scheduled today or with no date
        if (t.status === 'active' && (t.scheduledDate === todayStr || !t.scheduledDate)) {
          activeCount++;
        }
        // Tracked time from actual minutes — completed today
        if (t.actualMin && t.actualMin > 0 && t.completedAt && t.completedAt >= todayStart) {
          totalTrackedMin += t.actualMin;
        }
        // Estimated minutes for today's active tasks
        if (t.status === 'active' && t.scheduledDate === todayStr && t.estimatedMin) {
          totalEstMin += t.estimatedMin;
        }
      });

      // Add current session tracked time
      if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
        var currentSec = accumulatedWorkSeconds;
        if (phase === 'work') currentSec += (totalPhaseSeconds - secondsLeft);
        totalTrackedMin += Math.round(currentSec / 60);
      }

      // Also check localStorage tracked data
      try {
        var tracked = JSON.parse(localStorage.getItem(TRACKED_KEY) || '{}');
        for (var tid in tracked) {
          if (tracked.hasOwnProperty(tid)) {
            // Only add if we haven't already counted via actualMin
            // (tracked data is for current/recent sessions not yet saved to actualMin)
          }
        }
      } catch(e) {}

      var formatMin = function(m) {
        if (m >= 60) return Math.floor(m / 60) + 'h ' + (m % 60) + 'm';
        return m + 'm';
      };

      var html = '<div class="pomodoro-focus-stat-card">'
        + '<div class="pomodoro-focus-stat-value">' + completedToday + '</div>'
        + '<div class="pomodoro-focus-stat-label">Done</div></div>'
        + '<div class="pomodoro-focus-stat-card">'
        + '<div class="pomodoro-focus-stat-value">' + activeCount + '</div>'
        + '<div class="pomodoro-focus-stat-label">Active</div></div>'
        + '<div class="pomodoro-focus-stat-card">'
        + '<div class="pomodoro-focus-stat-value">' + formatMin(totalTrackedMin) + '</div>'
        + '<div class="pomodoro-focus-stat-label">Tracked</div></div>'
        + '<div class="pomodoro-focus-stat-card">'
        + '<div class="pomodoro-focus-stat-value">' + formatMin(totalEstMin) + '</div>'
        + '<div class="pomodoro-focus-stat-label">Planned</div></div>';
      focusStatsGridEl.innerHTML = html;
    }).catch(function() {
      focusStatsGridEl.innerHTML = '';
    });
  }

  // ── Ambient Visualizer ──
  var vizMode = 'aurora'; // 'aurora' | 'wave'
  var vizAnimId = null;
  var vizTime = 0;

  // Aurora / particles state
  var vizOrbs = [];
  var vizOrbCount = 12;

  // Wave state
  var vizWavePoints = [];
  var vizWaveCount = 64;

  // Color palette: muted blues, purples, teals
  var vizPalette = [
    { r: 60, g: 100, b: 200 },   // soft blue
    { r: 120, g: 70, b: 180 },   // muted purple
    { r: 50, g: 160, b: 180 },   // teal
    { r: 140, g: 90, b: 200 },   // lavender
    { r: 70, g: 130, b: 210 },   // sky
    { r: 100, g: 60, b: 160 },   // deep purple
  ];

  function vizPickColor() {
    return vizPalette[Math.floor(Math.random() * vizPalette.length)];
  }

  function vizInitOrbs() {
    vizOrbs = [];
    for (var i = 0; i < vizOrbCount; i++) {
      var c = vizPickColor();
      vizOrbs.push({
        x: Math.random(),           // 0-1 normalized position
        y: Math.random(),
        r: 0.15 + Math.random() * 0.25, // radius as fraction of min(w,h)
        vx: (Math.random() - 0.5) * 0.0004,
        vy: (Math.random() - 0.5) * 0.0003,
        phase: Math.random() * Math.PI * 2,
        pulseSpeed: 0.3 + Math.random() * 0.6,
        cr: c.r, cg: c.g, cb: c.b,
        alpha: 0.06 + Math.random() * 0.08
      });
    }
  }

  function vizInitWave() {
    vizWavePoints = [];
    for (var i = 0; i < vizWaveCount; i++) {
      vizWavePoints.push({
        phase: Math.random() * Math.PI * 2,
        freq: 0.5 + Math.random() * 2.5,
        amp: 0.1 + Math.random() * 0.35
      });
    }
  }

  // Render aurora: soft overlapping radial gradients drifting slowly
  function vizDrawAurora(ctx, w, h) {
    // Fade previous frame instead of clearing — leaves soft trails
    ctx.fillStyle = 'rgba(10, 10, 20, 0.12)';
    ctx.fillRect(0, 0, w, h);

    var minDim = Math.min(w, h);

    for (var i = 0; i < vizOrbCount; i++) {
      var orb = vizOrbs[i];

      // Drift
      orb.x += orb.vx;
      orb.y += orb.vy;

      // Soft bounce off edges with margin
      if (orb.x < -0.2 || orb.x > 1.2) orb.vx *= -1;
      if (orb.y < -0.2 || orb.y > 1.2) orb.vy *= -1;

      // Gentle random drift changes
      orb.vx += (Math.random() - 0.5) * 0.00003;
      orb.vy += (Math.random() - 0.5) * 0.00003;
      // Clamp velocity
      var maxV = 0.0008;
      orb.vx = Math.max(-maxV, Math.min(maxV, orb.vx));
      orb.vy = Math.max(-maxV, Math.min(maxV, orb.vy));

      // Pulsing radius
      var pulse = 0.85 + 0.15 * Math.sin(vizTime * orb.pulseSpeed + orb.phase);
      var radius = orb.r * minDim * pulse;

      var cx = orb.x * w;
      var cy = orb.y * h;

      // Radial gradient: colored center fading to transparent
      var grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      grad.addColorStop(0, 'rgba(' + orb.cr + ',' + orb.cg + ',' + orb.cb + ',' + (orb.alpha * pulse) + ')');
      grad.addColorStop(0.4, 'rgba(' + orb.cr + ',' + orb.cg + ',' + orb.cb + ',' + (orb.alpha * 0.5 * pulse) + ')');
      grad.addColorStop(1, 'rgba(' + orb.cr + ',' + orb.cg + ',' + orb.cb + ',0)');

      ctx.fillStyle = grad;
      ctx.fillRect(cx - radius, cy - radius, radius * 2, radius * 2);
    }
  }

  // Render waveform / oscilloscope — soft neon lines
  function vizDrawWave(ctx, w, h) {
    // Soft fade for trailing effect
    ctx.fillStyle = 'rgba(10, 10, 20, 0.15)';
    ctx.fillRect(0, 0, w, h);

    var midY = h * 0.5;
    var t = vizTime;

    var layers = [
      { freqMul: 1, ampMul: 1, alpha: 0.55, lineW: 2, colorIdx: 0 },
      { freqMul: 1.5, ampMul: 0.5, alpha: 0.3, lineW: 1.5, colorIdx: 1 },
      { freqMul: 0.7, ampMul: 0.7, alpha: 0.2, lineW: 1, colorIdx: 2 }
    ];

    layers.forEach(function(layer) {
      var c = vizPalette[layer.colorIdx];
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + layer.alpha + ')';
      ctx.lineWidth = layer.lineW;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      for (var x = 0; x <= w; x += 2) {
        var y = midY;
        for (var j = 0; j < vizWaveCount; j++) {
          var wp = vizWavePoints[j];
          var xNorm = x / w;
          y += Math.sin(xNorm * wp.freq * 6 * layer.freqMul + t * wp.freq * 0.6 + wp.phase)
               * wp.amp * h * 0.35 * layer.ampMul;
        }
        y = midY + (y - midY) / Math.sqrt(vizWaveCount * 0.6);

        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Subtle glow
      ctx.save();
      ctx.shadowColor = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.35)';
      ctx.shadowBlur = 8;
      ctx.stroke();
      ctx.restore();
    });

    // Slowly evolve wave parameters
    for (var j = 0; j < vizWaveCount; j++) {
      vizWavePoints[j].phase += (Math.random() - 0.5) * 0.012;
      vizWavePoints[j].amp += (Math.random() - 0.5) * 0.003;
      vizWavePoints[j].amp = Math.max(0.05, Math.min(0.4, vizWavePoints[j].amp));
    }
  }

  // Main animation frame
  function vizAnimate() {
    if (!isFocusMode) { vizAnimId = null; return; }

    var rect = focusVizContainer.getBoundingClientRect();
    var dpr = window.devicePixelRatio || 1;
    var w = Math.round(rect.width * dpr);
    var h = Math.round(rect.height * dpr);

    if (focusVizCanvas.width !== w || focusVizCanvas.height !== h) {
      focusVizCanvas.width = w;
      focusVizCanvas.height = h;
      // Fill with dark background on resize to avoid flash
      var ctx2 = focusVizCanvas.getContext('2d');
      ctx2.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx2.fillStyle = '#0a0a14';
      ctx2.fillRect(0, 0, rect.width, rect.height);
    }

    var ctx = focusVizCanvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    var cw = rect.width;
    var ch = rect.height;

    vizTime += 0.016;

    if (vizMode === 'aurora') {
      vizDrawAurora(ctx, cw, ch);
    } else {
      vizDrawWave(ctx, cw, ch);
    }

    vizAnimId = requestAnimationFrame(vizAnimate);
  }

  function vizStart() {
    if (vizAnimId) return;
    vizInitOrbs();
    vizInitWave();
    // Clear canvas to dark
    if (focusVizCanvas && focusVizContainer) {
      var rect = focusVizContainer.getBoundingClientRect();
      var dpr = window.devicePixelRatio || 1;
      focusVizCanvas.width = Math.round(rect.width * dpr);
      focusVizCanvas.height = Math.round(rect.height * dpr);
      var ctx = focusVizCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = '#0a0a14';
      ctx.fillRect(0, 0, rect.width, rect.height);
    }
    vizAnimate();
  }

  function vizStop() {
    if (vizAnimId) {
      cancelAnimationFrame(vizAnimId);
      vizAnimId = null;
    }
  }

  // Toggle visualizer mode
  if (focusVizToggle) {
    focusVizToggle.addEventListener('click', function() {
      vizMode = vizMode === 'aurora' ? 'wave' : 'aurora';
      // Clear canvas on mode switch for clean transition
      if (focusVizCanvas && focusVizContainer) {
        var rect = focusVizContainer.getBoundingClientRect();
        var dpr = window.devicePixelRatio || 1;
        var ctx = focusVizCanvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 0, rect.width, rect.height);
      }
    });
  }

  function enterFocusMode() {
    isFocusMode = true;
    // Sync current title/category to focus elements
    focusTitleEl.textContent = activeTodoTitle;
    if (activeTodoCategory) {
      focusCategoryEl.textContent = activeTodoCategory;
      focusCategoryEl.style.display = '';
    } else {
      focusCategoryEl.style.display = 'none';
    }
    timerEl.style.display = 'none';
    focusOverlay.style.display = '';

    // Render new panels
    renderSessionTimeline();

    // Start visualizer
    vizStart();

    // Load task details from IDB
    if (window.dmSync && window.dmSync.getTodo && activeTodoId) {
      window.dmSync.getTodo(activeTodoId).then(function(todo) {
        renderTaskDetails(todo);
      }).catch(function() { renderTaskDetails(null); });
    } else {
      renderTaskDetails(null);
    }

    // Load today's stats
    renderTodayStats();

    updateDisplay();
  }

  function exitFocusMode() {
    isFocusMode = false;
    focusOverlay.style.display = 'none';
    timerEl.style.display = '';
    vizStop();
  }

  // ── Focus overlay button handlers ──
  expandBtn.addEventListener('click', function() {
    if (!activeTodoId) return;
    enterFocusMode();
  });

  collapseBtn.addEventListener('click', exitFocusMode);

  // Focus overlay controls delegate to existing handlers
  focusToggleBtn.addEventListener('click', function() {
    if (isRunning) {
      pauseTimer();
    } else {
      startTimer();
    }
  });

  focusResetBtn.addEventListener('click', resetTimer);
  focusSkipBtn.addEventListener('click', skipPhase);

  focusStopBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      var trackedSoFar = accumulatedWorkSeconds;
      if (phase === 'work') trackedSoFar += (totalPhaseSeconds - secondsLeft);
      var mins = Math.round(trackedSoFar / 60);
      if (mins > 0 && !confirm('Stop timer? ' + mins + ' minute' + (mins !== 1 ? 's' : '') + ' of work will be recorded.')) {
        return;
      }
    }
    closeTimer();
  });

  focusCloseBtn.addEventListener('click', function() {
    if (accumulatedWorkSeconds > 0 || (phase === 'work' && totalPhaseSeconds > secondsLeft)) {
      if (!confirm('Cancel timer? Tracked time will be discarded.')) {
        return;
      }
    }
    cancelTimer();
  });

  // Backdrop click → collapse back to compact
  focusOverlay.querySelector('.pomodoro-focus-backdrop').addEventListener('click', function() {
    exitFocusMode();
  });

  // Escape key → collapse focus mode
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && isFocusMode) {
      e.preventDefault();
      e.stopPropagation();
      exitFocusMode();
    }
  });

  // ── Drag / move support ──
  var isDragging = false;
  var dragOffsetX = 0;
  var dragOffsetY = 0;
  var posRight = 24;  // initial CSS right
  var posBottom = 100; // initial CSS bottom
  var hasCustomPos = false;

  function onDragStart(e) {
    // Only drag from header area (not buttons)
    if (e.target.closest('button')) return;
    isDragging = true;
    var rect = timerEl.getBoundingClientRect();
    var clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
    var clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    timerEl.style.transition = 'none';
    timerEl.style.cursor = 'grabbing';
    e.preventDefault();
  }

  function onDragMove(e) {
    if (!isDragging) return;
    var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
    var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
    var newLeft = clientX - dragOffsetX;
    var newTop = clientY - dragOffsetY;
    // Clamp within viewport
    var rect = timerEl.getBoundingClientRect();
    var maxLeft = window.innerWidth - rect.width;
    var maxTop = window.innerHeight - rect.height;
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    // Switch from right/bottom to left/top positioning
    timerEl.style.right = 'auto';
    timerEl.style.bottom = 'auto';
    timerEl.style.left = newLeft + 'px';
    timerEl.style.top = newTop + 'px';
    hasCustomPos = true;
    e.preventDefault();
  }

  function onDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    timerEl.style.transition = '';
    timerEl.style.cursor = '';
  }

  // Attach drag listeners to the header
  var headerEl = timerEl.querySelector('.pomodoro-timer-header');
  headerEl.style.cursor = 'grab';
  headerEl.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);
  headerEl.addEventListener('touchstart', onDragStart, { passive: false });
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);

  function resetPosition() {
    timerEl.style.left = '';
    timerEl.style.top = '';
    timerEl.style.right = '';
    timerEl.style.bottom = '';
    hasCustomPos = false;
  }

  // ── Subtask loading for pomodoro popup ──
  function renderSubtasksInto(container, subs, parentId) {
    container.innerHTML = '';
    var doneCount = subs.filter(function(s) { return s.done; }).length;
    var totalCount = subs.length;
    var pct = Math.round((doneCount / totalCount) * 100);

    // Progress header
    var headerDiv = document.createElement('div');
    headerDiv.className = 'pomo-subtask-header';
    headerDiv.innerHTML = '<span>Subtasks ' + doneCount + '/' + totalCount + '</span>'
      + '<div class="pomo-subtask-progress-bar"><div class="pomo-subtask-progress-fill" style="width:' + pct + '%"></div></div>';
    container.appendChild(headerDiv);

    // Subtask rows
    subs.forEach(function(sub) {
      var row = document.createElement('div');
      var isActive = sub.id === activeTodoId;
      row.className = 'pomodoro-subtask-item' + (sub.done ? ' done' : '') + (isActive ? ' active' : '');
      var checkSvg = '<svg width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
      var estPill = sub.estimatedMin ? '<span class="pomo-subtask-est">' + sub.estimatedMin + 'm</span>' : '';
      row.innerHTML = '<span class="pomo-subtask-checkbox">' + checkSvg + '</span>'
        + '<label>' + escapeHtmlPomo(sub.title) + '</label>'
        + estPill;
      row.addEventListener('click', function() {
        var newDone = !sub.done;
        sub.done = newDone;
        toggleSubtaskDone(sub, newDone);
        // Recompute subtask remaining time
        loadSubtasks(parentId);
      });
      container.appendChild(row);
    });
    container.style.display = '';
  }

  function loadSubtasks(parentId) {
    if (!parentId) {
      subtasksEl.style.display = 'none';
      focusSubtasksEl.style.display = 'none';
      return;
    }
    if (!window.dmSync || !window.dmSync.getAllTodos) return;
    window.dmSync.getAllTodos().then(function(todos) {
      if (activeParentId !== parentId) {
        console.log('[pomo] loadSubtasks stale (activeParentId=' + activeParentId + ', parentId=' + parentId + ')');
        return;
      }
      var subs = (todos || []).filter(function(t) { return t.parentId === parentId && t.status !== 'deleted' && t.status !== 'archived'; });
      console.log('[pomo] loadSubtasks parentId=' + parentId + ' found ' + subs.length + ' subtasks (total todos: ' + (todos || []).length + ')');

      // Compute total estimated minutes of uncompleted subtasks for finish-at
      subtaskRemainingMin = 0;
      subs.forEach(function(sub) {
        if (!sub.done && sub.estimatedMin && sub.estimatedMin > 0) {
          subtaskRemainingMin += sub.estimatedMin;
        }
      });

      if (subs.length === 0) {
        subtasksEl.style.display = 'none';
        focusSubtasksEl.style.display = 'none';
        updateDisplay();
        return;
      }
      // Sort: active first, done last; within each group preserve order
      subs.sort(function(a, b) {
        if (a.done !== b.done) return a.done ? 1 : -1;
        return (a.order || 0) - (b.order || 0);
      });

      // Render into both compact and focus containers
      renderSubtasksInto(subtasksEl, subs, parentId);
      renderSubtasksInto(focusSubtasksEl, subs, parentId);
      updateDisplay();
    }).catch(function() {});
  }

  function escapeHtmlPomo(s) {
    var d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  function toggleSubtaskDone(sub, newDone) {
    sub.done = newDone;
    sub.status = newDone ? 'done' : 'active';
    sub.updatedAt = Date.now();
    if (newDone) sub.completedAt = Date.now();
    else sub.completedAt = null;

    if (window.dmSync) {
      var updateData = {
        done: newDone,
        status: newDone ? 'done' : 'active',
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (newDone) updateData.completedAt = firebase.firestore.FieldValue.serverTimestamp();
      else updateData.completedAt = null;

      window.dmSync.firestoreWrite({
        collection: 'todos',
        docId: sub.id,
        op: 'update',
        data: updateData,
        localOp: function() { return window.dmSync.putTodo(sub); }
      }).then(function() {
        // Notify todo list to re-render
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      }).catch(function(err) {
        console.error('Error toggling subtask:', err);
      });
    }
  }

  function clearInfoAndSubtasks() {
    startedAt = null;
    subtaskRemainingMin = 0;
    infoEl.style.display = 'none';
    subtasksEl.innerHTML = '';
    subtasksEl.style.display = 'none';
    focusInfoEl.style.display = 'none';
    focusSubtasksEl.innerHTML = '';
    focusSubtasksEl.style.display = 'none';
    // Clear focus panels
    focusTimelineEl.style.display = 'none';
    focusTimelineBlocksEl.innerHTML = '';
    focusDetailsGridEl.innerHTML = '';
    focusStatsGridEl.innerHTML = '';
  }

  // ── Restore persisted timer state on page load ──
  function restoreState() {
    var raw;
    try { raw = localStorage.getItem(STATE_KEY); } catch(e) { return; }
    if (!raw) return;
    var s;
    try { s = JSON.parse(raw); } catch(e) { clearState(); return; }
    if (!s || !s.activeTodoId || !s.savedAt) { clearState(); return; }

    // Calculate elapsed time since state was saved
    var elapsedMs = Date.now() - s.savedAt;
    if (elapsedMs < 0) { clearState(); return; } // clock skew, discard
    var elapsedSec = Math.floor(elapsedMs / 1000);

    // Restore config
    WORK_SECONDS = s.WORK_SECONDS || 25 * 60;
    BREAK_SECONDS = s.BREAK_SECONDS || 5 * 60;
    activeTodoId = s.activeTodoId;
    activeTodoTitle = s.activeTodoTitle || 'Task';
    activeTodoCategory = s.activeTodoCategory || '';
    activeParentId = s.activeParentId || s.activeTodoId;
    totalSessions = s.totalSessions || 1;
    startedAt = s.startedAt;

    // Restore mutable state
    var rPhase = s.phase || 'work';
    var rSecondsLeft = s.secondsLeft || 0;
    var rTotalPhase = s.totalPhaseSeconds || WORK_SECONDS;
    var rSessionCount = s.sessionCount || 1;
    var rAccWork = s.accumulatedWorkSeconds || 0;
    var wasRunning = s.isRunning;

    // If timer was running, simulate elapsed time
    if (wasRunning && elapsedSec > 0) {
      var result = simulateElapsed(rPhase, rSecondsLeft, rTotalPhase, rSessionCount, rAccWork, elapsedSec);
      if (result.finished) {
        // Timer completed entirely during navigation
        var completedId = activeTodoId;
        var completedParentId = activeParentId;
        var trackedMinutes = Math.round(result.accWork / 60);
        clearState();
        if (trackedMinutes > 0) {
          saveTrackedMinutes(completedId, trackedMinutes);
          window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
            detail: { todoId: completedId, trackedMinutes: trackedMinutes }
          }));
        }
        // If timing a subtask, try to auto-advance to the next one
        if (completedParentId && completedParentId !== completedId) {
          // Auto-mark completed subtask as done
          if (window.dmSync && window.dmSync.getTodo) {
            window.dmSync.getTodo(completedId).then(function(todo) {
              if (todo && !todo.done) toggleSubtaskDone(todo, true);
            });
          }
          // Find next subtask and show timer paused on it
          getNextUndoneSubtask(completedId).then(function(nextSub) {
            if (!nextSub) {
              // No more subtasks — stay closed
              activeTodoId = null;
              activeTodoTitle = '';
              activeTodoCategory = '';
              activeParentId = null;
              return;
            }
            // Set up timer for next subtask (paused, waiting for user)
            activeTodoId = nextSub.id;
            activeTodoTitle = nextSub.title || 'Task';
            activeParentId = completedParentId;
            activeTodoCategory = nextSub.category || '';
            titleEl.textContent = activeTodoTitle;
            focusTitleEl.textContent = activeTodoTitle;
            if (activeTodoCategory) {
              categoryEl.textContent = activeTodoCategory;
              categoryEl.style.display = '';
              focusCategoryEl.textContent = activeTodoCategory;
              focusCategoryEl.style.display = '';
            }
            // Load config from next subtask
            WORK_SECONDS = (nextSub.pomodoroLength && nextSub.pomodoroLength > 0) ? nextSub.pomodoroLength * 60 : 25 * 60;
            if (nextSub.breakLength && nextSub.breakLength > 0) {
              BREAK_SECONDS = nextSub.breakLength * 60;
            } else {
              BREAK_SECONDS = 5 * 60;
              try { var bv = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (bv > 0) BREAK_SECONDS = bv * 60; } catch(e) {}
            }
            totalSessions = (nextSub.pomodoroCount && nextSub.pomodoroCount > 0) ? nextSub.pomodoroCount : 1;
            phase = 'work';
            secondsLeft = WORK_SECONDS;
            totalPhaseSeconds = WORK_SECONDS;
            sessionCount = 1;
            accumulatedWorkSeconds = 0;
            isRunning = false;
            startedAt = Date.now();
            showPlayIcon();
            updateDisplay();
            resetPosition();
            timerEl.style.display = '';
            loadSubtasks(activeParentId);
            saveStateImmediate();
            notifyStateChanged();
          });
          return;
        }
        activeTodoId = null;
        activeTodoTitle = '';
        activeTodoCategory = '';
        activeParentId = null;
        return;
      }
      rPhase = result.phase;
      rSecondsLeft = result.secondsLeft;
      rTotalPhase = result.totalPhase;
      rSessionCount = result.sessionCount;
      rAccWork = result.accWork;
    }

    // Apply restored state
    phase = rPhase;
    secondsLeft = rSecondsLeft;
    totalPhaseSeconds = rTotalPhase;
    sessionCount = rSessionCount;
    accumulatedWorkSeconds = rAccWork;

    // Update UI
    titleEl.textContent = activeTodoTitle;
    focusTitleEl.textContent = activeTodoTitle;
    if (activeTodoCategory) {
      categoryEl.textContent = activeTodoCategory;
      categoryEl.style.display = '';
      focusCategoryEl.textContent = activeTodoCategory;
      focusCategoryEl.style.display = '';
    }
    updateDisplay();
    resetPosition();
    timerEl.style.display = '';

    // Load subtasks
    loadSubtasks(activeParentId);

    // Resume or show paused state
    if (wasRunning) {
      startTimer();
    } else {
      showPlayIcon();
      saveState();
    }
  }

  /**
   * Simulate elapsed seconds across phase transitions.
   * Returns { phase, secondsLeft, totalPhase, sessionCount, accWork, finished }
   */
  function simulateElapsed(curPhase, curSecondsLeft, curTotalPhase, curSession, curAccWork, elapsed) {
    var remaining = elapsed;

    while (remaining > 0) {
      if (remaining >= curSecondsLeft) {
        // Phase completed during navigation
        remaining -= curSecondsLeft;

        if (curPhase === 'work') {
          curAccWork += curSecondsLeft; // work seconds remaining = work done to finish phase

          // Check if all sessions are done
          if (totalSessions > 1 && curSession >= totalSessions) {
            return { finished: true, accWork: curAccWork };
          }

          // Switch to break (auto-started)
          curPhase = 'break';
          curSecondsLeft = BREAK_SECONDS;
          curTotalPhase = BREAK_SECONDS;
        } else {
          // Break finished — next work session does NOT auto-start
          curSession++;
          curPhase = 'work';
          curSecondsLeft = WORK_SECONDS;
          curTotalPhase = WORK_SECONDS;
          // Break → work transition doesn't auto-start, so stop consuming time
          break;
        }
      } else {
        // Elapsed time consumed within current phase
        if (curPhase === 'work') {
          // Track partial work done during elapsed time
          curAccWork += remaining;
          // Adjust totalPhase so progress bar is accurate
          curTotalPhase = curSecondsLeft; // total = what was left before elapsed
        }
        curSecondsLeft -= remaining;
        remaining = 0;
      }
    }

    return {
      finished: false,
      phase: curPhase,
      secondsLeft: curSecondsLeft,
      totalPhase: curTotalPhase,
      sessionCount: curSession,
      accWork: curAccWork
    };
  }

  // Restore on page load (localStorage first — fast, same device)
  restoreState();

  // ── Cross-device restore: if no local timer running, check Firestore ──
  function applyRemoteState(s) {
    if (!s || !s.activeTodoId || !s.savedAt) return false;

    // Calculate elapsed time since the remote state was saved
    var elapsedMs = Date.now() - s.savedAt;
    if (elapsedMs < 0) return false; // clock skew
    // Discard states older than 4 hours (likely stale/abandoned)
    if (elapsedMs > 4 * 60 * 60 * 1000) return false;
    var elapsedSec = Math.floor(elapsedMs / 1000);

    // Restore config
    WORK_SECONDS = s.WORK_SECONDS || 25 * 60;
    BREAK_SECONDS = s.BREAK_SECONDS || 5 * 60;
    activeTodoId = s.activeTodoId;
    activeTodoTitle = s.activeTodoTitle || 'Task';
    activeTodoCategory = s.activeTodoCategory || '';
    activeParentId = s.activeParentId || s.activeTodoId;
    totalSessions = s.totalSessions || 1;
    startedAt = s.startedAt;

    var rPhase = s.phase || 'work';
    var rSecondsLeft = s.secondsLeft || 0;
    var rTotalPhase = s.totalPhaseSeconds || WORK_SECONDS;
    var rSessionCount = s.sessionCount || 1;
    var rAccWork = s.accumulatedWorkSeconds || 0;
    var wasRunning = s.isRunning;

    // Simulate elapsed time if timer was running
    if (wasRunning && elapsedSec > 0) {
      var result = simulateElapsed(rPhase, rSecondsLeft, rTotalPhase, rSessionCount, rAccWork, elapsedSec);
      if (result.finished) {
        // Timer finished while on the other device — don't restore
        var trackedMinutes = Math.round(result.accWork / 60);
        if (trackedMinutes > 0) {
          saveTrackedMinutes(activeTodoId, trackedMinutes);
          window.dispatchEvent(new CustomEvent('dm-pomodoro-stopped', {
            detail: { todoId: activeTodoId, trackedMinutes: trackedMinutes }
          }));
        }
        activeTodoId = null;
        activeTodoTitle = '';
        activeTodoCategory = '';
        activeParentId = null;
        clearStateFromFirestore();
        return false;
      }
      rPhase = result.phase;
      rSecondsLeft = result.secondsLeft;
      rTotalPhase = result.totalPhase;
      rSessionCount = result.sessionCount;
      rAccWork = result.accWork;
    }

    // Apply state
    phase = rPhase;
    secondsLeft = rSecondsLeft;
    totalPhaseSeconds = rTotalPhase;
    sessionCount = rSessionCount;
    accumulatedWorkSeconds = rAccWork;

    // Update UI
    titleEl.textContent = activeTodoTitle;
    focusTitleEl.textContent = activeTodoTitle;
    if (activeTodoCategory) {
      categoryEl.textContent = activeTodoCategory;
      categoryEl.style.display = '';
      focusCategoryEl.textContent = activeTodoCategory;
      focusCategoryEl.style.display = '';
    }
    updateDisplay();
    resetPosition();
    timerEl.style.display = '';
    loadSubtasks(activeParentId);

    if (wasRunning) {
      startTimer();
    } else {
      showPlayIcon();
      saveState(); // persist locally too
    }
    return true;
  }

  // Try Firestore restore if no local state was found
  function tryRemoteRestore() {
    if (activeTodoId) return; // Already restored from localStorage
    var ref = _getTimerDocRef();
    if (!ref) return;
    ref.get().then(function(doc) {
      if (!doc.exists || activeTodoId) return; // Timer already active or no remote state
      _fsSyncing = true;
      applyRemoteState(doc.data());
      _fsSyncing = false;
    }).catch(function(err) {
      console.warn('[pomo-sync] Remote restore failed:', err.message);
    });
  }

  // Start real-time listener for cross-device timer updates
  function startFirestoreListener() {
    var ref = _getTimerDocRef();
    if (!ref) return;
    if (_fsUnsubscribe) { _fsUnsubscribe(); _fsUnsubscribe = null; }

    _fsUnsubscribe = ref.onSnapshot(function(doc) {
      if (!doc.exists) {
        // Remote timer was closed/cancelled — close local timer too
        if (activeTodoId && !_fsSyncing) {
          _fsSyncing = true;
          // Close timer locally without writing back to Firestore
          if (intervalId) { clearInterval(intervalId); intervalId = null; }
          isRunning = false;
          cancelScheduledNotification();
          timerEl.style.display = 'none';
          categoryEl.style.display = 'none';
          focusOverlay.style.display = 'none';
          isFocusMode = false;
          vizStop();
          document.title = document.title.replace(/^\d{2}:\d{2} \u2014 (Work|Break) \| /, '');
          clearInfoAndSubtasks();
          activeTodoId = null;
          activeTodoTitle = '';
          activeTodoCategory = '';
          activeParentId = null;
          try { localStorage.removeItem(STATE_KEY); } catch(e) {}
          notifyStateChanged();
          _fsSyncing = false;
        }
        return;
      }

      var data = doc.data();
      if (!data) return;

      // Ignore our own writes
      if (data.deviceId === _deviceId) return;

      // Ignore if the remote state is older than our last write
      if (data.savedAt && data.savedAt <= _lastFsSavedAt) return;

      _fsSyncing = true;

      // If we have a running timer for a different todo, close ours
      if (activeTodoId && data.activeTodoId && activeTodoId !== data.activeTodoId) {
        if (intervalId) { clearInterval(intervalId); intervalId = null; }
        isRunning = false;
        cancelScheduledNotification();
        timerEl.style.display = 'none';
        clearInfoAndSubtasks();
      }

      // Apply the remote state
      applyRemoteState(data);
      _fsSyncing = false;
    }, function(err) {
      console.warn('[pomo-sync] Snapshot listener error:', err.message);
    });
  }

  // Initialize cross-device sync after auth is ready
  if (window.dmAuthReady) {
    window.dmAuthReady.then(function(user) {
      if (!user) return;
      tryRemoteRestore();
      startFirestoreListener();
    });
  }

  // ── Notify todo list to re-render inline timer indicators ──
  function notifyStateChanged() {
    window.dispatchEvent(new CustomEvent('dm-pomodoro-state-changed', {
      detail: { todoId: activeTodoId, isRunning: isRunning }
    }));
  }

  // ── Listen for external todo updates (e.g., subtask toggled in todo list) ──
  window.addEventListener('dm-todos-updated', function() {
    if (activeParentId) {
      loadSubtasks(activeParentId);
    }
  });

  // ── Re-schedule notification when app is backgrounded / foregrounded ──
  document.addEventListener('visibilitychange', function() {
    if (!activeTodoId || !isRunning) return;
    if (document.hidden) {
      // Going to background — ensure service worker has the notification scheduled
      scheduleNotification(secondsLeft, phase);
    }
    // When returning to foreground, the in-page setInterval keeps running,
    // so no action needed — the next tick() will reconcile state.
  });

  // ── Public API ──
  window.dmPomodoro = {
    start: function(todoId, todoTitle) {
      // If a different todo is already being timed, close it first
      if (activeTodoId && activeTodoId !== todoId) {
        closeTimer();
      }
      activeTodoId = todoId;
      activeTodoTitle = todoTitle || 'Task';
      activeTodoCategory = '';
      titleEl.textContent = activeTodoTitle;
      focusTitleEl.textContent = activeTodoTitle;

      // Look up category and pomodoro config from IndexedDB
      categoryEl.style.display = 'none';
      categoryEl.textContent = '';
      focusCategoryEl.style.display = 'none';
      focusCategoryEl.textContent = '';

      // Set defaults
      WORK_SECONDS = 25 * 60;
      BREAK_SECONDS = 5 * 60;
      totalSessions = 1;

      function initAndStart() {
        phase = 'work';
        secondsLeft = WORK_SECONDS;
        totalPhaseSeconds = WORK_SECONDS;
        sessionCount = 1;
        accumulatedWorkSeconds = 0;
        startedAt = Date.now();
        isRunning = false;
        showPlayIcon();
        updateDisplay();
        resetPosition();
        timerEl.style.display = '';
        // Request notification permission on first timer start (needs user gesture)
        requestNotificationPermission();
        startTimer();
      }

      // Clear subtasks from previous run
      subtasksEl.innerHTML = '';
      subtasksEl.style.display = 'none';
      focusSubtasksEl.innerHTML = '';
      focusSubtasksEl.style.display = 'none';
      // Clear focus panels from previous run
      focusTimelineEl.style.display = 'none';
      focusTimelineBlocksEl.innerHTML = '';
      focusDetailsGridEl.innerHTML = '';
      focusStatsGridEl.innerHTML = '';

      if (window.dmSync && window.dmSync.getTodo) {
        window.dmSync.getTodo(todoId).then(function(todo) {
          if (todo && activeTodoId === todoId) {
            if (todo.category) {
              categoryEl.textContent = todo.category;
              categoryEl.style.display = '';
              focusCategoryEl.textContent = todo.category;
              focusCategoryEl.style.display = '';
              activeTodoCategory = todo.category;
            }
            if (todo.pomodoroLength && todo.pomodoroLength > 0) {
              WORK_SECONDS = todo.pomodoroLength * 60;
            }
            if (todo.breakLength && todo.breakLength > 0) {
              BREAK_SECONDS = todo.breakLength * 60;
            } else {
              // Fall back to global short-break default
              try { var v = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (v > 0) BREAK_SECONDS = v * 60; } catch(e) {}
            }
            if (todo.pomodoroCount && todo.pomodoroCount > 0) {
              totalSessions = todo.pomodoroCount;
            }
            // Determine parent context: if this is a subtask, show siblings from the parent
            if (todo.parentId) {
              activeParentId = todo.parentId;
              console.log('[pomo] Timing subtask "' + todoTitle + '" (parentId=' + todo.parentId + ')');
            } else {
              activeParentId = todoId;
              console.log('[pomo] Timing parent "' + todoTitle + '" (id=' + todoId + ')');
            }
          } else {
            activeParentId = todoId;
          }
          initAndStart();
          // Load subtasks AFTER timer is visible so user sees them appear
          loadSubtasks(activeParentId);
        }).catch(function(err) {
          console.error('[pomo] getTodo error:', err);
          activeParentId = todoId;
          initAndStart();
        });
      } else {
        activeParentId = todoId;
        initAndStart();
      }
    },
    stop: closeTimer,
    pause: pauseTimer,
    resume: startTimer,
    togglePause: function() {
      if (isRunning) {
        pauseTimer();
      } else if (activeTodoId) {
        startTimer();
      }
    },
    isActive: function(todoId) {
      return activeTodoId === todoId;
    },
    isTimerRunning: function() {
      return isRunning;
    },
    getActiveTodoId: function() {
      return activeTodoId;
    },
    getSessionInfo: function() {
      return { current: sessionCount, total: totalSessions };
    },
    getStartedAt: function() {
      return startedAt;
    }
  };
})();
</script>
