<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="{{ default .Summary .Description }}">
<meta name="theme-color" content="#161921">
<meta name="color-scheme" content="light dark">

{{- with .Page.Params.BookHref -}}
  <meta http-equiv="Refresh" content="0; url='{{ . }}'" />
{{- end -}}

{{- template "_internal/opengraph.html" . -}}

<title>{{ partial "docs/html-head-title" . }}</title>

{{- $manifest := resources.Get "manifest.json" | resources.ExecuteAsTemplate "manifest.json" . }}
<link rel="manifest" href="{{ $manifest.RelPermalink }}">
<link rel="icon" href="{{ "favicon.png" | relURL }}" type="image/x-icon">

{{- range .Translations }}
  <link rel="alternate" hreflang="{{ default .Language.Lang .Site.LanguageCode }}" href="{{ .Permalink }}" title="{{ partial "docs/title" . }}">
{{- end -}}

<!-- Theme stylesheet -->
{{- $styles := resources.Get "book.scss" | resources.ExecuteAsTemplate "book.scss" . | resources.ToCSS | resources.Minify | resources.Fingerprint }}
<link rel="stylesheet" href="{{ $styles.RelPermalink }}" {{ template "integrity" $styles }}>

{{- if default true .Site.Params.BookSearch -}}
  {{- $searchJSFile := printf "%s.search.js" .Language.Lang }}
  {{- $searchJS := resources.Get "search.js" | resources.ExecuteAsTemplate $searchJSFile . | resources.Minify | resources.Fingerprint }}
  <script defer src="{{ "flexsearch.min.js" | relURL }}"></script>
  <script defer src="{{ $searchJS.RelPermalink }}" {{ template "integrity" $searchJS }}></script>
{{ end -}}

{{- if .Site.Params.BookServiceWorker -}}
  {{- $swJS := resources.Get "sw-register.js" | resources.ExecuteAsTemplate "sw.js" . | resources.Minify | resources.Fingerprint }}
  <script defer src="{{ $swJS.RelPermalink }}" {{ template "integrity" $swJS }}></script>
{{ end -}}

{{- if in .RawContent "{{< graph >}}" -}}
  {{- $graphJS := resources.Get "js/graph.js" | resources.ExecuteAsTemplate "js/graph.js" . | resources.Minify | resources.Fingerprint }}
  <script defer src="{{ "js/vendor/d3.min.js" | relURL }}"></script>
  <script defer src="{{ $graphJS.RelPermalink }}" {{ template "integrity" $graphJS }}></script>
{{ end -}}

{{- template "_internal/google_analytics.html" . -}}

<!-- Firebase SDK (Auth + Firestore) -->
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>

<!-- Markdown renderer + Syntax highlighting (client-side) -->
<script src="https://cdn.jsdelivr.net/npm/marked@15.0.7/marked.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/github-dark.min.css" media="(prefers-color-scheme: dark)">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/github.min.css" media="(prefers-color-scheme: light)">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>

<!-- Configure marked.js to match Hugo's heading rendering -->
<script>
(function() {
  if (typeof marked === 'undefined') return;

  var renderer = new marked.Renderer();

  // Match Hugo's render-heading.html: add id + anchor link
  renderer.heading = function(data) {
    var text = data.text || '';
    var depth = data.depth || 1;
    var slug = text.toLowerCase()
      .replace(/<[^>]+>/g, '')
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    return '<h' + depth + ' id="' + slug + '">\n  ' +
      text + '\n  <a class="anchor" href="#' + slug + '">#</a>\n' +
      '</h' + depth + '>\n';
  };

  // --- Diagram support ---
  // Diagram languages rendered client-side
  var MERMAID_LANG = 'mermaid';
  // Diagram languages rendered via Kroki API
  var KROKI_LANGS = ['plantuml', 'd2', 'graphviz', 'ditaa', 'erd', 'nomnoml', 'svgbob', 'excalidraw', 'c4plantuml', 'dbml'];

  // Override code renderer to detect diagram fences and emit placeholders
  var originalCode = renderer.code ? renderer.code.bind(renderer) : null;
  renderer.code = function(data) {
    var lang = (data.lang || '').toLowerCase().trim();
    var text = data.text || '';
    if (lang === MERMAID_LANG || KROKI_LANGS.indexOf(lang) !== -1) {
      // Emit a placeholder div instead of <pre><code>
      // Use base64 to safely embed source in data attribute
      var encoded = btoa(unescape(encodeURIComponent(text)));
      return '<div class="dm-diagram" data-type="' + lang + '" data-source="' + encoded + '">' +
        '<div class="dm-diagram-loading">Loading ' + lang + ' diagram\u2026</div>' +
        '</div>';
    }
    // Fall back to default rendering
    if (originalCode) return originalCode(data);
    return '<pre><code class="language-' + lang + '">' + text.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</code></pre>';
  };

  marked.setOptions({
    renderer: renderer,
    gfm: true,
    breaks: false
  });

  // Mermaid lazy-loader
  var mermaidReady = null; // Promise, set once
  function loadMermaid() {
    if (mermaidReady) return mermaidReady;
    mermaidReady = new Promise(function(resolve, reject) {
      if (typeof mermaid !== 'undefined') {
        mermaid.initialize({
          startOnLoad: false,
          flowchart: { useMaxWidth: true },
          theme: 'dark',
          themeVariables: {
            darkMode: true,
            background: '#161921',
            primaryColor: '#1e3a5f',
            primaryTextColor: '#e1e4e8',
            primaryBorderColor: '#64b5f6',
            lineColor: '#4a5568',
            secondaryColor: '#1a2332',
            tertiaryColor: '#1e222d'
          }
        });
        resolve();
        return;
      }
      var script = document.createElement('script');
      script.src = (document.querySelector('link[rel="manifest"]')
        ? document.querySelector('link[rel="manifest"]').getAttribute('href').replace('/manifest.json', '')
        : '') + '/mermaid.min.js';
      script.onload = function() {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({
            startOnLoad: false,
            flowchart: { useMaxWidth: true },
            theme: 'dark',
            themeVariables: {
              darkMode: true,
              background: '#161921',
              primaryColor: '#1e3a5f',
              primaryTextColor: '#e1e4e8',
              primaryBorderColor: '#64b5f6',
              lineColor: '#4a5568',
              secondaryColor: '#1a2332',
              tertiaryColor: '#1e222d'
            }
          });
        }
        resolve();
      };
      script.onerror = function() { reject(new Error('Failed to load mermaid.js')); };
      document.head.appendChild(script);
    });
    return mermaidReady;
  }

  // Render a Kroki diagram via POST
  function renderKroki(el, type, source) {
    // Map language aliases to Kroki diagram types
    var krokiType = type;
    if (type === 'c4plantuml') krokiType = 'c4plantuml';
    if (type === 'graphviz') krokiType = 'graphviz';

    fetch('https://kroki.io/' + krokiType + '/svg', {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain' },
      body: source
    }).then(function(res) {
      if (!res.ok) throw new Error('Kroki returned ' + res.status);
      return res.text();
    }).then(function(svg) {
      el.innerHTML = svg;
      el.classList.add('dm-diagram-rendered');

      // Make SVG responsive: remove fixed width/height so it scales via viewBox
      var svgEl = el.querySelector('svg');
      if (svgEl) {
        svgEl.removeAttribute('width');
        svgEl.removeAttribute('height');
        // Remove inline width/height from style attribute
        var inlineStyle = svgEl.getAttribute('style') || '';
        inlineStyle = inlineStyle
          .replace(/width:\s*[^;]+;?/gi, '')
          .replace(/height:\s*[^;]+;?/gi, '');
        if (inlineStyle.trim()) {
          svgEl.setAttribute('style', inlineStyle);
        } else {
          svgEl.removeAttribute('style');
        }
        // Ensure viewBox is present for proper scaling
        if (!svgEl.getAttribute('viewBox')) {
          var w = svgEl.getBBox ? svgEl.getBBox().width : 800;
          var h = svgEl.getBBox ? svgEl.getBBox().height : 600;
          svgEl.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
        }
      }
    }).catch(function(err) {
      console.error('Kroki render error (' + type + '):', err);
      el.innerHTML = '<div class="dm-diagram-error">Failed to render ' + type + ' diagram</div>' +
        '<pre><code>' + source.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</code></pre>';
    });
  }

  /**
   * Scan a container for .dm-diagram placeholders and render them.
   * Call this after marked.parse() + hljs highlighting.
   *
   * @param {Element} containerEl — the rendered content container
   */
  window.dmRenderDiagrams = function(containerEl) {
    if (!containerEl) return;
    var diagrams = containerEl.querySelectorAll('.dm-diagram');
    if (!diagrams.length) return;

    var hasMermaid = false;
    var krokiDiagrams = [];

    diagrams.forEach(function(el) {
      var type = el.getAttribute('data-type');
      var encoded = el.getAttribute('data-source');
      if (!type || !encoded) return;
      var source = decodeURIComponent(escape(atob(encoded)));
      if (type === MERMAID_LANG) {
        hasMermaid = true;
        // Set up for mermaid.run()
        el.classList.add('mermaid');
        el.textContent = source;
        el.removeAttribute('data-source');
      } else {
        krokiDiagrams.push({ el: el, type: type, source: source });
      }
    });

    // Render Mermaid diagrams
    if (hasMermaid) {
      loadMermaid().then(function() {
        if (typeof mermaid !== 'undefined') {
          // mermaid v10+ uses mermaid.run(), v9 uses mermaid.init()
          var nodes = containerEl.querySelectorAll('.mermaid');
          if (mermaid.run) {
            mermaid.run({ nodes: nodes });
          } else if (mermaid.init) {
            mermaid.init(undefined, nodes);
          }
        }
      }).catch(function(err) {
        console.error('Mermaid load error:', err);
      });
    }

    // Render Kroki diagrams
    krokiDiagrams.forEach(function(d) {
      renderKroki(d.el, d.type, d.source);
    });
  };

  // --- Diagram Lightbox (pan + zoom) ---
  // The white card (.dm-lightbox-svg-wrap) stays fixed in the center.
  // The SVG content pans and zooms INSIDE it via an inner container
  // (.dm-lightbox-inner) that receives the CSS transform.
  //
  // Zoom-toward-point math: when zooming, the point under the cursor
  // (or pinch center) stays fixed. This uses transform-origin: 0 0
  // with manual translate/scale, adjusting translate on each zoom so
  // the cursor-relative point doesn't shift.
  (function() {
    var overlay, svgWrap, innerWrap, currentTransform;
    var MIN_SCALE = 0.3, MAX_SCALE = 10;
    var WHEEL_FACTOR = 1.12;   // multiplicative: each wheel tick = 12% zoom
    var BUTTON_FACTOR = 1.35;  // +/- buttons: 35% per click

    function createOverlay() {
      if (overlay) return;
      overlay = document.createElement('div');
      overlay.className = 'dm-lightbox';
      overlay.innerHTML =
        '<div class="dm-lightbox-toolbar">' +
          '<button class="dm-lightbox-btn" data-action="zoom-in" title="Zoom in (+)">+</button>' +
          '<span class="dm-lightbox-zoom-label">100%</span>' +
          '<button class="dm-lightbox-btn" data-action="zoom-out" title="Zoom out (&minus;)">&minus;</button>' +
          '<button class="dm-lightbox-btn" data-action="fit" title="Fit to view">Fit</button>' +
          '<button class="dm-lightbox-btn dm-lightbox-close" data-action="close" title="Close (Esc)">&times;</button>' +
        '</div>' +
        '<div class="dm-lightbox-canvas">' +
          '<div class="dm-lightbox-svg-wrap">' +
            '<div class="dm-lightbox-inner"></div>' +
          '</div>' +
        '</div>';
      document.body.appendChild(overlay);

      svgWrap = overlay.querySelector('.dm-lightbox-svg-wrap');
      innerWrap = overlay.querySelector('.dm-lightbox-inner');
      var canvas = overlay.querySelector('.dm-lightbox-canvas');

      // -- Button actions --
      overlay.querySelector('.dm-lightbox-toolbar').addEventListener('click', function(e) {
        var btn = e.target.closest('[data-action]');
        if (!btn) return;
        var action = btn.getAttribute('data-action');
        if (action === 'close') closeLightbox();
        else if (action === 'zoom-in') zoomAtCenter(BUTTON_FACTOR);
        else if (action === 'zoom-out') zoomAtCenter(1 / BUTTON_FACTOR);
        else if (action === 'fit') fitToView();
      });

      // -- Keyboard shortcuts --
      document.addEventListener('keydown', function(e) {
        if (!overlay || !overlay.classList.contains('dm-lightbox-open')) return;
        if (e.key === 'Escape') closeLightbox();
        else if (e.key === '+' || e.key === '=') zoomAtCenter(BUTTON_FACTOR);
        else if (e.key === '-' || e.key === '_') zoomAtCenter(1 / BUTTON_FACTOR);
        else if (e.key === '0') fitToView();
      });

      // -- Close on backdrop click --
      canvas.addEventListener('click', function(e) {
        if (e.target === canvas) closeLightbox();
      });

      // -- Mouse wheel zoom toward cursor --
      svgWrap.addEventListener('wheel', function(e) {
        e.preventDefault();
        var factor = e.deltaY < 0 ? WHEEL_FACTOR : (1 / WHEEL_FACTOR);
        // Get cursor position relative to the svg-wrap
        var rect = svgWrap.getBoundingClientRect();
        var px = e.clientX - rect.left;
        var py = e.clientY - rect.top;
        zoomAtPoint(factor, px, py);
      }, { passive: false });

      // -- Pan with mouse drag --
      var dragging = false, startX, startY, startTx, startTy;

      svgWrap.addEventListener('mousedown', function(e) {
        if (e.button !== 0) return;
        dragging = true;
        startX = e.clientX; startY = e.clientY;
        startTx = currentTransform.x; startTy = currentTransform.y;
        svgWrap.classList.add('dm-lightbox-dragging');
        e.preventDefault();
      });

      document.addEventListener('mousemove', function(e) {
        if (!dragging) return;
        currentTransform.x = startTx + (e.clientX - startX);
        currentTransform.y = startTy + (e.clientY - startY);
        applyTransform();
      });

      document.addEventListener('mouseup', function() {
        if (dragging) {
          dragging = false;
          svgWrap.classList.remove('dm-lightbox-dragging');
        }
      });

      // -- Touch: pinch-to-zoom toward center + single-finger pan --
      var lastTouchDist = 0, lastTouchCx = 0, lastTouchCy = 0;

      svgWrap.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
          lastTouchDist = touchDist(e.touches);
          var c = touchCenter(e.touches);
          var rect = svgWrap.getBoundingClientRect();
          lastTouchCx = c.x - rect.left;
          lastTouchCy = c.y - rect.top;
          e.preventDefault();
        } else if (e.touches.length === 1) {
          dragging = true;
          startX = e.touches[0].clientX; startY = e.touches[0].clientY;
          startTx = currentTransform.x; startTy = currentTransform.y;
        }
      }, { passive: false });

      svgWrap.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2 && lastTouchDist) {
          e.preventDefault();
          var newDist = touchDist(e.touches);
          var factor = newDist / lastTouchDist;
          var c = touchCenter(e.touches);
          var rect = svgWrap.getBoundingClientRect();
          var cx = c.x - rect.left;
          var cy = c.y - rect.top;
          zoomAtPoint(factor, cx, cy);
          lastTouchDist = newDist;
          lastTouchCx = cx;
          lastTouchCy = cy;
        } else if (e.touches.length === 1 && dragging) {
          currentTransform.x = startTx + (e.touches[0].clientX - startX);
          currentTransform.y = startTy + (e.touches[0].clientY - startY);
          applyTransform();
        }
      }, { passive: false });

      svgWrap.addEventListener('touchend', function() {
        dragging = false;
        lastTouchDist = 0;
      });

      // -- Double-click to zoom in at point --
      svgWrap.addEventListener('dblclick', function(e) {
        var rect = svgWrap.getBoundingClientRect();
        var px = e.clientX - rect.left;
        var py = e.clientY - rect.top;
        zoomAtPoint(BUTTON_FACTOR, px, py);
        e.preventDefault();
      });
    }

    function touchDist(touches) {
      var dx = touches[0].clientX - touches[1].clientX;
      var dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function touchCenter(touches) {
      return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
      };
    }

    function clampScale(s) {
      return Math.max(MIN_SCALE, Math.min(MAX_SCALE, s));
    }

    /**
     * Zoom toward a specific point (px, py) in svg-wrap coordinates.
     * The point under (px, py) stays fixed after the zoom.
     *
     * Math: before zoom, the content point at (px, py) in wrap space maps to
     *   contentX = (px - tx) / oldScale
     *   contentY = (py - ty) / oldScale
     * After zoom, we want the same content point to stay at (px, py):
     *   px = newTx + contentX * newScale
     * Solving: newTx = px - contentX * newScale
     *        = px - ((px - tx) / oldScale) * newScale
     */
    function zoomAtPoint(factor, px, py) {
      var oldScale = currentTransform.scale;
      var newScale = clampScale(oldScale * factor);
      if (newScale === oldScale) return;

      var ratio = newScale / oldScale;
      currentTransform.x = px - (px - currentTransform.x) * ratio;
      currentTransform.y = py - (py - currentTransform.y) * ratio;
      currentTransform.scale = newScale;
      applyTransform();
    }

    /** Zoom at the center of the viewport (for +/- buttons and keyboard) */
    function zoomAtCenter(factor) {
      if (!svgWrap) return;
      var rect = svgWrap.getBoundingClientRect();
      zoomAtPoint(factor, rect.width / 2, rect.height / 2);
    }

    /** Fit the diagram to fill the viewport */
    function fitToView() {
      currentTransform = { x: 0, y: 0, scale: 1 };
      applyTransform();
    }

    function applyTransform() {
      innerWrap.style.transform = 'translate(' + currentTransform.x + 'px, ' + currentTransform.y + 'px) scale(' + currentTransform.scale + ')';
      var label = overlay.querySelector('.dm-lightbox-zoom-label');
      if (label) label.textContent = Math.round(currentTransform.scale * 100) + '%';
    }

    function openLightbox(svgHtml) {
      createOverlay();
      innerWrap.innerHTML = svgHtml;
      // Remove fixed dimensions from the SVG so it scales via viewBox
      var svgEl = innerWrap.querySelector('svg');
      if (svgEl) {
        var origW = parseFloat(svgEl.getAttribute('width')) || 0;
        var origH = parseFloat(svgEl.getAttribute('height')) || 0;
        svgEl.removeAttribute('width');
        svgEl.removeAttribute('height');
        var s = svgEl.getAttribute('style') || '';
        var styleW = s.match(/width:\s*([\d.]+)/i);
        var styleH = s.match(/height:\s*([\d.]+)/i);
        if (!origW && styleW) origW = parseFloat(styleW[1]);
        if (!origH && styleH) origH = parseFloat(styleH[1]);
        s = s.replace(/width:\s*[^;]+;?/gi, '').replace(/height:\s*[^;]+;?/gi, '');
        if (s.trim()) svgEl.setAttribute('style', s); else svgEl.removeAttribute('style');
        if (!svgEl.getAttribute('viewBox')) {
          var w = origW || (svgEl.getBBox ? svgEl.getBBox().width : 800) || 800;
          var h = origH || (svgEl.getBBox ? svgEl.getBBox().height : 600) || 600;
          svgEl.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
        }
      }
      currentTransform = { x: 0, y: 0, scale: 1 };
      applyTransform();
      overlay.classList.add('dm-lightbox-open');
      document.body.style.overflow = 'hidden';
    }

    function closeLightbox() {
      if (!overlay) return;
      overlay.classList.remove('dm-lightbox-open');
      document.body.style.overflow = '';
      innerWrap.innerHTML = '';
    }

    // Expose globally
    window.dmDiagramLightbox = { open: openLightbox, close: closeLightbox };

    // Delegate click on rendered diagrams
    document.addEventListener('click', function(e) {
      var diagram = e.target.closest('.dm-diagram-rendered');
      if (!diagram) {
        diagram = e.target.closest('.dm-diagram');
        if (!diagram || !diagram.querySelector('svg')) return;
      }
      var svg = diagram.querySelector('svg');
      if (svg) openLightbox(svg.outerHTML);
    });
  })();

  /**
   * Enable interactive checkboxes in rendered markdown.
   * Removes `disabled` from task list checkboxes and wires up click handlers
   * that toggle `- [ ]` / `- [x]` in the raw note content, then persist.
   *
   * @param {Element} bodyEl — container with rendered HTML
   * @param {Object}  note   — note object with .id and .content
   * @param {Function} onUpdate(updatedNote) — called after successful save
   */
  window.dmEnableCheckboxes = function(bodyEl, note, onUpdate) {
    if (!bodyEl || !note) return;
    var checkboxes = bodyEl.querySelectorAll('li > input[type="checkbox"][disabled]');
    if (!checkboxes.length) return;

    checkboxes.forEach(function(cb, idx) {
      cb.removeAttribute('disabled');
      cb.style.cursor = 'pointer';

      cb.addEventListener('change', function() {
        var raw = note.content || '';
        var cbIndex = 0;
        var newContent = raw.replace(/^([-*]\s+\[)([ xX])(\]\s+)/gm, function(match, pre, check, post) {
          if (cbIndex === idx) {
            cbIndex++;
            return pre + (check === ' ' ? 'x' : ' ') + post;
          }
          cbIndex++;
          return match;
        });

        if (newContent === raw) return; // nothing changed

        note.content = newContent;
        note.updatedAt = Date.now();

        // Persist to Firestore + IndexedDB
        if (window.dmDb && window.dmSync) {
          window.dmDb.collection('notes').doc(note.id).update({
            content: newContent,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }).then(function() {
            return window.dmSync.putNote(note);
          }).then(function() {
            if (onUpdate) onUpdate(note);
          }).catch(function(err) {
            console.error('Checkbox save error:', err);
            // Revert the checkbox visually
            cb.checked = !cb.checked;
          });
        }
      });
    });
  };
})();
</script>

<!-- RSS -->
{{- with .OutputFormats.Get "rss" -}}
  {{ printf `<link rel="%s" type="%s" href="%s" title="%s" />` .Rel .MediaType.Type .Permalink $.Site.Title | safeHTML }}
{{ end -}}

{{ "<!--" | safeHTML }}
Made with Book Theme
https://github.com/alex-shpak/hugo-book
{{ "-->" | safeHTML }}

{{- define "integrity" -}}
  {{- if (urls.Parse .Permalink).Host -}}
    integrity="{{ .Data.Integrity }}" crossorigin="anonymous"
  {{- end -}}
{{- end -}}
