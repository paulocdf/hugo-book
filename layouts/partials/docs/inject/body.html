<!-- Theme toggle button -->
<button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme" title="Toggle light/dark theme">
  <svg class="theme-icon theme-icon--sun" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="theme-icon theme-icon--moon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>

<script>
(function() {
  var toggle = document.getElementById('theme-toggle');
  if (!toggle) return;

  function getEffectiveTheme() {
    var saved = localStorage.getItem('dm-theme');
    if (saved === 'light' || saved === 'dark') return saved;
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }

  function applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('dm-theme', theme);
    updateMeta(theme);
  }

  function updateMeta(theme) {
    var meta = document.querySelector('meta[name="theme-color"]');
    if (meta) meta.setAttribute('content', theme === 'dark' ? '#161921' : '#ffffff');
    var cs = document.querySelector('meta[name="color-scheme"]');
    if (cs) cs.setAttribute('content', theme);
  }

  // Set initial state
  var current = getEffectiveTheme();
  document.documentElement.setAttribute('data-theme', current);
  updateMeta(current);

  toggle.addEventListener('click', function() {
    var now = getEffectiveTheme();
    var next = now === 'dark' ? 'light' : 'dark';
    applyTheme(next);
  });

  // Listen for OS theme changes (only if user hasn't overridden)
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
    if (!localStorage.getItem('dm-theme')) {
      var theme = e.matches ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', theme);
      updateMeta(theme);
    }
  });
})();
</script>

<!-- Sidebar collapse/expand toggle -->
<script>
(function() {
  var toggle = document.getElementById('sidebar-toggle');
  if (!toggle) return;

  function isCollapsed() {
    return document.documentElement.classList.contains('sidebar-collapsed');
  }

  function setSidebar(collapsed) {
    if (collapsed) {
      document.documentElement.classList.add('sidebar-collapsed');
      toggle.setAttribute('aria-label', 'Expand sidebar');
    } else {
      document.documentElement.classList.remove('sidebar-collapsed');
      toggle.setAttribute('aria-label', 'Collapse sidebar');
    }
    try { localStorage.setItem('dm-sidebar-collapsed', collapsed ? '1' : '0'); } catch(e) {}
  }

  toggle.addEventListener('click', function() {
    setSidebar(!isCollapsed());
  });

  // Keyboard shortcut: [ to toggle sidebar
  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
    if (e.key === '[' && !e.ctrlKey && !e.metaKey && !e.altKey) {
      e.preventDefault();
      setSidebar(!isCollapsed());
    }
  });
})();
</script>

<!-- Quick Capture FAB (Floating Action Button) -->
<button class="quick-capture-fab" id="quick-capture-btn" aria-label="Quick Capture (Q)" title="Quick Capture">
  <svg class="fab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 20h9"></path>
    <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
  </svg>
  <span class="fab-tooltip">Quick Capture <kbd>Q</kbd></span>
</button>

<!-- Export button (top-right, next to theme toggle) -->
<button class="export-toolbar-btn" id="export-toolbar-btn" aria-label="Export" title="Export">
  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <polyline points="7 10 12 15 17 10"></polyline>
    <line x1="12" y1="15" x2="12" y2="3"></line>
  </svg>
</button>

<script>
(function() {
  var exportToolbarBtn = document.getElementById('export-toolbar-btn');
  if (exportToolbarBtn) {
    exportToolbarBtn.addEventListener('click', function() {
      if (window.dmExport) window.dmExport.open();
    });
  }
})();
</script>

{{ partial "quick-capture-modal.html" . }}

{{ partial "note-edit-modal" . }}

{{ partial "version-history-modal" . }}

{{ partial "search-modal.html" . }}

{{ partial "todo-complete-modal.html" . }}

{{ partial "todo-edit-modal.html" . }}

{{ partial "pomodoro-timer.html" . }}

{{ partial "keyboard-shortcuts.html" . }}

{{ partial "ai-companion.html" . }}

{{ partial "export-modal.html" . }}

<!-- Quick Capture modal logic -->
<script>
(function() {
  var btn = document.getElementById('quick-capture-btn');
  var modal = document.getElementById('quick-capture-modal');
  if (!modal) return;

  var backdrop = document.getElementById('quick-capture-backdrop');
  var input = document.getElementById('quick-capture-input');
  var titleInput = document.getElementById('qc-title-input');
  var cancelBtn = document.getElementById('qc-cancel');
  var submitBtn = document.getElementById('qc-submit');
  var destButtons = document.querySelectorAll('.qc-dest-btn');
  var modeButtons = document.querySelectorAll('.qc-mode-btn');
  var langButtons = document.querySelectorAll('.qc-lang-btn');
  var destRow = document.getElementById('qc-destination-row');
  var langRow = document.getElementById('qc-language-row');
  var bookTitleRow = document.getElementById('qc-book-title-row');
  var bookTitleInput = document.getElementById('qc-book-title-input');
  var bookTitleDatalist = document.getElementById('qc-book-title-list');
  var inboxNewBtn = document.getElementById('qc-inbox-new-btn');
  var previewWrapper = document.getElementById('qc-preview-wrapper');
  var previewPanel = document.getElementById('qc-preview-panel');
  var notePreviewWrapper = document.getElementById('qc-note-preview-wrapper');
  var notePreviewPanel = document.getElementById('qc-note-preview-panel');
  var dialog = modal.querySelector('.quick-capture-dialog');
  var toolbar = document.getElementById('qc-toolbar');
  var toolbarButtons = toolbar ? toolbar.querySelectorAll('.qc-toolbar-btn') : [];

  // Auth elements
  var signinBtn = document.getElementById('qc-signin');
  var signoutBtn = document.getElementById('qc-signout');
  var authUserEl = document.getElementById('qc-auth-user');
  var authAvatarEl = document.getElementById('qc-auth-avatar');
  var authNameEl = document.getElementById('qc-auth-name');

  // Feedback elements
  var feedbackEl = document.getElementById('qc-feedback');
  var feedbackIconEl = document.getElementById('qc-feedback-icon');
  var feedbackTextEl = document.getElementById('qc-feedback-text');

  // Todo mode elements
  var todoFieldsEl = document.getElementById('qc-todo-fields');
  var todoTitleInput = document.getElementById('qc-todo-title');
  var todoEstimateInput = document.getElementById('qc-todo-estimate');
  var todoDateBtn = document.getElementById('qc-todo-date-btn');
  var todoDateChip = document.getElementById('qc-todo-date-chip');
  var todoDateChipText = document.getElementById('qc-todo-date-chip-text');
  var todoDateClear = document.getElementById('qc-todo-date-clear');
  var todoReminderBtn = document.getElementById('qc-todo-reminder-btn');
  var todoReminderChip = document.getElementById('qc-todo-reminder-chip');
  var todoReminderChipText = document.getElementById('qc-todo-reminder-chip-text');
  var todoReminderClear = document.getElementById('qc-todo-reminder-clear');

  // AI mode elements
  var qcAiContainer = document.getElementById('qc-ai-container');
  var qcAiMessages = document.getElementById('qc-ai-messages');
  var qcAiWelcome = document.getElementById('qc-ai-welcome');
  var qcAiInput = document.getElementById('qc-ai-input');
  var qcAiSendBtn = document.getElementById('qc-ai-send-btn');
  var qcAiStopBtn = document.getElementById('qc-ai-stop-btn');
  var qcAiQuickActions = document.getElementById('qc-ai-quick-actions');
  var qcAiStatusEl = document.getElementById('qc-ai-status');
  var qcAiStatusText = document.getElementById('qc-ai-status-text');
  var qcAiProgressFill = document.getElementById('qc-ai-progress-fill');
  var qcAiStatusDetail = document.getElementById('qc-ai-status-detail');
  var qcAiNotSupported = document.getElementById('qc-ai-not-supported');
  var qcAiModeBadge = document.getElementById('qc-ai-mode-badge');
  var qcAiModeBadgeText = document.getElementById('qc-ai-mode-badge-text');
  var qcAiModeBadgeCancel = document.getElementById('qc-ai-mode-badge-cancel');
  var qcAiMicBtn = document.getElementById('qc-ai-mic-btn');
  var qcAiInputArea = document.getElementById('qc-ai-input-area');
  var qcAiModeBtn = document.querySelector('.qc-mode-btn-ai');

  // State
  var currentMode = 'ai'; // 'ai', 'note', 'code', or 'todo'
  var selectedLang = 'kotlin';
  var inboxMode = 'append'; // 'append' or 'new'
  var selectedDest = {
    path: 'content/docs/inbox',
    tag: 'inbox'
  };
  var previewTimer = null;
  var isSaving = false;

  // Todo mode state
  var _qcTodoDate = null; // YYYY-MM-DD string
  var _qcTodoReminderMs = null; // timestamp in ms
  var _qcTodoPopover = null; // currently open popover element

  // =========================================================================
  // Firebase Auth
  // =========================================================================
  function updateAuthUI(user) {
    if (user) {
      signinBtn.style.display = 'none';
      authUserEl.style.display = '';
      authAvatarEl.src = user.photoURL || '';
      authAvatarEl.alt = user.displayName || '';
      authNameEl.textContent = user.displayName || user.email || '';
    } else {
      signinBtn.style.display = '';
      authUserEl.style.display = 'none';
    }
  }

  // Listen for auth state changes
  if (window.dmAuth) {
    function subscribeSidebarAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        updateAuthUI(user);
      });
    }
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeSidebarAuth);
    } else {
      subscribeSidebarAuth();
    }
  }

  if (signinBtn) {
    signinBtn.addEventListener('click', function() {
      window.dmSignIn();
    });
  }

  if (signoutBtn) {
    signoutBtn.addEventListener('click', function() {
      if (window.dmAuth) window.dmAuth.signOut();
    });
  }

  // =========================================================================
  // Feedback (success / error overlay)
  // =========================================================================
  function showFeedback(type, message) {
    if (!feedbackEl) return;
    feedbackEl.className = 'qc-feedback qc-feedback--' + type;
    feedbackEl.style.display = '';

    if (type === 'success') {
      feedbackIconEl.innerHTML = '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
    } else {
      feedbackIconEl.innerHTML = '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
    }
    feedbackTextEl.textContent = message;

    if (type === 'success') {
      setTimeout(function() {
        feedbackEl.style.display = 'none';
        closeModal();
      }, 1200);
    } else {
      setTimeout(function() {
        feedbackEl.style.display = 'none';
      }, 3000);
    }
  }

  // Slug helper: lowercase, replace non-alphanum with hyphens, collapse, trim
  function slugify(str) {
    return str.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 60);
  }

  // =========================================================================
  // Markdown formatting toolbar helpers
  // =========================================================================

  // Wrap selected text with before/after markers (bold, italic, code)
  function wrapSelection(before, after) {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;
    var selected = text.slice(start, end);

    // If no selection, insert markers with cursor between them
    if (start === end) {
      var inserted = before + after;
      input.value = text.slice(0, start) + inserted + text.slice(end);
      input.selectionStart = input.selectionEnd = start + before.length;
    } else {
      input.value = text.slice(0, start) + before + selected + after + text.slice(end);
      input.selectionStart = start + before.length;
      input.selectionEnd = end + before.length;
    }
    input.focus();
  }

  // Prefix each selected line (or current line) with a string
  function prefixLines(prefix) {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;

    // Find the start of the first selected line
    var lineStart = text.lastIndexOf('\n', start - 1) + 1;
    // Find the end of the last selected line
    var lineEnd = text.indexOf('\n', end);
    if (lineEnd === -1) lineEnd = text.length;

    var block = text.slice(lineStart, lineEnd);
    var lines = block.split('\n');
    var prefixed = lines.map(function(line) { return prefix + line; }).join('\n');

    input.value = text.slice(0, lineStart) + prefixed + text.slice(lineEnd);

    // Place cursor at end of modified block
    var newEnd = lineStart + prefixed.length;
    input.selectionStart = lineStart;
    input.selectionEnd = newEnd;
    input.focus();
  }

  // Insert link markdown: [text](url) or [](url) if no selection
  function insertLink() {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;
    var selected = text.slice(start, end);

    if (selected) {
      var inserted = '[' + selected + '](url)';
      input.value = text.slice(0, start) + inserted + text.slice(end);
      // Select "url" so user can type over it
      input.selectionStart = start + selected.length + 2;
      input.selectionEnd = start + selected.length + 5;
    } else {
      input.value = text.slice(0, start) + '[](url)' + text.slice(end);
      // Place cursor inside [] for link text
      input.selectionStart = input.selectionEnd = start + 1;
    }
    input.focus();
  }

  function applyFormat(format) {
    switch (format) {
      case 'bold':    wrapSelection('**', '**'); break;
      case 'italic':  wrapSelection('*', '*'); break;
      case 'code':    wrapSelection('`', '`'); break;
      case 'heading': prefixLines('## '); break;
      case 'bullet':  prefixLines('- '); break;
      case 'todo':    prefixLines('- [ ] '); break;
      case 'link':    insertLink(); break;
    }
  }

  // Toolbar button click handlers
  toolbarButtons.forEach(function(tbtn) {
    tbtn.addEventListener('click', function(e) {
      e.preventDefault();
      var format = tbtn.getAttribute('data-format');
      applyFormat(format);
      scheduleNotePreview();
    });
  });

  // =========================================================================
  // Mini Markdown → HTML renderer for Note mode preview
  // Supports: headings, bold, italic, inline code, links, bullets, todos,
  //           paragraphs, and blank-line separation.
  // =========================================================================
  function renderMarkdown(src) {
    if (!src) return '';
    var lines = src.split('\n');
    var html = '';
    var inList = false; // track if we are inside a <ul>

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];

      // Headings: ## text
      var headingMatch = line.match(/^(#{1,6})\s+(.*)/);
      if (headingMatch) {
        if (inList) { html += '</ul>'; inList = false; }
        var level = headingMatch[1].length;
        html += '<h' + level + '>' + inlineMarkdown(escapeHtml(headingMatch[2])) + '</h' + level + '>';
        continue;
      }

      // Todo items: - [ ] text  or  - [x] text
      var todoMatch = line.match(/^[-*]\s+\[([ xX])\]\s+(.*)/);
      if (todoMatch) {
        if (!inList) { html += '<ul class="qc-md-list">'; inList = true; }
        var checked = todoMatch[1] !== ' ';
        html += '<li class="qc-md-todo">'
          + '<input type="checkbox" disabled' + (checked ? ' checked' : '') + '> '
          + inlineMarkdown(escapeHtml(todoMatch[2]))
          + '</li>';
        continue;
      }

      // Bullet / list items: - text or * text
      var bulletMatch = line.match(/^[-*]\s+(.*)/);
      if (bulletMatch) {
        if (!inList) { html += '<ul class="qc-md-list">'; inList = true; }
        html += '<li>' + inlineMarkdown(escapeHtml(bulletMatch[1])) + '</li>';
        continue;
      }

      // Close any open list before non-list content
      if (inList) { html += '</ul>'; inList = false; }

      // Blank lines
      if (!line.trim()) {
        continue;
      }

      // Normal paragraph
      html += '<p>' + inlineMarkdown(escapeHtml(line)) + '</p>';
    }

    if (inList) html += '</ul>';
    return html;
  }

  // Inline markdown: bold, italic, inline code, links
  function inlineMarkdown(text) {
    // Inline code: `code`
    text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
    // Bold: **text**
    text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    // Italic: *text*  (but not inside **)
    text = text.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
    // Links: [text](url)
    text = text.replace(/\[([^\]]*)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    return text;
  }

  function updateNotePreview() {
    if (currentMode !== 'note' || !notePreviewPanel) return;
    var text = input.value;
    if (!text.trim()) {
      notePreviewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see a preview...</div>';
      notePreviewWrapper.style.display = 'none';
      return;
    }
    notePreviewWrapper.style.display = '';
    notePreviewPanel.innerHTML = renderMarkdown(text);
  }

  var notePreviewTimer = null;
  function scheduleNotePreview() {
    if (notePreviewTimer) clearTimeout(notePreviewTimer);
    notePreviewTimer = setTimeout(updateNotePreview, 150);
  }

  // =========================================================================
  // Mini syntax highlighter — outputs <span> with Chroma-compatible classes
  // Covers keywords, strings, comments, numbers, and functions for our 8 langs.
  // =========================================================================
  var langKeywords = {
    kotlin: /\b(fun|val|var|class|object|interface|if|else|when|for|while|do|return|break|continue|import|package|is|as|in|null|true|false|this|super|throw|try|catch|finally|typealias|companion|data|sealed|enum|open|abstract|override|private|public|protected|internal|inline|suspend|lateinit|by|init|constructor|get|set|it)\b/g,
    bash: /\b(if|then|else|elif|fi|for|while|do|done|case|esac|function|return|in|select|until|local|export|source|alias|unalias|readonly|declare|typeset|set|unset|shift|trap|exec|eval|exit|echo|printf|read|test|true|false)\b/g,
    sql: /\b(SELECT|FROM|WHERE|INSERT|INTO|UPDATE|SET|DELETE|CREATE|DROP|ALTER|TABLE|INDEX|VIEW|JOIN|INNER|LEFT|RIGHT|OUTER|CROSS|ON|AND|OR|NOT|IN|IS|NULL|AS|ORDER|BY|GROUP|HAVING|LIMIT|OFFSET|UNION|ALL|EXISTS|BETWEEN|LIKE|DISTINCT|COUNT|SUM|AVG|MIN|MAX|CASE|WHEN|THEN|ELSE|END|VALUES|PRIMARY|KEY|FOREIGN|REFERENCES|DEFAULT|CONSTRAINT|UNIQUE|CHECK|CASCADE|TRIGGER|FUNCTION|PROCEDURE|BEGIN|COMMIT|ROLLBACK|GRANT|REVOKE|WITH|RECURSIVE|RETURNING|COALESCE|CAST|NULLIF|select|from|where|insert|into|update|set|delete|create|drop|alter|table|index|view|join|inner|left|right|outer|cross|on|and|or|not|in|is|null|as|order|by|group|having|limit|offset|union|all|exists|between|like|distinct|count|sum|avg|min|max|case|when|then|else|end|values|primary|key|foreign|references|default|constraint|unique|check|cascade|trigger|function|procedure|begin|commit|rollback|grant|revoke|with|recursive|returning|coalesce|cast|nullif)\b/g,
    ruby: /\b(def|end|class|module|if|elsif|else|unless|while|until|for|do|begin|rescue|ensure|raise|return|yield|require|include|extend|attr_accessor|attr_reader|attr_writer|puts|print|nil|true|false|self|super|then|and|or|not|in|case|when|lambda|proc|block_given)\b/g,
    python: /\b(def|class|if|elif|else|for|while|return|import|from|as|try|except|finally|raise|with|yield|lambda|pass|break|continue|and|or|not|in|is|None|True|False|self|print|async|await|global|nonlocal|assert|del)\b/g,
    go: /\b(func|package|import|var|const|type|struct|interface|map|chan|range|if|else|for|switch|case|default|select|break|continue|return|go|defer|fallthrough|nil|true|false|make|new|len|cap|append|copy|delete|close|panic|recover|error|string|int|int8|int16|int32|int64|uint|float32|float64|bool|byte|rune)\b/g,
    javascript: /\b(function|var|let|const|if|else|for|while|do|switch|case|default|break|continue|return|class|extends|new|this|super|import|export|from|as|try|catch|finally|throw|async|await|yield|typeof|instanceof|in|of|delete|void|null|undefined|true|false|console|window|document|NaN|Infinity|require|module|Promise|Map|Set|Symbol|Array|Object|RegExp)\b/g,
    yaml: /\b(true|false|null|yes|no|on|off)\b/g
  };

  var langComments = {
    kotlin:     { line: '//', block: ['/\\*', '\\*/'] },
    bash:       { line: '#', block: null },
    sql:        { line: '--', block: ['/\\*', '\\*/'] },
    ruby:       { line: '#', block: ['=begin', '=end'] },
    python:     { line: '#', block: null },
    go:         { line: '//', block: ['/\\*', '\\*/'] },
    javascript: { line: '//', block: ['/\\*', '\\*/'] },
    yaml:       { line: '#', block: null }
  };

  function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function highlightCode(code, lang) {
    if (!code) return '';

    // Tokenize: we process the string linearly to avoid overlapping matches.
    // Tokens: { start, end, cls }
    var tokens = [];
    var src = code;

    // 1) Strings (double-quoted, single-quoted, backtick for JS)
    var strPatterns = lang === 'python'
      ? [/"""[\s\S]*?"""/g, /'''[\s\S]*?'''/g, /"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g]
      : lang === 'javascript'
      ? [/"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g, /`(?:[^`\\]|\\.)*`/g]
      : [/"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g];

    strPatterns.forEach(function(re) {
      var m;
      while ((m = re.exec(src)) !== null) {
        tokens.push({ start: m.index, end: m.index + m[0].length, cls: 's' });
      }
    });

    // 2) Comments
    var cmt = langComments[lang];
    if (cmt) {
      if (cmt.line) {
        var lineRe = new RegExp(cmt.line.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '.*', 'gm');
        var m;
        while ((m = lineRe.exec(src)) !== null) {
          tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'c1' });
        }
      }
      if (cmt.block) {
        var blockRe = new RegExp(cmt.block[0] + '[\\s\\S]*?' + cmt.block[1], 'g');
        var m;
        while ((m = blockRe.exec(src)) !== null) {
          tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'cm' });
        }
      }
    }

    // 3) Numbers
    var numRe = /\b(?:0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+\.?\d*(?:[eE][+-]?\d+)?)\b/g;
    var m;
    while ((m = numRe.exec(src)) !== null) {
      tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'mi' });
    }

    // Sort tokens by start, then by length descending (longer wins)
    tokens.sort(function(a, b) { return a.start - b.start || (b.end - b.start) - (a.end - a.start); });

    // Remove overlapping tokens (first one wins)
    var filtered = [];
    var lastEnd = 0;
    tokens.forEach(function(t) {
      if (t.start >= lastEnd) {
        filtered.push(t);
        lastEnd = t.end;
      }
    });

    // Build output: interleave plain text (with keyword highlighting) and tokens
    var out = '';
    var pos = 0;

    function highlightKeywords(text) {
      var kwRe = langKeywords[lang];
      if (!kwRe) return escapeHtml(text);
      // Reset regex
      kwRe.lastIndex = 0;
      var result = '';
      var last = 0;
      var km;
      while ((km = kwRe.exec(text)) !== null) {
        result += escapeHtml(text.slice(last, km.index));
        result += '<span class="k">' + escapeHtml(km[0]) + '</span>';
        last = km.index + km[0].length;
      }
      result += escapeHtml(text.slice(last));

      // Also highlight function calls: word followed by (
      result = result.replace(/\b([a-zA-Z_]\w*)(\()/g, function(match, name, paren) {
        // Don't re-wrap already-wrapped keywords
        if (match.indexOf('<span') !== -1) return match;
        return '<span class="nf">' + name + '</span>' + paren;
      });

      return result;
    }

    filtered.forEach(function(t) {
      if (t.start > pos) {
        out += highlightKeywords(src.slice(pos, t.start));
      }
      out += '<span class="' + t.cls + '">' + escapeHtml(src.slice(t.start, t.end)) + '</span>';
      pos = t.end;
    });
    if (pos < src.length) {
      out += highlightKeywords(src.slice(pos));
    }

    return out;
  }

  function updatePreview() {
    if (currentMode !== 'code' || !previewPanel) return;
    var code = input.value;
    if (!code.trim()) {
      previewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see highlighted preview...</div>';
      return;
    }
    var highlighted = highlightCode(code, selectedLang);
    previewPanel.innerHTML = '<pre class="chroma"><code>' + highlighted + '</code></pre>';
  }

  function schedulePreview() {
    if (previewTimer) clearTimeout(previewTimer);
    previewTimer = setTimeout(updatePreview, 150);
  }

  // Listen for input on textarea
  input.addEventListener('input', function() {
    if (currentMode === 'code') schedulePreview();
    if (currentMode === 'note') scheduleNotePreview();
  });

  // Mode switching logic
  var modes = ['ai', 'note', 'code', 'todo'];

  function setMode(mode) {
    if (mode === currentMode) return;
    currentMode = mode;
    modeButtons.forEach(function(b) { b.classList.remove('active'); });
    modeButtons.forEach(function(b) {
      if (b.getAttribute('data-mode') === mode) b.classList.add('active');
    });

    // Hide everything first
    destRow.style.display = 'none';
    langRow.style.display = 'none';
    if (bookTitleRow) bookTitleRow.style.display = 'none';
    previewWrapper.style.display = 'none';
    notePreviewWrapper.style.display = 'none';
    if (todoFieldsEl) todoFieldsEl.style.display = 'none';
    if (qcAiContainer) qcAiContainer.style.display = 'none';

    // Hide/show common elements based on AI vs other modes
    var isAiMode = mode === 'ai';
    titleInput.style.display = isAiMode ? 'none' : '';
    document.getElementById('qc-editor-box').style.display = isAiMode ? 'none' : '';
    // Hide Save/Cancel for AI mode, show for others
    var actionsEl = modal.querySelector('.quick-capture-actions');
    if (actionsEl) actionsEl.style.display = isAiMode ? 'none' : '';

    if (mode === 'ai') {
      if (qcAiContainer) qcAiContainer.style.display = '';
      if (toolbar) toolbar.style.display = 'none';
      input.classList.remove('code-mode');
      dialog.classList.remove('code-mode');
      dialog.classList.add('ai-mode');
      // Focus AI input after a tick
      setTimeout(function() { if (qcAiInput) qcAiInput.focus(); }, 50);
    } else if (mode === 'code') {
      langRow.style.display = '';
      previewWrapper.style.display = '';
      if (toolbar) toolbar.style.display = 'none';
      input.classList.add('code-mode');
      dialog.classList.add('code-mode');
      dialog.classList.remove('ai-mode');
      input.placeholder = 'Paste or type your code here...';
      titleInput.style.display = '';
      document.getElementById('qc-editor-box').style.display = '';
      updatePreview();
    } else if (mode === 'todo') {
      if (todoFieldsEl) todoFieldsEl.style.display = '';
      if (toolbar) toolbar.style.display = 'none';
      titleInput.style.display = 'none';
      document.getElementById('qc-editor-box').style.display = 'none';
      input.classList.remove('code-mode');
      dialog.classList.remove('code-mode');
      dialog.classList.remove('ai-mode');
    } else {
      // note mode
      destRow.style.display = '';
      if (toolbar) toolbar.style.display = '';
      if (bookTitleRow) bookTitleRow.style.display = selectedDest.tag === 'book-note' ? '' : 'none';
      input.classList.remove('code-mode');
      dialog.classList.remove('code-mode');
      dialog.classList.remove('ai-mode');
      input.placeholder = "What's on your mind?";
      titleInput.style.display = '';
      document.getElementById('qc-editor-box').style.display = '';
      updateNotePreview();
    }

    // Focus the primary input for the new mode
    if (mode === 'ai') {
      // already handled above
    } else if (mode === 'todo') {
      if (todoTitleInput) todoTitleInput.focus();
    } else {
      titleInput.focus();
    }
  }

  // Mode toggle click handlers
  modeButtons.forEach(function(mbtn) {
    mbtn.addEventListener('click', function() {
      setMode(mbtn.getAttribute('data-mode'));
    });
  });

  // Destination button click handling
  destButtons.forEach(function(dbtn) {
    dbtn.addEventListener('click', function() {
      destButtons.forEach(function(b) { b.classList.remove('active'); });
      dbtn.classList.add('active');
      selectedDest.path = dbtn.getAttribute('data-path');
      selectedDest.tag = dbtn.getAttribute('data-tag');

      // Show/hide book title input
      if (selectedDest.tag === 'book-note' && bookTitleRow) {
        bookTitleRow.style.display = '';
        populateBookTitleDatalist();
      } else if (bookTitleRow) {
        bookTitleRow.style.display = 'none';
      }

      // Show/hide new-note toggle (only visible when Inbox is selected)
      if (inboxNewBtn) {
        inboxNewBtn.style.display = selectedDest.tag === 'inbox' ? '' : 'none';
        if (selectedDest.tag !== 'inbox') {
          inboxNewBtn.classList.remove('active');
          inboxMode = 'append';
        }
      }
    });
  });

  // Inbox new-note toggle click handling
  if (inboxNewBtn) {
    inboxNewBtn.addEventListener('click', function() {
      var isNew = inboxNewBtn.classList.toggle('active');
      inboxMode = isNew ? 'new' : 'append';
    });
  }

  // Language button click handling
  langButtons.forEach(function(lbtn) {
    lbtn.addEventListener('click', function() {
      langButtons.forEach(function(b) { b.classList.remove('active'); });
      lbtn.classList.add('active');
      selectedLang = lbtn.getAttribute('data-lang');
      updatePreview();
    });
  });

  // Populate the book title datalist with existing book titles from IndexedDB
  function populateBookTitleDatalist() {
    if (!bookTitleDatalist || !window.dmSync) return;
    window.dmSync.getAllNotes().then(function(notes) {
      var titles = {};
      notes.forEach(function(n) {
        if (n.destination === 'book-note' && n.bookTitle) {
          titles[n.bookTitle] = true;
        }
      });
      var html = '';
      Object.keys(titles).sort().forEach(function(t) {
        html += '<option value="' + t.replace(/"/g, '&quot;') + '">';
      });
      bookTitleDatalist.innerHTML = html;
    });
  }

  // =========================================================================
  // Todo mode: date/reminder popovers and chips
  // =========================================================================

  function closeQcTodoPopover() {
    if (_qcTodoPopover && _qcTodoPopover.parentNode) {
      _qcTodoPopover.parentNode.removeChild(_qcTodoPopover);
    }
    _qcTodoPopover = null;
  }

  function formatQcDateChip(dateStr) {
    var today = new Date(); today.setHours(0,0,0,0);
    var d = new Date(dateStr + 'T00:00:00');
    var diff = Math.round((d - today) / 86400000);
    if (diff === 0) return 'Today';
    if (diff === 1) return 'Tomorrow';
    var days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    if (diff > 1 && diff < 7) return days[d.getDay()];
    return months[d.getMonth()] + ' ' + d.getDate();
  }

  function formatQcReminderChip(ms) {
    var d = new Date(ms);
    var now = new Date();
    var diffMin = Math.round((ms - now.getTime()) / 60000);
    if (diffMin > 0 && diffMin <= 90) return 'In ' + diffMin + ' min';
    var today = new Date(); today.setHours(0,0,0,0);
    var target = new Date(ms); target.setHours(0,0,0,0);
    var dayDiff = Math.round((target - today) / 86400000);
    var timeStr = d.getHours() + ':' + (d.getMinutes() < 10 ? '0' : '') + d.getMinutes();
    if (dayDiff === 0) return 'Today ' + timeStr;
    if (dayDiff === 1) return 'Tmrw ' + timeStr;
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[d.getMonth()] + ' ' + d.getDate() + ' ' + timeStr;
  }

  function updateQcDateChip() {
    if (_qcTodoDate) {
      todoDateChipText.textContent = formatQcDateChip(_qcTodoDate);
      todoDateChip.style.display = '';
    } else {
      todoDateChip.style.display = 'none';
    }
  }

  function updateQcReminderChip() {
    if (_qcTodoReminderMs) {
      todoReminderChipText.textContent = formatQcReminderChip(_qcTodoReminderMs);
      todoReminderChip.style.display = '';
    } else {
      todoReminderChip.style.display = 'none';
    }
  }

  function showQcDatePopover() {
    closeQcTodoPopover();
    var pop = document.createElement('div');
    pop.className = 'qc-todo-popover';

    var today = new Date();
    var todayStr = today.getFullYear() + '-' + pad(today.getMonth()+1) + '-' + pad(today.getDate());
    var tmrw = new Date(today); tmrw.setDate(tmrw.getDate()+1);
    var tmrwStr = tmrw.getFullYear() + '-' + pad(tmrw.getMonth()+1) + '-' + pad(tmrw.getDate());

    pop.innerHTML =
      '<button type="button" class="qc-todo-popover-shortcut" data-val="' + todayStr + '">Today</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-val="' + tmrwStr + '">Tomorrow</button>' +
      '<input type="date" class="qc-todo-popover-date" min="' + todayStr + '" />';

    pop.querySelectorAll('.qc-todo-popover-shortcut').forEach(function(btn) {
      btn.addEventListener('click', function() {
        _qcTodoDate = btn.getAttribute('data-val');
        updateQcDateChip();
        closeQcTodoPopover();
      });
    });
    pop.querySelector('.qc-todo-popover-date').addEventListener('change', function() {
      if (this.value) {
        _qcTodoDate = this.value;
        updateQcDateChip();
        closeQcTodoPopover();
      }
    });

    // Position below the button
    var rect = todoDateBtn.getBoundingClientRect();
    var dialogRect = dialog.getBoundingClientRect();
    pop.style.position = 'absolute';
    pop.style.top = (rect.bottom - dialogRect.top + 4) + 'px';
    pop.style.left = (rect.left - dialogRect.left) + 'px';

    dialog.appendChild(pop);
    _qcTodoPopover = pop;
  }

  function showQcReminderPopover() {
    closeQcTodoPopover();
    var pop = document.createElement('div');
    pop.className = 'qc-todo-popover';

    var now = new Date();
    var in30 = new Date(now.getTime() + 30*60000);
    var in60 = new Date(now.getTime() + 60*60000);
    var tmrw9 = new Date(now); tmrw9.setDate(tmrw9.getDate()+1); tmrw9.setHours(9,0,0,0);

    pop.innerHTML =
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + in30.getTime() + '">In 30 min</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + in60.getTime() + '">In 1 hour</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + tmrw9.getTime() + '">Tomorrow 9 AM</button>' +
      '<input type="datetime-local" class="qc-todo-popover-datetime" />';

    pop.querySelectorAll('.qc-todo-popover-shortcut').forEach(function(btn) {
      btn.addEventListener('click', function() {
        _qcTodoReminderMs = parseInt(btn.getAttribute('data-ms'), 10);
        updateQcReminderChip();
        closeQcTodoPopover();
      });
    });
    pop.querySelector('.qc-todo-popover-datetime').addEventListener('change', function() {
      if (this.value) {
        _qcTodoReminderMs = new Date(this.value).getTime();
        updateQcReminderChip();
        closeQcTodoPopover();
      }
    });

    var rect = todoReminderBtn.getBoundingClientRect();
    var dialogRect = dialog.getBoundingClientRect();
    pop.style.position = 'absolute';
    pop.style.top = (rect.bottom - dialogRect.top + 4) + 'px';
    pop.style.left = (rect.left - dialogRect.left) + 'px';

    dialog.appendChild(pop);
    _qcTodoPopover = pop;
  }

  // Wire up todo icon buttons
  if (todoDateBtn) {
    todoDateBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (_qcTodoPopover) { closeQcTodoPopover(); return; }
      showQcDatePopover();
    });
  }
  if (todoReminderBtn) {
    todoReminderBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (_qcTodoPopover) { closeQcTodoPopover(); return; }
      showQcReminderPopover();
    });
  }
  if (todoDateClear) {
    todoDateClear.addEventListener('click', function() {
      _qcTodoDate = null;
      updateQcDateChip();
    });
  }
  if (todoReminderClear) {
    todoReminderClear.addEventListener('click', function() {
      _qcTodoReminderMs = null;
      updateQcReminderChip();
    });
  }

  // Dismiss popover on outside click
  document.addEventListener('click', function(e) {
    if (_qcTodoPopover && !_qcTodoPopover.contains(e.target) &&
        e.target !== todoDateBtn && e.target !== todoReminderBtn &&
        !todoDateBtn.contains(e.target) && !todoReminderBtn.contains(e.target)) {
      closeQcTodoPopover();
    }
  });

  function openModal(startMode) {
    var mode = startMode || 'ai';
    // Reset state
    currentMode = mode;
    selectedLang = 'kotlin';
    modeButtons.forEach(function(b) { b.classList.remove('active'); });
    modeButtons.forEach(function(b) {
      if (b.getAttribute('data-mode') === mode) b.classList.add('active');
    });
    destRow.style.display = mode === 'note' ? '' : 'none';
    langRow.style.display = mode === 'code' ? '' : 'none';
    if (bookTitleRow) bookTitleRow.style.display = 'none';
    if (bookTitleInput) bookTitleInput.value = '';
    // Reset inbox new-note toggle
    inboxMode = 'append';
    if (inboxNewBtn) inboxNewBtn.classList.remove('active');
    previewWrapper.style.display = mode === 'code' ? '' : 'none';
    notePreviewWrapper.style.display = 'none';
    if (toolbar) toolbar.style.display = mode === 'note' ? '' : 'none';
    langButtons.forEach(function(b) { b.classList.remove('active'); });
    langButtons[0].classList.add('active');
    // Reset destination to Inbox
    destButtons.forEach(function(b) { b.classList.remove('active'); });
    destButtons[0].classList.add('active');
    selectedDest.path = destButtons[0].getAttribute('data-path');
    selectedDest.tag = destButtons[0].getAttribute('data-tag');
    input.classList.remove('code-mode');
    dialog.classList.remove('code-mode');
    dialog.classList.remove('ai-mode');
    input.placeholder = "What's on your mind?";

    // Reset todo state
    if (todoFieldsEl) todoFieldsEl.style.display = mode === 'todo' ? '' : 'none';
    if (todoTitleInput) todoTitleInput.value = '';
    if (todoEstimateInput) todoEstimateInput.value = '';
    _qcTodoDate = null;
    _qcTodoReminderMs = null;
    updateQcDateChip();
    updateQcReminderChip();
    closeQcTodoPopover();

    // AI mode setup
    if (qcAiContainer) qcAiContainer.style.display = mode === 'ai' ? '' : 'none';

    // Show/hide elements based on mode
    var isAiMode = mode === 'ai';
    titleInput.style.display = isAiMode ? 'none' : (mode === 'todo' ? 'none' : '');
    document.getElementById('qc-editor-box').style.display = isAiMode ? 'none' : (mode === 'todo' ? 'none' : '');
    var actionsEl = modal.querySelector('.quick-capture-actions');
    if (actionsEl) actionsEl.style.display = isAiMode ? 'none' : '';
    if (isAiMode) dialog.classList.add('ai-mode');
    if (mode === 'code') {
      input.classList.add('code-mode');
      dialog.classList.add('code-mode');
      input.placeholder = 'Paste or type your code here...';
    }

    modal.classList.add('active');
    modal.setAttribute('aria-hidden', 'false');
    titleInput.value = '';
    input.value = '';
    if (previewPanel) previewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see highlighted preview...</div>';
    if (notePreviewPanel) notePreviewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see a preview...</div>';

    // Focus appropriate input
    if (mode === 'ai') {
      setTimeout(function() { if (qcAiInput) qcAiInput.focus(); }, 50);
    } else if (mode === 'todo') {
      if (todoTitleInput) todoTitleInput.focus();
    } else {
      titleInput.focus();
    }
  }

  function closeModal() {
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
    titleInput.value = '';
    input.value = '';
    if (bookTitleInput) bookTitleInput.value = '';
    if (todoTitleInput) todoTitleInput.value = '';
    if (todoEstimateInput) todoEstimateInput.value = '';
    _qcTodoDate = null;
    _qcTodoReminderMs = null;
    closeQcTodoPopover();
    isSaving = false;
    if (feedbackEl) feedbackEl.style.display = 'none';
    // Stop AI generation if in progress
    if (_qcAiAbort) { _qcAiAbort.stop(); _qcAiAbort = null; }
    if (_qcAiRecognition && _qcAiRecording) { try { _qcAiRecognition.stop(); } catch(e) {} }
  }

  function pad(n) { return n < 10 ? '0' + n : '' + n; }

  function submit() {
    if (isSaving) return;

    // AI mode — not handled by submit
    if (currentMode === 'ai') return;

    // Todo mode — different submit path
    if (currentMode === 'todo') {
      submitTodo();
      return;
    }

    var text = input.value.trim();
    if (!text) {
      input.focus();
      return;
    }

    // Check auth
    if (!window.dmAuth || !window.dmAuth.currentUser) {
      showFeedback('error', 'Please sign in with Google to save notes.');
      return;
    }

    isSaving = true;
    submitBtn.disabled = true;

    var user = window.dmAuth.currentUser;
    var now = new Date();
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    var displayDate = months[now.getMonth()] + ' ' + now.getDate() + ', ' + now.getFullYear();

    var userTitle = titleInput.value.trim();
    var noteData = {
      userId: user.uid,
      userEmail: user.email,
      userName: user.displayName || '',
      content: text,
      mode: currentMode,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    if (currentMode === 'code') {
      var langLabel = selectedLang.charAt(0).toUpperCase() + selectedLang.slice(1);
      noteData.title = userTitle || (langLabel + ' Snippet - ' + displayDate);
      noteData.language = selectedLang;
      noteData.tags = ['snippet', selectedLang];
      noteData.destination = 'snippets';
    } else {
      noteData.title = userTitle || ('Quick Note - ' + displayDate);
      noteData.destination = selectedDest.tag;
      noteData.tags = [selectedDest.tag];
      noteData.language = null;

      // Include bookTitle for book notes
      if (selectedDest.tag === 'book-note' && bookTitleInput) {
        noteData.bookTitle = bookTitleInput.value.trim() || null;
      }
    }

    // Inbox append mode: prepend to existing single note (newest on top)
    if (noteData.destination === 'inbox' && inboxMode === 'append' && window.dmSync) {
      window.dmSync.getNotesByDestination('inbox').then(function(inboxNotes) {
        if (inboxNotes && inboxNotes.length > 0) {
          // Prepend to existing inbox note (newest content on top)
          inboxNotes.sort(function(a, b) { return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0); });
          var existing = inboxNotes[0];
          var separator = '\n\n---\n\n';
          var heading = userTitle ? ('## ' + userTitle + '\n\n') : '';
          var prepended = heading + text + separator + existing.content;

          var updateData = {
            content: prepended,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          };

          window.dmSync.firestoreWrite({
              collection: 'notes',
              docId: existing.id,
              op: 'update',
              data: updateData,
              localOp: function() {
                existing.content = prepended;
                existing.updatedAt = Date.now();
                return window.dmSync.putNote(existing);
              }
            })
            .then(function() {
              isSaving = false;
              submitBtn.disabled = false;
              showFeedback('success', 'Added to Inbox!');
              window.dispatchEvent(new CustomEvent('dm-sync-complete'));
            })
            .catch(function(err) {
              console.error('Firestore append error:', err);
              isSaving = false;
              submitBtn.disabled = false;
              showFeedback('error', 'Failed to save. Please try again.');
            });
        } else {
          // No inbox note exists yet — create one
          noteData.title = 'Inbox';
          var heading = userTitle ? ('## ' + userTitle + '\n\n') : '';
          noteData.content = heading + text;
          createNewNote(noteData);
        }
      }).catch(function(err) {
        console.error('Error checking inbox notes:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to save. Please try again.');
      });
      return;
    }

    // All other destinations: create a new note
    createNewNote(noteData);
  }

  function createNewNote(noteData) {
    var newDocId = window.dmDb ? window.dmDb.collection('notes').doc().id : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    var localNote = Object.assign({}, noteData, {
      id: newDocId,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });

    window.dmSync.firestoreWrite({
      collection: 'notes',
      docId: newDocId,
      op: 'set',
      data: noteData,
      localOp: function() { return window.dmSync.putNote(localNote); }
    })
      .then(function() {
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('success', 'Note saved!');
        // Fire sync event so sidebar updates
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      })
      .catch(function(err) {
        console.error('Firestore write error:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to save. Please try again.');
      });
  }

  function submitTodo() {
    var title = todoTitleInput ? todoTitleInput.value.trim() : '';
    if (!title) {
      if (todoTitleInput) todoTitleInput.focus();
      return;
    }

    if (!window.dmAuth || !window.dmAuth.currentUser) {
      showFeedback('error', 'Please sign in with Google to save tasks.');
      return;
    }

    if (!window.dmDb) {
      showFeedback('error', 'Database not ready. Try again.');
      return;
    }

    isSaving = true;
    submitBtn.disabled = true;

    // ── NLP auto-parse: extract date, estimate, category, priority from title ──
    var nlpTitle = title;
    var nlpScheduledDate = _qcTodoDate || null;
    var nlpEstimate = todoEstimateInput ? (parseInt(todoEstimateInput.value, 10) || 0) : 0;
    var nlpCategory = null;
    var nlpBujoType = 'task';
    var nlpFeedbackParts = [];

    if (window.dmAI && window.dmAI._parseTaskDetails) {
      var parsed = window.dmAI._parseTaskDetails(title);
      // Only apply NLP date if user hasn't manually set one
      if (!_qcTodoDate && parsed.scheduledDate) {
        nlpScheduledDate = parsed.scheduledDate;
        nlpFeedbackParts.push('scheduled');
      }
      // Only apply NLP estimate if user hasn't manually entered one
      if (!nlpEstimate && parsed.estimatedMin) {
        nlpEstimate = parsed.estimatedMin;
        nlpFeedbackParts.push(nlpEstimate + 'min');
      }
      if (parsed.category) {
        nlpCategory = parsed.category;
      }
      if (parsed.bujoType) {
        nlpBujoType = parsed.bujoType;
      }
      // Use cleaned title (without date/time/estimate phrases)
      if (parsed.title && parsed.title !== title) {
        nlpTitle = parsed.title;
      }
    }

    var user = window.dmAuth.currentUser;
    var est = nlpEstimate || 25;
    var scheduledDate = nlpScheduledDate;
    var reminderAtMs = (_qcTodoReminderMs && _qcTodoReminderMs > Date.now()) ? _qcTodoReminderMs : null;

    var todoData = {
      userId: user.uid,
      title: nlpTitle,
      estimatedMin: est,
      actualMin: null,
      category: nlpCategory,
      done: false,
      status: 'active',
      parentId: null,
      order: Date.now(),
      scheduledDate: scheduledDate,
      reminderAt: reminderAtMs ? firebase.firestore.Timestamp.fromMillis(reminderAtMs) : null,
      reminderFired: false,
      bujoType: nlpBujoType,
      bujoState: 'open',
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      completedAt: null
    };

    var newTodoId = window.dmDb ? window.dmDb.collection('todos').doc().id : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    var localTodo = Object.assign({}, todoData, {
      id: newTodoId,
      reminderAt: reminderAtMs || null,
      reminderFired: false,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });

    window.dmSync.firestoreWrite({
      collection: 'todos',
      docId: newTodoId,
      op: 'set',
      data: todoData,
      localOp: function() { return window.dmSync.putTodo(localTodo); }
    })
      .then(function() {
        isSaving = false;
        submitBtn.disabled = false;
        var msg = 'Task added!';
        if (nlpFeedbackParts.length > 0) {
          msg = 'Task added (' + nlpFeedbackParts.join(', ') + ')';
        }
        showFeedback('success', msg);
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      })
      .catch(function(err) {
        console.error('Firestore todo write error:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to add task. Please try again.');
      });
  }

  btn.addEventListener('click', function() { openModal('ai'); });
  cancelBtn.addEventListener('click', closeModal);
  submitBtn.addEventListener('click', submit);
  backdrop.addEventListener('click', closeModal);

  document.addEventListener('keydown', function(e) {
    // Global shortcut: Q to open Quick Capture (when not typing)
    if (!modal.classList.contains('active')) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
      if (e.key === 'q' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault();
        openModal();
      }
      // A opens Quick Capture in AI mode
      if (e.key === 'a' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        e.preventDefault();
        openModal('ai');
      }
      // E opens note edit modal (clicks the edit button in note-viewer)
      if (e.key === 'e' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        var editBtn = document.getElementById('note-viewer-edit');
        if (editBtn && editBtn.offsetParent !== null) {
          e.preventDefault();
          editBtn.click();
        }
      }
      return;
    }

    // Modal-specific shortcuts
    if (e.key === 'Escape') {
      // Only close if the active input for the current mode is empty
      var activeInput = currentMode === 'todo' ? todoTitleInput
                      : currentMode === 'ai' ? qcAiInput
                      : input;
      if (activeInput && activeInput.value.trim()) {
        // Clear the input instead of closing
        e.preventDefault();
        activeInput.value = '';
        activeInput.focus();
        return;
      }
      e.preventDefault();
      closeModal();
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      submit();
    }
    // Tab cycles modes: Note → Code → Todo → Note
    if (e.key === 'Tab' && !e.metaKey && !e.ctrlKey && !e.altKey) {
      e.preventDefault();
      var idx = modes.indexOf(currentMode);
      var next = e.shiftKey
        ? modes[(idx - 1 + modes.length) % modes.length]
        : modes[(idx + 1) % modes.length];
      setMode(next);
    }

    // Formatting shortcuts (Note mode only, when textarea is focused)
    if (currentMode === 'note' && e.target === input && (e.metaKey || e.ctrlKey)) {
      if (e.key === 'b') {
        e.preventDefault();
        applyFormat('bold');
      } else if (e.key === 'i') {
        e.preventDefault();
        applyFormat('italic');
      } else if (e.key === 'e') {
        e.preventDefault();
        applyFormat('code');
      } else if (e.shiftKey && (e.key === 'T' || e.key === 't')) {
        e.preventDefault();
        applyFormat('todo');
      } else if (e.shiftKey && (e.key === 'H' || e.key === 'h')) {
        e.preventDefault();
        applyFormat('heading');
      }
    }
  });

  // ─── Quick Capture AI Mode ───
  // Delegates to window.dmAI for engine, rendering, task detection.
  // Maintains its own chat history, messages DOM, and streaming state.

  var _qcAiChatHistory = [];
  var _qcAiIsGenerating = false;
  var _qcAiAbort = null;
  var _qcAiRecognition = null;
  var _qcAiRecording = false;

  // Session storage key for QC AI messages
  var QC_AI_SS_KEY = 'dm-qc-ai-messages';

  // Quick action prompts (same as side panel)
  var _qcAiQuickPrompts = {
    plan: 'Look at my tasks for today and overdue. Create a prioritized plan with suggested order. If no tasks today, pick from my backlog.',
    suggest: 'Suggest 3-5 new tasks based on my existing tasks. For each, give the title in **bold** and a one-line reason.',
    improve: null,
    summarize: null
  };

  // ─── AI state visibility ───
  function _qcAiUpdateVisibility() {
    if (!qcAiModeBtn) return;
    var enabled = window.dmAI && window.dmAI.isEnabled();
    qcAiModeBtn.style.display = enabled ? '' : 'none';
    // If we're currently in AI mode but AI got disabled, switch to note
    if (!enabled && currentMode === 'ai') {
      setMode('note');
    }
  }

  // Listen for AI state changes
  window.addEventListener('dm-ai-state-changed', function() {
    _qcAiUpdateVisibility();
  });

  // Initial visibility check (deferred so ai-companion.html has time to init)
  setTimeout(_qcAiUpdateVisibility, 100);

  // ─── Helpers ───
  function _qcAiScrollToBottom(force) {
    if (!qcAiMessages) return;
    var atBottom = force || (qcAiMessages.scrollHeight - qcAiMessages.scrollTop - qcAiMessages.clientHeight < 80);
    if (atBottom) {
      qcAiMessages.scrollTop = qcAiMessages.scrollHeight;
    }
  }

  function _qcAiAddMessage(role, content) {
    if (qcAiWelcome) qcAiWelcome.style.display = 'none';
    var msgEl = document.createElement('div');
    msgEl.className = 'qc-ai-msg qc-ai-msg-' + role;

    var avatarEl = document.createElement('div');
    avatarEl.className = 'qc-ai-msg-avatar';
    avatarEl.textContent = role === 'user' ? 'U' : 'AI';

    var bubbleEl = document.createElement('div');
    bubbleEl.className = 'qc-ai-msg-bubble';
    if (content && window.dmAI) {
      bubbleEl.innerHTML = window.dmAI._renderMarkdown(content);
    } else if (content) {
      bubbleEl.textContent = content;
    }

    msgEl.appendChild(avatarEl);
    msgEl.appendChild(bubbleEl);
    qcAiMessages.appendChild(msgEl);
    _qcAiScrollToBottom(true);
    return msgEl;
  }

  function _qcAiAddTyping() {
    var el = document.createElement('div');
    el.className = 'qc-ai-msg qc-ai-msg-assistant';
    el.innerHTML = '<div class="qc-ai-msg-avatar">AI</div><div class="qc-ai-msg-bubble"><div class="qc-ai-typing"><span class="qc-ai-typing-dot"></span><span class="qc-ai-typing-dot"></span><span class="qc-ai-typing-dot"></span></div></div>';
    qcAiMessages.appendChild(el);
    _qcAiScrollToBottom(true);
    return el;
  }

  function _qcAiAddCopyBtn(bubbleEl, text) {
    var btn = document.createElement('button');
    btn.className = 'qc-ai-copy-btn';
    btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> Copy';
    btn.addEventListener('click', function() {
      navigator.clipboard.writeText(text).then(function() {
        btn.classList.add('copied');
        btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied';
        setTimeout(function() {
          btn.classList.remove('copied');
          btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> Copy';
        }, 2000);
      }).catch(function() {});
    });
    bubbleEl.appendChild(btn);
  }

  function _qcAiDetectTaskCards(bubbleEl, text) {
    var boldPattern = /\*\*([^*]+)\*\*/g;
    var matches = [];
    var match;
    while ((match = boldPattern.exec(text)) !== null) {
      var title = match[1].trim();
      if (title.length > 5 && title.length < 200 && !/^[A-Za-z]{1,15}:/.test(title)) {
        matches.push(title);
      }
    }
    if (matches.length === 0) return;

    var container = document.createElement('div');
    container.style.marginTop = '8px';

    matches.forEach(function(taskTitle) {
      var card = document.createElement('div');
      card.className = 'qc-ai-task-card';

      var titleSpan = document.createElement('span');
      titleSpan.className = 'qc-ai-task-card-title';
      titleSpan.textContent = taskTitle;

      var addBtn = document.createElement('button');
      addBtn.className = 'qc-ai-task-card-add';
      addBtn.innerHTML = '+';
      addBtn.title = 'Add as task';
      addBtn.addEventListener('click', function() {
        if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser) {
          _qcAiAddMessage('assistant', 'Please sign in to add tasks.');
          return;
        }
        // Run NLP parsing on suggested task title to extract date/estimate/category
        var detail = { title: taskTitle, source: 'ai', bujoType: 'task' };
        if (window.dmAI && window.dmAI._parseTaskDetails) {
          var det = window.dmAI._parseTaskDetails(taskTitle);
          detail.title = det.title;
          detail.scheduledDate = det.scheduledDate;
          detail.estimatedMin = det.estimatedMin;
          detail.category = det.category;
          detail.bujoType = det.bujoType || 'task';
        }
        window.dispatchEvent(new CustomEvent('dm-ai-create-task', { detail: detail }));
        addBtn.style.display = 'none';
        var addedSpan = document.createElement('span');
        addedSpan.className = 'qc-ai-task-card-added';
        addedSpan.textContent = 'Added';
        card.appendChild(addedSpan);
      });

      card.appendChild(titleSpan);
      card.appendChild(addBtn);
      container.appendChild(card);
    });

    bubbleEl.appendChild(container);
  }

  // ─── Save / Load messages ───
  function _qcAiSaveMessages() {
    try {
      if (_qcAiChatHistory.length > 50) {
        _qcAiChatHistory = _qcAiChatHistory.slice(-50);
      }
      sessionStorage.setItem(QC_AI_SS_KEY, JSON.stringify(_qcAiChatHistory.slice(-20)));
    } catch(e) {}
  }

  function _qcAiLoadMessages() {
    try {
      var saved = sessionStorage.getItem(QC_AI_SS_KEY);
      if (saved) {
        var parsed = JSON.parse(saved);
        if (!Array.isArray(parsed)) return;
        _qcAiChatHistory = parsed.filter(function(msg) {
          return msg && (msg.role === 'user' || msg.role === 'assistant') && typeof msg.content === 'string';
        });
        _qcAiChatHistory.forEach(function(msg) {
          var msgEl = _qcAiAddMessage(msg.role, msg.content);
          msgEl.style.animation = 'none';
        });
      }
    } catch(e) {}
  }

  // Restore messages on page load
  _qcAiLoadMessages();

  // ─── Get task context ───
  function _qcAiGetTasks() {
    return new Promise(function(resolve) {
      if (!window.dmSync || !window.dmSync.getAllTodos) { resolve([]); return; }
      window.dmSync.getAllTodos().then(function(todos) { resolve(todos || []); }).catch(function() { resolve([]); });
    });
  }

  // ─── Core chat: run streaming completion via dmAI ───
  function _qcAiRunChat(userMessage, systemOverride) {
    if (_qcAiIsGenerating || !window.dmAI) return;
    _qcAiIsGenerating = true;
    if (qcAiSendBtn) qcAiSendBtn.disabled = true;
    if (qcAiStopBtn) qcAiStopBtn.style.display = '';

    _qcAiAddMessage('user', userMessage);
    _qcAiChatHistory.push({ role: 'user', content: userMessage });

    var typingEl = _qcAiAddTyping();

    // Show status while loading
    if (qcAiStatusEl) qcAiStatusEl.style.display = '';
    if (qcAiStatusText) qcAiStatusText.textContent = 'Loading AI model...';

    // Listen for progress
    function onProgress(e) {
      var d = e.detail || {};
      if (qcAiProgressFill) qcAiProgressFill.style.width = (d.pct || 0) + '%';
      if (qcAiStatusText) qcAiStatusText.textContent = d.text || 'Loading...';
      if (d.pct > 0 && d.pct < 100 && qcAiStatusDetail) qcAiStatusDetail.textContent = d.pct + '% complete';
    }
    window.addEventListener('dm-ai-load-progress', onProgress);

    var enginePromise = window.dmAI._loadEngine();

    enginePromise.then(function() {
      window.removeEventListener('dm-ai-load-progress', onProgress);
      if (qcAiStatusEl) qcAiStatusEl.style.display = 'none';
      if (qcAiProgressFill) qcAiProgressFill.style.width = '0%';
      if (qcAiStatusDetail) qcAiStatusDetail.textContent = '';
      return _qcAiGetTasks();
    }).then(function(tasks) {
      var systemPrompt = systemOverride || (window.dmAI._buildSystemPrompt ? window.dmAI._buildSystemPrompt(tasks) : '');
      var messages = [{ role: 'system', content: systemPrompt }];
      var recentHistory = _qcAiChatHistory.slice(-10);
      messages = messages.concat(recentHistory);

      var stopped = false;
      _qcAiAbort = { stop: function() { stopped = true; } };

      return window.dmAI._getEngine().then(function(engine) {
        return engine.chat.completions.create({
          messages: messages,
          stream: true,
          temperature: 0.7,
          max_tokens: 512
        }).then(function(chunks) {
          if (typingEl && typingEl.parentNode) typingEl.parentNode.removeChild(typingEl);

          var msgEl = _qcAiAddMessage('assistant', '');
          var bubbleEl = msgEl.querySelector('.qc-ai-msg-bubble');
          bubbleEl.classList.add('streaming');
          var fullText = '';
          var rafPending = false;

          function finalizeStream() {
            bubbleEl.classList.remove('streaming');
            _qcAiChatHistory.push({ role: 'assistant', content: fullText });
            _qcAiSaveMessages();
            if (window.dmAI._renderMarkdown) {
              bubbleEl.innerHTML = window.dmAI._renderMarkdown(fullText);
            }
            _qcAiAddCopyBtn(bubbleEl, fullText);
            _qcAiDetectTaskCards(bubbleEl, fullText);
            _qcAiIsGenerating = false;
            if (qcAiSendBtn) qcAiSendBtn.disabled = !(qcAiInput && qcAiInput.value.trim());
            if (qcAiStopBtn) qcAiStopBtn.style.display = 'none';
            _qcAiAbort = null;
          }

          if (chunks[Symbol.asyncIterator]) {
            var iterator = chunks[Symbol.asyncIterator]();
            function processIterator() {
              return iterator.next().then(function(result) {
                if (result.done || stopped) { finalizeStream(); return; }
                var chunk = result.value;
                var delta = '';
                if (chunk.choices && chunk.choices[0] && chunk.choices[0].delta) {
                  delta = chunk.choices[0].delta.content || '';
                }
                if (delta) {
                  fullText += delta;
                  if (!rafPending) {
                    rafPending = true;
                    requestAnimationFrame(function() {
                      rafPending = false;
                      if (window.dmAI._renderMarkdown) {
                        bubbleEl.innerHTML = window.dmAI._renderMarkdown(fullText);
                      }
                      _qcAiScrollToBottom();
                    });
                  }
                }
                return processIterator();
              });
            }
            return processIterator();
          } else {
            throw new Error('Unexpected streaming response format');
          }
        });
      });
    }).catch(function(err) {
      window.removeEventListener('dm-ai-load-progress', onProgress);
      if (qcAiStatusEl) qcAiStatusEl.style.display = 'none';
      if (typingEl && typingEl.parentNode) typingEl.parentNode.removeChild(typingEl);
      var errRaw = (err.message || String(err));
      var errLower = errRaw.toLowerCase();
      if (errLower.indexOf('not supported') === -1) {
        var friendlyMsg = 'Something went wrong.';
        if (errLower.indexOf('network') !== -1 || errLower.indexOf('fetch') !== -1) {
          friendlyMsg = 'Network error — check your connection and try again.';
        } else if (errLower.indexOf('context') !== -1 || errLower.indexOf('token') !== -1) {
          friendlyMsg = 'The conversation is too long. Try clearing and starting fresh.';
        } else {
          friendlyMsg += ' ' + errRaw;
        }
        _qcAiAddMessage('assistant', friendlyMsg);
      }
      _qcAiIsGenerating = false;
      if (qcAiSendBtn) qcAiSendBtn.disabled = !(qcAiInput && qcAiInput.value.trim());
      if (qcAiStopBtn) qcAiStopBtn.style.display = 'none';
      _qcAiAbort = null;
    });
  }

  // ─── Send message ───
  function _qcAiSendMessage() {
    if (!qcAiInput || !window.dmAI) return;
    var text = qcAiInput.value.trim();
    if (!text || _qcAiIsGenerating) return;

    var inputMode = qcAiInput.dataset.mode;
    qcAiInput.value = '';
    qcAiInput.dataset.mode = '';
    qcAiInput.placeholder = 'Ask me anything...';
    _qcAiHideModeBadge();
    _qcAiUpdateInputHeight();
    if (qcAiSendBtn) qcAiSendBtn.disabled = true;

    if (inputMode === 'improve') {
      _qcAiRunChat('Please improve the following text. Make it clearer, more concise, and better written. Return only the improved version:\n\n' + text);
    } else if (inputMode === 'summarize') {
      _qcAiRunChat('Please summarize the following text concisely:\n\n' + text);
    } else {
      // Check for task-creation intent
      if (window.dmAI._detectTaskIntent) {
        var rawTitle = window.dmAI._detectTaskIntent(text);
        if (rawTitle && window.dmAI._parseTaskDetails) {
          // Check for multi-action tasks
          if (window.dmAI._detectMultipleActions) {
            var multiActions = window.dmAI._detectMultipleActions(rawTitle);
            if (multiActions && multiActions.length >= 2 && window.dmDb && window.dmAuth && window.dmAuth.currentUser) {
              var sharedDate = window.dmAI._parseDate ? window.dmAI._parseDate(rawTitle) : null;
              var sharedScheduledDate = sharedDate ? sharedDate.date : null;
              var confirmParts = [];
              multiActions.forEach(function(action) {
                var det = window.dmAI._parseTaskDetails(action);
                if (!det.scheduledDate && sharedScheduledDate) {
                  det.scheduledDate = sharedScheduledDate;
                }
                window.dispatchEvent(new CustomEvent('dm-ai-create-task', {
                  detail: { title: det.title, scheduledDate: det.scheduledDate, estimatedMin: det.estimatedMin, category: det.category, bujoType: det.bujoType || 'task', source: 'ai' }
                }));
                confirmParts.push('**' + det.title + '**');
              });
              _qcAiAddMessage('user', text);
              _qcAiChatHistory.push({ role: 'user', content: text });
              var multiConfirm = 'Done — added ' + multiActions.length + ' tasks: ' + confirmParts.join(', ') + '.';
              if (sharedScheduledDate && window.dmAI._fmtDate) {
                var today = window.dmAI._fmtDate(new Date());
                var tmr = new Date(); tmr.setDate(tmr.getDate() + 1);
                var tmrStr = window.dmAI._fmtDate(tmr);
                var dateLabel = sharedScheduledDate === today ? 'today' : (sharedScheduledDate === tmrStr ? 'tomorrow' : sharedScheduledDate);
                multiConfirm += ' All scheduled for ' + dateLabel + '.';
              }
              _qcAiAddMessage('assistant', multiConfirm);
              _qcAiChatHistory.push({ role: 'assistant', content: multiConfirm });
              _qcAiSaveMessages();
              return;
            }
          }

          // Single task creation
          var details = window.dmAI._parseTaskDetails(rawTitle);
          if (window.dmDb && window.dmAuth && window.dmAuth.currentUser) {
            window.dispatchEvent(new CustomEvent('dm-ai-create-task', {
              detail: {
                title: details.title,
                scheduledDate: details.scheduledDate,
                estimatedMin: details.estimatedMin,
                category: details.category,
                bujoType: details.bujoType || 'task',
                source: 'ai'
              }
            }));
            _qcAiAddMessage('user', text);
            _qcAiChatHistory.push({ role: 'user', content: text });
            var confirmText = window.dmAI._buildTaskConfirmation(details);
            _qcAiAddMessage('assistant', confirmText);
            _qcAiChatHistory.push({ role: 'assistant', content: confirmText });
            _qcAiSaveMessages();
            return;
          }
        }
      }
      _qcAiRunChat(text);
    }
  }

  // ─── Mode badge ───
  function _qcAiShowModeBadge(label) {
    if (qcAiModeBadge) {
      if (qcAiModeBadgeText) qcAiModeBadgeText.textContent = label;
      qcAiModeBadge.style.display = '';
    }
  }

  function _qcAiHideModeBadge() {
    if (qcAiModeBadge) {
      qcAiModeBadge.style.display = 'none';
      if (qcAiModeBadgeText) qcAiModeBadgeText.textContent = '';
    }
  }

  // ─── Quick actions ───
  function _qcAiHandleQuickAction(action) {
    if (action === 'improve') {
      if (qcAiInput) {
        qcAiInput.value = '';
        qcAiInput.placeholder = 'Paste the text you want to improve...';
        qcAiInput.focus();
        qcAiInput.dataset.mode = 'improve';
      }
      _qcAiShowModeBadge('Improve mode');
      return;
    }
    if (action === 'summarize') {
      if (qcAiInput) {
        qcAiInput.value = '';
        qcAiInput.placeholder = 'Paste the text you want to summarize...';
        qcAiInput.focus();
        qcAiInput.dataset.mode = 'summarize';
      }
      _qcAiShowModeBadge('Summarize mode');
      return;
    }
    var prompt = _qcAiQuickPrompts[action];
    if (prompt) _qcAiRunChat(prompt);
  }

  // ─── Auto-resize textarea ───
  function _qcAiUpdateInputHeight() {
    if (!qcAiInput) return;
    qcAiInput.style.height = 'auto';
    qcAiInput.style.height = Math.min(qcAiInput.scrollHeight, 120) + 'px';
  }

  // ─── Event listeners ───
  if (qcAiSendBtn) {
    qcAiSendBtn.addEventListener('click', _qcAiSendMessage);
  }

  if (qcAiInput) {
    qcAiInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();
        _qcAiSendMessage();
      }
    });
    qcAiInput.addEventListener('input', function() {
      _qcAiUpdateInputHeight();
      if (qcAiSendBtn) qcAiSendBtn.disabled = !qcAiInput.value.trim() || _qcAiIsGenerating;
    });
  }

  if (qcAiStopBtn) {
    qcAiStopBtn.addEventListener('click', function() {
      if (_qcAiAbort) _qcAiAbort.stop();
    });
  }

  if (qcAiQuickActions) {
    qcAiQuickActions.addEventListener('click', function(e) {
      var btn = e.target.closest('.qc-ai-quick-btn');
      if (!btn) return;
      var action = btn.dataset.action;
      if (action) _qcAiHandleQuickAction(action);
    });
  }

  if (qcAiModeBadgeCancel) {
    qcAiModeBadgeCancel.addEventListener('click', function() {
      if (qcAiInput) {
        qcAiInput.dataset.mode = '';
        qcAiInput.placeholder = 'Ask me anything...';
        qcAiInput.focus();
      }
      _qcAiHideModeBadge();
    });
  }

  // ─── Voice input (Web Speech API) ───
  var _qcAiSpeechAPI = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (_qcAiSpeechAPI && qcAiMicBtn) {
    qcAiMicBtn.style.display = '';

    _qcAiRecognition = new _qcAiSpeechAPI();
    _qcAiRecognition.continuous = false;
    _qcAiRecognition.interimResults = true;
    _qcAiRecognition.lang = navigator.language || 'en-US';

    var _qcAiInterimStart = '';

    _qcAiRecognition.onstart = function() {
      _qcAiRecording = true;
      qcAiMicBtn.classList.add('recording');
      qcAiMicBtn.title = 'Stop recording';
      _qcAiInterimStart = qcAiInput ? qcAiInput.value : '';
    };

    _qcAiRecognition.onresult = function(event) {
      var interim = '';
      var final = '';
      for (var i = event.resultIndex; i < event.results.length; i++) {
        var transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          final += transcript;
        } else {
          interim += transcript;
        }
      }
      if (qcAiInput) {
        if (final) {
          var sep = _qcAiInterimStart && !_qcAiInterimStart.endsWith(' ') ? ' ' : '';
          _qcAiInterimStart += sep + final;
          qcAiInput.value = _qcAiInterimStart;
        } else if (interim) {
          var sep2 = _qcAiInterimStart && !_qcAiInterimStart.endsWith(' ') ? ' ' : '';
          qcAiInput.value = _qcAiInterimStart + sep2 + interim;
        }
        _qcAiUpdateInputHeight();
        if (qcAiSendBtn) qcAiSendBtn.disabled = !qcAiInput.value.trim() || _qcAiIsGenerating;
      }
    };

    _qcAiRecognition.onend = function() {
      _qcAiRecording = false;
      qcAiMicBtn.classList.remove('recording');
      qcAiMicBtn.title = 'Voice input';
      if (qcAiInput) qcAiInput.focus();
    };

    _qcAiRecognition.onerror = function(event) {
      _qcAiRecording = false;
      qcAiMicBtn.classList.remove('recording');
      qcAiMicBtn.title = 'Voice input';
      if (event.error !== 'aborted' && event.error !== 'no-speech') {
        console.warn('[QC AI] Speech recognition error:', event.error);
      }
    };

    qcAiMicBtn.addEventListener('click', function() {
      if (_qcAiRecording) {
        _qcAiRecognition.stop();
      } else {
        try { _qcAiRecognition.start(); } catch(e) { _qcAiRecognition.stop(); }
      }
    });
  }
})();
</script>

<!-- Landing page auth (garden-hero) -->
<script>
(function() {
  if (typeof firebase === 'undefined' || !window.dmAuth) return;

  var gardenSignin = document.getElementById('garden-signin');
  var gardenSignout = document.getElementById('garden-signout');
  var gardenAuthUser = document.getElementById('garden-auth-user');
  var gardenAvatar = document.getElementById('garden-auth-avatar');
  var gardenName = document.getElementById('garden-auth-name');

  // Only run on pages that have the landing page auth elements
  if (!gardenSignin) return;

  function subscribeGardenAuth() {
    window.dmAuth.onAuthStateChanged(function(user) {
      if (user) {
        gardenSignin.style.display = 'none';
        gardenAuthUser.style.display = '';
        gardenAvatar.src = user.photoURL || '';
        gardenAvatar.alt = user.displayName || '';
        gardenName.textContent = user.displayName || user.email || '';
      } else {
        gardenSignin.style.display = '';
        gardenAuthUser.style.display = 'none';
      }
    });
  }
  if (window.dmAuthReady) {
    window.dmAuthReady.then(subscribeGardenAuth);
  } else {
    subscribeGardenAuth();
  }

  gardenSignin.addEventListener('click', function() {
    window.dmSignIn();
  });

  gardenSignout.addEventListener('click', function() {
    window.dmAuth.signOut();
  });
})();
</script>

<!-- Dynamic sidebar: populates sidebar entries from IndexedDB cache -->
<script>
(function() {
  'use strict';

  var SIDEBAR_CACHE_KEY = 'dm-sidebar-html';
  var SIDEBAR_CACHE_VERSION_KEY = 'dm-sidebar-version';
  var SIDEBAR_VERSION = '{{ now.Unix }}'; // changes on each Hugo build

  // Immediately restore cached sidebar HTML to prevent flicker on navigation
  (function restoreSidebarCache() {
    try {
      // Invalidate cache if version changed (new deploy)
      var cachedVersion = sessionStorage.getItem(SIDEBAR_CACHE_VERSION_KEY);
      if (cachedVersion !== SIDEBAR_VERSION) {
        sessionStorage.removeItem(SIDEBAR_CACHE_KEY);
        sessionStorage.setItem(SIDEBAR_CACHE_VERSION_KEY, SIDEBAR_VERSION);
        return;
      }
      var cached = sessionStorage.getItem(SIDEBAR_CACHE_KEY);
      if (!cached) return;
      var menuNav = document.querySelector('.book-menu-content nav');
      if (!menuNav) return;
      var ul = menuNav.querySelector('ul');
      if (!ul) return;

      ul.innerHTML = cached;

      // Update active states to match current page
      var links = ul.querySelectorAll('a[href]');
      var pathname = window.location.pathname;
      var search = window.location.search;
      var params = new URLSearchParams(search);
      var viewId = params.get('id');
      links.forEach(function(a) {
        a.classList.remove('active');
        var href = a.getAttribute('href');
        if (!href) return;
        // Check if this is the current view page
        if (viewId && href.indexOf('id=' + viewId) !== -1) {
          a.classList.add('active');
        }
        // Check if this is the current section page
        else if (!viewId && (pathname === href || pathname === href.replace(/\/$/, ''))) {
          a.classList.add('active');
        }
      });

      // Also update inbox accent: only active when on inbox page
      var inboxItem = ul.querySelector('.sidebar-inbox');
      if (inboxItem) {
        var inboxLink = inboxItem.querySelector('a');
        if (inboxLink) {
          if (pathname.indexOf('/docs/inbox') !== -1) {
            inboxLink.classList.add('active');
          } else {
            inboxLink.classList.remove('active');
          }
        }
      }
    } catch (e) { /* sessionStorage may be unavailable */ }
  })();

  var ICONS = {
    books: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>',
    topics: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
    inbox: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path></svg>',
    snippets: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>',
    tags: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>',
    dashboard: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="3" width="7" height="7" rx="1"></rect><rect x="3" y="14" width="7" height="7" rx="1"></rect><rect x="14" y="14" width="7" height="7" rx="1"></rect></svg>',
    review: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 18V5"></path><path d="M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4"></path><path d="M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5"></path><path d="M17.997 5.125a4 4 0 0 1 2.526 5.77"></path><path d="M18 18a4 4 0 0 0 2-7.464"></path><path d="M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517"></path><path d="M6 18a4 4 0 0 1-2-7.464"></path><path d="M6.003 5.125a4 4 0 0 0-2.526 5.77"></path></svg>',
    ai: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275L21 12l-5.813 1.912a2 2 0 0 0-1.275 1.275L12 21l-1.912-5.813a2 2 0 0 0-1.275-1.275L3 12l5.813-1.912a2 2 0 0 0 1.275-1.275L12 3z"></path></svg>',
    trash: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>',
    settings: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1.08-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1.08 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1.08 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1.08z"></path></svg>'
  };

  function getBaseUrl() {
    var manifest = document.querySelector('link[rel="manifest"]');
    if (manifest) return manifest.getAttribute('href').replace('/manifest.json', '');
    return '';
  }

  function viewUrl(noteId) {
    return getBaseUrl() + '/docs/view/?id=' + encodeURIComponent(noteId);
  }

  function sectionUrl(section) {
    return getBaseUrl() + '/docs/' + section + '/';
  }

  function escapeHtml(text) {
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function randomId() {
    return 'dmsb-' + Math.random().toString(36).substr(2, 9);
  }

  // Check if current page matches a URL
  function isActive(url) {
    return window.location.pathname === url || window.location.pathname === url.replace(/\/$/, '');
  }

  function isViewPage(noteId) {
    var params = new URLSearchParams(window.location.search);
    return params.get('id') === noteId;
  }

  function buildSectionHtml(title, icon, sectionPath, children, isOpen) {
    var checkId = randomId();
    var checked = isOpen ? ' checked' : '';
    var html = '<li class="sidebar-section" data-section="' + escapeHtml(title.toLowerCase()) + '">';
    html += '<input type="checkbox" id="' + checkId + '" class="toggle"' + checked + ' />';
    html += '<label for="' + checkId + '" class="flex justify-between">';
    html += '<a href="' + sectionPath + '">' + icon + escapeHtml(title) + '</a>';
    html += '</label>';
    html += '<ul>' + children + '</ul>';
    html += '</li>';
    return html;
  }

  function buildNoteItem(note) {
    var active = isViewPage(note.id) ? ' class="active"' : '';
    return '<li class="sidebar-item" data-section="' + escapeHtml((note.title || '').toLowerCase()) + '">' +
      '<a href="' + viewUrl(note.id) + '"' + active + '>' + escapeHtml(note.title || 'Untitled') + '</a>' +
      '</li>';
  }

  function buildSubSection(title, notes, isOpen) {
    var checkId = randomId();
    var checked = isOpen ? ' checked' : '';
    var children = '';
    notes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.createdAt || 0) - (a.createdAt || 0);
    });
    notes.forEach(function(n) { children += buildNoteItem(n); });

    var html = '<li class="sidebar-section" data-section="' + escapeHtml(title.toLowerCase()) + '">';
    html += '<input type="checkbox" id="' + checkId + '" class="toggle"' + checked + ' />';
    html += '<label for="' + checkId + '" class="flex justify-between">';
    html += '<a role="button">' + escapeHtml(title) + '</a>';
    html += '</label>';
    html += '<ul>' + children + '</ul>';
    html += '</li>';
    return html;
  }

  function sortByCreatedAt(notes) {
    return notes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.createdAt || 0) - (a.createdAt || 0);
    });
  }

  var SIDEBAR_MAX = 10;

  function renderDynamicSidebar(allNotes, user) {
    var menuNav = document.querySelector('.book-menu-content nav');
    if (!menuNav) return;

    // Find the existing <ul> that contains sections
    var existingUl = menuNav.querySelector('ul');
    if (!existingUl) return;

    // Categorize notes (inbox excluded — it's a single scrollable page)
    var bookNotes = {};      // grouped by bookTitle
    var topicNotes = [];
    var snippetNotes = {};   // grouped by language

    allNotes.forEach(function(n) {
      if (n.destination === 'book-note') {
        var bt = n.bookTitle || 'Uncategorized';
        if (!bookNotes[bt]) bookNotes[bt] = [];
        bookNotes[bt].push(n);
      } else if (n.destination === 'topic') {
        topicNotes.push(n);
      } else if (n.destination === 'snippets') {
        var lang = n.language || 'other';
        if (!snippetNotes[lang]) snippetNotes[lang] = [];
        snippetNotes[lang].push(n);
      }
    });

    // Check which note is currently being viewed
    var currentNoteId = new URLSearchParams(window.location.search).get('id');
    var currentNote = currentNoteId ? allNotes.find(function(n) { return n.id === currentNoteId; }) : null;

    // Build Books section — flat list, one entry per book (no sub-grouping)
    var booksChildren = '';
    // Flatten all book notes, sorted by most recently updated
    var allBookNotes = [];
    Object.keys(bookNotes).sort().forEach(function(bt) {
      sortByCreatedAt(bookNotes[bt]);
      bookNotes[bt].forEach(function(n) { allBookNotes.push(n); });
    });
    allBookNotes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0);
    });
    var shownBooks = allBookNotes.slice(0, SIDEBAR_MAX);
    shownBooks.forEach(function(n) { booksChildren += buildNoteItem(n); });
    if (allBookNotes.length > SIDEBAR_MAX) {
      booksChildren += '<li class="sidebar-item sidebar-viewall"><a href="' + sectionUrl('books') + '">View all ' + allBookNotes.length + '</a></li>';
    }

    // Build Topics section
    var topicsChildren = '';
    sortByCreatedAt(topicNotes);
    var shownTopics = topicNotes.slice(0, SIDEBAR_MAX);
    shownTopics.forEach(function(n) { topicsChildren += buildNoteItem(n); });
    if (topicNotes.length > SIDEBAR_MAX) {
      topicsChildren += '<li class="sidebar-item sidebar-viewall"><a href="' + sectionUrl('topics') + '">View all ' + topicNotes.length + '</a></li>';
    }

    // Build Inbox section — no children, inbox is a single scrollable page
    var inboxActive = window.location.pathname.indexOf('/docs/inbox') !== -1 ? ' class="active"' : '';

    // Build Snippets section — sub-sections by language, each limited to top 10
    var snippetsChildren = '';
    Object.keys(snippetNotes).sort().forEach(function(lang) {
      var langTitle = lang.charAt(0).toUpperCase() + lang.slice(1);
      var subOpen = currentNote && currentNote.language === lang;
      var langNotes = snippetNotes[lang];
      langNotes.sort(function(a, b) {
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;
        return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0);
      });
      snippetsChildren += buildSubSection(langTitle, langNotes.slice(0, SIDEBAR_MAX), subOpen);
    });

    // All sections expanded by default
    var booksOpen = true;
    var topicsOpen = true;
    var snippetsOpen = true;

    // Build the full sidebar HTML
    var html = '';
    // Inbox first — accented, single page, no sub-entries
    html += '<li class="sidebar-item sidebar-inbox" data-section="inbox">' +
      '<a href="' + sectionUrl('inbox') + '"' + inboxActive + '>' + ICONS.inbox + 'Inbox</a>' +
      '</li>';
    html += buildSectionHtml('Books', ICONS.books, sectionUrl('books'), booksChildren, booksOpen);
    html += buildSectionHtml('Topics', ICONS.topics, sectionUrl('topics'), topicsChildren, topicsOpen);
    html += buildSectionHtml('Snippets', ICONS.snippets, sectionUrl('snippets'), snippetsChildren, snippetsOpen);

    // Add Tags entry (static)
    var tagsActive = window.location.pathname.indexOf('/docs/tags') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="tags">' +
      '<a href="' + sectionUrl('tags') + '"' + tagsActive + '>' + ICONS.tags + 'Tags</a>' +
      '</li>';

    // Add Review entry (static)
    var reviewActive = window.location.pathname.indexOf('/docs/review') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="review">' +
      '<a href="' + sectionUrl('review') + '"' + reviewActive + '>' + ICONS.review + 'Review</a>' +
      '</li>';

    // Add Dashboard entry (static)
    var dashboardActive = window.location.pathname.indexOf('/docs/dashboard') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="dashboard">' +
      '<a href="' + sectionUrl('dashboard') + '"' + dashboardActive + '>' + ICONS.dashboard + 'Dashboard</a>' +
      '</li>';

    // Add AI entry (static)
    var aiActive = window.location.pathname.indexOf('/docs/ai') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item sidebar-ai" data-section="ai">' +
      '<a href="' + sectionUrl('ai') + '"' + aiActive + '>' + ICONS.ai + 'AI</a>' +
      '</li>';

    // Add Trash entry (static)
    var trashActive = window.location.pathname.indexOf('/docs/trash') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item sidebar-trash" data-section="trash">' +
      '<a href="' + sectionUrl('trash') + '"' + trashActive + '>' + ICONS.trash + 'Trash</a>' +
      '</li>';

    // Replace sidebar content
    existingUl.innerHTML = html;

    // Build settings footer at bottom of sidebar (outside nav, inside .book-menu-content)
    var menuContent = document.querySelector('.book-menu-content');
    if (menuContent) {
      // Remove existing settings footer if present (re-render safe)
      var existingFooter = menuContent.querySelector('.sidebar-settings-footer');
      if (existingFooter) existingFooter.remove();

      var avatarSrc = (user && user.photoURL) ? user.photoURL : '';
      var userName = (user && (user.displayName || user.email)) || '';
      var avatarHtml = avatarSrc
        ? '<img class="sidebar-settings-avatar" src="' + avatarSrc + '" alt="' + escapeHtml(userName) + '" referrerpolicy="no-referrer">'
        : '<svg class="sidebar-settings-avatar-fallback" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>';

      var footer = document.createElement('div');
      footer.className = 'sidebar-settings-footer';
      footer.innerHTML =
        '<div class="sidebar-settings-panel" id="sidebar-settings-panel" style="display:none;">' +
          '<div class="sidebar-settings-group-label">Short session</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-pomo-short-work">Work</label>' +
            '<div class="sidebar-settings-control">' +
              '<input type="number" id="setting-pomo-short-work" class="sidebar-settings-input" min="1" max="120" value="25">' +
              '<span class="sidebar-settings-unit">min</span>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-pomo-short-break">Break</label>' +
            '<div class="sidebar-settings-control">' +
              '<input type="number" id="setting-pomo-short-break" class="sidebar-settings-input" min="1" max="60" value="5">' +
              '<span class="sidebar-settings-unit">min</span>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-group-label" style="margin-top:4px;">Long session</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-pomo-long-work">Work</label>' +
            '<div class="sidebar-settings-control">' +
              '<input type="number" id="setting-pomo-long-work" class="sidebar-settings-input" min="1" max="120" value="50">' +
              '<span class="sidebar-settings-unit">min</span>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-pomo-long-break">Break</label>' +
            '<div class="sidebar-settings-control">' +
              '<input type="number" id="setting-pomo-long-break" class="sidebar-settings-input" min="1" max="60" value="10">' +
              '<span class="sidebar-settings-unit">min</span>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-pomo-count">Default pomodoros</label>' +
            '<div class="sidebar-settings-control">' +
              '<input type="number" id="setting-pomo-count" class="sidebar-settings-input" min="0" max="20" value="1">' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-auto-schedule">Auto-schedule today</label>' +
            '<div class="sidebar-settings-control">' +
              '<label class="sidebar-settings-toggle-switch">' +
                '<input type="checkbox" id="setting-auto-schedule" checked>' +
                '<span class="sidebar-settings-toggle-slider"></span>' +
              '</label>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-group-label" style="margin-top:4px;">Sounds</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-sound-work">Work end</label>' +
            '<div class="sidebar-settings-control">' +
              '<select id="setting-sound-work" class="sidebar-settings-select">' +
                '<option value="chime">Chime</option>' +
                '<option value="bell">Bell</option>' +
                '<option value="digital">Digital</option>' +
                '<option value="bowl">Singing bowl</option>' +
                '<option value="ascending">Ascending</option>' +
                '<option value="pulse">Soft pulse</option>' +
                '<option value="none">None</option>' +
              '</select>' +
              '<button type="button" class="sidebar-settings-preview" data-sound-select="setting-sound-work" title="Preview">' +
                '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>' +
              '</button>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-sound-break">Break end</label>' +
            '<div class="sidebar-settings-control">' +
              '<select id="setting-sound-break" class="sidebar-settings-select">' +
                '<option value="chime">Chime</option>' +
                '<option value="bell">Bell</option>' +
                '<option value="digital">Digital</option>' +
                '<option value="bowl">Singing bowl</option>' +
                '<option value="ascending">Ascending</option>' +
                '<option value="pulse">Soft pulse</option>' +
                '<option value="none">None</option>' +
              '</select>' +
              '<button type="button" class="sidebar-settings-preview" data-sound-select="setting-sound-break" title="Preview">' +
                '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>' +
              '</button>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-sound-tick">Tick</label>' +
            '<div class="sidebar-settings-control">' +
              '<select id="setting-sound-tick" class="sidebar-settings-select">' +
                '<option value="none">None</option>' +
                '<option value="tick-soft">Soft tick</option>' +
                '<option value="tick-click">Click</option>' +
                '<option value="tick-woodblock">Woodblock</option>' +
              '</select>' +
              '<button type="button" class="sidebar-settings-preview" data-sound-select="setting-sound-tick" title="Preview">' +
                '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>' +
              '</button>' +
            '</div>' +
          '</div>' +
          '<div class="sidebar-settings-row">' +
            '<label class="sidebar-settings-label" for="setting-sound-volume">Volume</label>' +
            '<div class="sidebar-settings-control sidebar-settings-volume-control">' +
              '<input type="range" id="setting-sound-volume" class="sidebar-settings-range" min="0" max="100" value="80" step="5">' +
              '<span class="sidebar-settings-unit" id="setting-sound-volume-label">80%</span>' +
            '</div>' +
          '</div>' +
        '</div>' +
        '<div class="sidebar-settings-trigger" id="sidebar-settings-toggle">' +
          avatarHtml +
          '<span class="sidebar-settings-name">' + escapeHtml(userName) + '</span>' +
          ICONS.settings +
        '</div>';
      menuContent.appendChild(footer);
    }

    // Initialize settings panel interactions
    initSettingsPanel();

    // Cache sidebar HTML for instant restore on next navigation
    try { sessionStorage.setItem(SIDEBAR_CACHE_KEY, html); } catch (e) {}
  }

  // ─── Settings panel logic ───
  function initSettingsPanel() {
    var toggle = document.getElementById('sidebar-settings-toggle');
    var panel = document.getElementById('sidebar-settings-panel');
    if (!toggle || !panel) return;

    // ─── Migrate old single-key format ───
    var oldLen = null;
    try { var v = parseInt(localStorage.getItem('dm-pomodoro-length'), 10); if (v > 0) oldLen = v; } catch(e) {}
    if (oldLen) {
      // Use old value as the short-work default if no short-work key exists yet
      try { if (!localStorage.getItem('dm-pomo-short-work')) localStorage.setItem('dm-pomo-short-work', oldLen); } catch(e) {}
      try { localStorage.removeItem('dm-pomodoro-length'); } catch(e) {}
    }

    // ─── Read all mode values from localStorage ───
    var shortWork = 25;
    try { var v = parseInt(localStorage.getItem('dm-pomo-short-work'), 10); if (v > 0) shortWork = v; } catch(e) {}
    var shortBreak = 5;
    try { var v = parseInt(localStorage.getItem('dm-pomo-short-break'), 10); if (v > 0) shortBreak = v; } catch(e) {}
    var longWork = 50;
    try { var v = parseInt(localStorage.getItem('dm-pomo-long-work'), 10); if (v > 0) longWork = v; } catch(e) {}
    var longBreak = 10;
    try { var v = parseInt(localStorage.getItem('dm-pomo-long-break'), 10); if (v > 0) longBreak = v; } catch(e) {}

    var defaultPomoCount = 1;
    try { var v = parseInt(localStorage.getItem('dm-default-pomo-count'), 10); if (v >= 0) defaultPomoCount = v; } catch(e) {}

    var autoSchedule = true;
    try { var v = localStorage.getItem('dm-auto-schedule-today'); if (v === 'false') autoSchedule = false; } catch(e) {}

    var shortWorkInput = document.getElementById('setting-pomo-short-work');
    var shortBreakInput = document.getElementById('setting-pomo-short-break');
    var longWorkInput = document.getElementById('setting-pomo-long-work');
    var longBreakInput = document.getElementById('setting-pomo-long-break');
    var countInput = document.getElementById('setting-pomo-count');
    var scheduleToggle = document.getElementById('setting-auto-schedule');

    if (shortWorkInput) shortWorkInput.value = shortWork;
    if (shortBreakInput) shortBreakInput.value = shortBreak;
    if (longWorkInput) longWorkInput.value = longWork;
    if (longBreakInput) longBreakInput.value = longBreak;
    if (countInput) countInput.value = defaultPomoCount;
    if (scheduleToggle) scheduleToggle.checked = autoSchedule;

    // Toggle panel visibility
    toggle.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      panel.style.display = panel.style.display === 'none' ? '' : 'none';
    });

    // Helper: save a numeric setting on change
    function bindNumericSetting(inputEl, lsKey, min, max, fallback) {
      if (!inputEl) return;
      inputEl.addEventListener('change', function() {
        var val = parseInt(inputEl.value, 10);
        if (val >= min && val <= max) {
          try { localStorage.setItem(lsKey, val); } catch(e) {}
          window.dispatchEvent(new CustomEvent('dm-settings-changed', { detail: { key: lsKey, value: val } }));
        } else {
          inputEl.value = fallback;
        }
      });
    }

    bindNumericSetting(shortWorkInput, 'dm-pomo-short-work', 1, 120, shortWork);
    bindNumericSetting(shortBreakInput, 'dm-pomo-short-break', 1, 60, shortBreak);
    bindNumericSetting(longWorkInput, 'dm-pomo-long-work', 1, 120, longWork);
    bindNumericSetting(longBreakInput, 'dm-pomo-long-break', 1, 60, longBreak);

    // Save on change — Default Pomodoro count
    if (countInput) {
      countInput.addEventListener('change', function() {
        var val = parseInt(countInput.value, 10);
        if (val >= 0 && val <= 20) {
          try { localStorage.setItem('dm-default-pomo-count', val); } catch(e) {}
          window.dispatchEvent(new CustomEvent('dm-settings-changed', { detail: { key: 'dm-default-pomo-count', value: val } }));
        } else {
          countInput.value = defaultPomoCount;
        }
      });
    }

    // Save on change — Auto-schedule today
    if (scheduleToggle) {
      scheduleToggle.addEventListener('change', function() {
        var val = scheduleToggle.checked;
        try { localStorage.setItem('dm-auto-schedule-today', val ? 'true' : 'false'); } catch(e) {}
        window.dispatchEvent(new CustomEvent('dm-settings-changed', { detail: { key: 'dm-auto-schedule-today', value: val } }));
      });
    }

    // ─── Sound settings ───
    var soundWorkSelect = document.getElementById('setting-sound-work');
    var soundBreakSelect = document.getElementById('setting-sound-break');
    var soundTickSelect = document.getElementById('setting-sound-tick');
    var soundVolumeRange = document.getElementById('setting-sound-volume');
    var soundVolumeLabel = document.getElementById('setting-sound-volume-label');

    // Read saved values
    var savedWorkSound = 'chime';
    try { var v = localStorage.getItem('dm-pomo-sound-work'); if (v) savedWorkSound = v; } catch(e) {}
    var savedBreakSound = 'chime';
    try { var v = localStorage.getItem('dm-pomo-sound-break'); if (v) savedBreakSound = v; } catch(e) {}
    var savedTickSound = 'none';
    try { var v = localStorage.getItem('dm-pomo-sound-tick'); if (v) savedTickSound = v; } catch(e) {}
    var savedVolume = 80;
    try { var v = parseFloat(localStorage.getItem('dm-pomo-sound-volume')); if (v >= 0 && v <= 1) savedVolume = Math.round(v * 100); } catch(e) {}

    if (soundWorkSelect) soundWorkSelect.value = savedWorkSound;
    if (soundBreakSelect) soundBreakSelect.value = savedBreakSound;
    if (soundTickSelect) soundTickSelect.value = savedTickSound;
    if (soundVolumeRange) soundVolumeRange.value = savedVolume;
    if (soundVolumeLabel) soundVolumeLabel.textContent = savedVolume + '%';

    // Helper: bind a select sound setting
    function bindSoundSelect(selectEl, lsKey) {
      if (!selectEl) return;
      selectEl.addEventListener('change', function() {
        var val = selectEl.value;
        try { localStorage.setItem(lsKey, val); } catch(e) {}
        window.dispatchEvent(new CustomEvent('dm-settings-changed', { detail: { key: lsKey, value: val } }));
      });
    }

    bindSoundSelect(soundWorkSelect, 'dm-pomo-sound-work');
    bindSoundSelect(soundBreakSelect, 'dm-pomo-sound-break');
    bindSoundSelect(soundTickSelect, 'dm-pomo-sound-tick');

    // Volume slider
    if (soundVolumeRange) {
      soundVolumeRange.addEventListener('input', function() {
        var pct = parseInt(soundVolumeRange.value, 10);
        if (soundVolumeLabel) soundVolumeLabel.textContent = pct + '%';
        var vol = pct / 100;
        try { localStorage.setItem('dm-pomo-sound-volume', vol); } catch(e) {}
        window.dispatchEvent(new CustomEvent('dm-settings-changed', { detail: { key: 'dm-pomo-sound-volume', value: vol } }));
      });
    }

    // Preview buttons
    var previewBtns = panel.querySelectorAll('.sidebar-settings-preview');
    previewBtns.forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        var selectId = btn.getAttribute('data-sound-select');
        var selectEl = document.getElementById(selectId);
        if (!selectEl) return;
        var soundId = selectEl.value;
        if (window.dmSounds && soundId && soundId !== 'none') {
          var vol = soundVolumeRange ? parseInt(soundVolumeRange.value, 10) / 100 : 0.8;
          window.dmSounds.play(soundId, vol);
        }
      });
    });
  }

  function renderAuthPrompt() {
    var menuNav = document.querySelector('.book-menu-content nav');
    if (!menuNav) return;

    var existingUl = menuNav.querySelector('ul');
    if (!existingUl) return;

    // Remove settings footer on sign-out
    var menuContent = document.querySelector('.book-menu-content');
    if (menuContent) {
      var existingFooter = menuContent.querySelector('.sidebar-settings-footer');
      if (existingFooter) existingFooter.remove();
    }

    // Clear cached sidebar since user signed out
    try { sessionStorage.removeItem(SIDEBAR_CACHE_KEY); } catch (e) {}

    var base = getBaseUrl();
    var html = '';

    // Show section headers without children
    html += buildSectionHtml('Books', ICONS.books, sectionUrl('books'), '', false);
    html += buildSectionHtml('Topics', ICONS.topics, sectionUrl('topics'), '', false);
    // Inbox: simple link, no sub-entries
    html += '<li class="sidebar-item" data-section="inbox">' +
      '<a href="' + sectionUrl('inbox') + '">' + ICONS.inbox + 'Inbox</a>' +
      '</li>';
    html += buildSectionHtml('Snippets', ICONS.snippets, sectionUrl('snippets'), '', false);

    var tagsActive = window.location.pathname.indexOf('/docs/tags') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="tags">' +
      '<a href="' + sectionUrl('tags') + '"' + tagsActive + '>' + ICONS.tags + 'Tags</a>' +
      '</li>';

    var reviewActive = window.location.pathname.indexOf('/docs/review') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="review">' +
      '<a href="' + sectionUrl('review') + '"' + reviewActive + '>' + ICONS.review + 'Review</a>' +
      '</li>';

    var dashboardActive = window.location.pathname.indexOf('/docs/dashboard') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="dashboard">' +
      '<a href="' + sectionUrl('dashboard') + '"' + dashboardActive + '>' + ICONS.dashboard + 'Dashboard</a>' +
      '</li>';

    var aiActive = window.location.pathname.indexOf('/docs/ai') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item sidebar-ai" data-section="ai">' +
      '<a href="' + sectionUrl('ai') + '"' + aiActive + '>' + ICONS.ai + 'AI</a>' +
      '</li>';

    existingUl.innerHTML = html;
  }

  // Listen for sync completion
  var _sidebarUser = null; // cached user for re-renders
  window.addEventListener('dm-sync-complete', function() {
    if (!window.dmSync) return;
    window.dmSync.getAllNotes().then(function(notes) {
      if (notes.length > 0) {
        renderDynamicSidebar(notes, _sidebarUser);
      }
    });
  });

  // Auth state change
  if (window.dmAuth) {
    function subscribeDynSidebarAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        if (user) {
          _sidebarUser = user;
          // Try to render from cache immediately
          if (window.dmSync) {
            window.dmSync.getAllNotes().then(function(notes) {
              if (notes.length > 0) {
                renderDynamicSidebar(notes, user);
              }
              // Sync will fire dm-sync-complete which will re-render
            });
          }
        } else {
          _sidebarUser = null;
          renderAuthPrompt();
        }
      });
    }
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeDynSidebarAuth);
    } else {
      subscribeDynSidebarAuth();
    }
  }
})();
</script>

<!-- Sidebar review due-count badge -->
<script>
(function() {
  'use strict';

  function updateReviewBadge() {
    if (!window.dmSync || !window.dmSync.getDueCount) return;
    window.dmSync.getDueCount().then(function(count) {
      var link = document.querySelector('[data-section="review"] a');
      if (!link) return;

      var badge = link.querySelector('.review-due-badge');
      if (count > 0) {
        if (!badge) {
          badge = document.createElement('span');
          badge.className = 'review-due-badge';
          link.appendChild(badge);
        }
        badge.textContent = count > 99 ? '99+' : count;
      } else if (badge) {
        badge.remove();
      }
    });
  }

  // Update on sync complete and review changes
  window.addEventListener('dm-sync-complete', updateReviewBadge);
  window.addEventListener('dm-review-updated', updateReviewBadge);

  // Initial update after auth settles
  if (window.dmAuth) {
    function subscribeBadgeAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        if (user) {
          // Small delay to ensure sidebar has rendered
          setTimeout(updateReviewBadge, 500);
        }
      });
    }
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeBadgeAuth);
    } else {
      subscribeBadgeAuth();
    }
  }
})();
</script>

<!-- Dynamic ToC builder + scroll spy -->
<script>
(function() {
  'use strict';

  var toc = document.querySelector('.book-toc');
  if (!toc) return;

  var tocContent = toc.querySelector('.book-toc-content');
  if (!tocContent) return;

  var progressBar = document.getElementById('toc-progress-bar');
  var rafId = null;
  var headingMap = [];
  var tocLinks = [];

  // Slugify heading text to create IDs
  function slugify(text) {
    return text.toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  // Build ToC from rendered DOM headings
  function buildDynamicToc() {
    // Find the content area where marked.js renders
    var contentArea = document.querySelector('.note-viewer-body') ||
                      document.querySelector('.single-note-body') ||
                      document.querySelector('.section-notes-list') ||
                      document.querySelector('article.markdown');
    if (!contentArea) return;

    var headings = contentArea.querySelectorAll('h1, h2, h3, h4');
    if (headings.length < 2) {
      toc.style.display = 'none';
      return;
    }

    // Ensure headings have IDs (deduplicate slugs)
    var usedIds = {};
    headings.forEach(function(h) {
      if (!h.id) {
        var base = slugify(h.textContent);
        if (!base) base = 'heading';
        var id = base;
        if (usedIds[id]) {
          var n = 1;
          while (usedIds[id + '-' + n]) n++;
          id = id + '-' + n;
        }
        usedIds[id] = true;
        h.id = id;
      } else {
        usedIds[h.id] = true;
      }
    });

    // Determine the minimum heading level present
    var minLevel = 6;
    headings.forEach(function(h) {
      var level = parseInt(h.tagName.charAt(1));
      if (level < minLevel) minLevel = level;
    });

    // Build nested list HTML
    var html = '<nav id="TableOfContents"><ul>';
    var prevLevel = minLevel;

    headings.forEach(function(h) {
      var level = parseInt(h.tagName.charAt(1));
      var text = h.textContent;
      var id = h.id;

      // Handle nesting
      if (level > prevLevel) {
        for (var i = 0; i < level - prevLevel; i++) {
          html += '<ul>';
        }
      } else if (level < prevLevel) {
        for (var i = 0; i < prevLevel - level; i++) {
          html += '</li></ul>';
        }
        html += '</li>';
      } else if (html !== '<nav id="TableOfContents"><ul>') {
        html += '</li>';
      }

      html += '<li><a href="#' + id + '">' + text + '</a>';
      prevLevel = level;
    });

    // Close remaining tags
    for (var i = 0; i < prevLevel - minLevel; i++) {
      html += '</li></ul>';
    }
    html += '</li></ul></nav>';

    // Inject into ToC container (after progress bar and header)
    var existingNav = tocContent.querySelector('nav#TableOfContents');
    if (existingNav) {
      existingNav.remove();
    }
    tocContent.insertAdjacentHTML('beforeend', html);

    toc.style.display = '';

    // Re-initialize scroll spy
    initScrollSpy();
  }

  function initScrollSpy() {
    headingMap = [];
    var tocNav = tocContent.querySelector('nav#TableOfContents');
    tocLinks = tocNav ? Array.from(tocNav.querySelectorAll('a')) : [];

    if (tocLinks.length < 2) {
      toc.style.display = 'none';
      return;
    }

    tocLinks.forEach(function(link) {
      var href = link.getAttribute('href');
      if (!href || href.charAt(0) !== '#') return;
      var id = decodeURIComponent(href.substring(1));
      var heading = document.getElementById(id);
      if (heading) {
        headingMap.push({ el: heading, link: link });
      }
    });

    if (!headingMap.length) return;
    // Defer initial highlight so the browser has computed layout positions
    requestAnimationFrame(function() {
      requestAnimationFrame(update);
    });
  }

  function update() {
    rafId = null;

    // Reading progress
    if (progressBar) {
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      var docHeight = document.documentElement.scrollHeight - window.innerHeight;
      var progress = docHeight > 0 ? Math.min(scrollTop / docHeight, 1) : 0;
      progressBar.style.setProperty('--progress', (progress * 100) + '%');
    }

    // Scroll spy — find the heading closest to (but above) the current scroll position
    var scrollPos = window.scrollY || document.documentElement.scrollTop;
    var offset = 80;
    var activeHeading = null;

    // If at or near the top of the page, always highlight the first heading
    if (scrollPos <= offset) {
      activeHeading = headingMap.length > 0 ? headingMap[0] : null;
    } else {
      for (var i = headingMap.length - 1; i >= 0; i--) {
        if (headingMap[i].el.offsetTop <= scrollPos + offset) {
          activeHeading = headingMap[i];
          break;
        }
      }

      if (!activeHeading && headingMap.length > 0) {
        activeHeading = headingMap[0];
      }
    }

    tocLinks.forEach(function(link) {
      link.classList.remove('active');
      link.parentElement.classList.remove('toc-active');
    });

    if (activeHeading) {
      activeHeading.link.classList.add('active');
      activeHeading.link.parentElement.classList.add('toc-active');
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = requestAnimationFrame(update);
    }
  }

  window.addEventListener('scroll', onScroll, { passive: true });

  // Listen for dynamically rendered content
  window.addEventListener('dm-content-rendered', function() {
    buildDynamicToc();
  });

  // Also try building from Hugo's static ToC on page load
  var existingNav = tocContent.querySelector('nav#TableOfContents');
  var existingLinks = existingNav ? existingNav.querySelectorAll('a') : [];
  if (existingLinks.length >= 2) {
    initScrollSpy();
  } else {
    // No static ToC — hide until dynamic content arrives
    toc.style.display = 'none';
  }
})();
</script>

