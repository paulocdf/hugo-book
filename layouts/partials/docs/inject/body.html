<!-- Theme toggle button -->
<button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme" title="Toggle light/dark theme">
  <svg class="theme-icon theme-icon--sun" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="theme-icon theme-icon--moon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>

<script>
(function() {
  var toggle = document.getElementById('theme-toggle');
  if (!toggle) return;

  function getEffectiveTheme() {
    var saved = localStorage.getItem('dm-theme');
    if (saved === 'light' || saved === 'dark') return saved;
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }

  function applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('dm-theme', theme);
    updateMeta(theme);
  }

  function updateMeta(theme) {
    var meta = document.querySelector('meta[name="theme-color"]');
    if (meta) meta.setAttribute('content', theme === 'dark' ? '#161921' : '#ffffff');
    var cs = document.querySelector('meta[name="color-scheme"]');
    if (cs) cs.setAttribute('content', theme);
  }

  // Set initial state
  var current = getEffectiveTheme();
  document.documentElement.setAttribute('data-theme', current);
  updateMeta(current);

  toggle.addEventListener('click', function() {
    var now = getEffectiveTheme();
    var next = now === 'dark' ? 'light' : 'dark';
    applyTheme(next);
  });

  // Listen for OS theme changes (only if user hasn't overridden)
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
    if (!localStorage.getItem('dm-theme')) {
      var theme = e.matches ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', theme);
      updateMeta(theme);
    }
  });
})();
</script>

<!-- Sidebar collapse/expand toggle -->
<script>
(function() {
  var toggle = document.getElementById('sidebar-toggle');
  if (!toggle) return;

  function isCollapsed() {
    return document.documentElement.classList.contains('sidebar-collapsed');
  }

  function setSidebar(collapsed) {
    if (collapsed) {
      document.documentElement.classList.add('sidebar-collapsed');
      toggle.setAttribute('aria-label', 'Expand sidebar');
    } else {
      document.documentElement.classList.remove('sidebar-collapsed');
      toggle.setAttribute('aria-label', 'Collapse sidebar');
    }
    try { localStorage.setItem('dm-sidebar-collapsed', collapsed ? '1' : '0'); } catch(e) {}
  }

  toggle.addEventListener('click', function() {
    setSidebar(!isCollapsed());
  });

  // Keyboard shortcut: [ to toggle sidebar
  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
    if (e.key === '[' && !e.ctrlKey && !e.metaKey && !e.altKey) {
      e.preventDefault();
      setSidebar(!isCollapsed());
    }
  });
})();
</script>

<!-- Quick Capture FAB (Floating Action Button) -->
<button class="quick-capture-fab" id="quick-capture-btn" aria-label="Quick Capture (E)" title="Quick Capture">
  <svg class="fab-icon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 20h9"></path>
    <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
  </svg>
  <span class="fab-tooltip">Quick Capture <kbd>E</kbd></span>
</button>

{{ partial "quick-capture-modal.html" . }}

{{ partial "note-edit-modal" . }}

{{ partial "version-history-modal" . }}

{{ partial "search-modal.html" . }}

{{ partial "todo-complete-modal.html" . }}

{{ partial "pomodoro-timer.html" . }}

{{ partial "keyboard-shortcuts.html" . }}

<!-- Quick Capture modal logic -->
<script>
(function() {
  var btn = document.getElementById('quick-capture-btn');
  var modal = document.getElementById('quick-capture-modal');
  if (!modal) return;

  var backdrop = document.getElementById('quick-capture-backdrop');
  var input = document.getElementById('quick-capture-input');
  var titleInput = document.getElementById('qc-title-input');
  var cancelBtn = document.getElementById('qc-cancel');
  var submitBtn = document.getElementById('qc-submit');
  var destButtons = document.querySelectorAll('.qc-dest-btn');
  var modeButtons = document.querySelectorAll('.qc-mode-btn');
  var langButtons = document.querySelectorAll('.qc-lang-btn');
  var destRow = document.getElementById('qc-destination-row');
  var langRow = document.getElementById('qc-language-row');
  var bookTitleRow = document.getElementById('qc-book-title-row');
  var bookTitleInput = document.getElementById('qc-book-title-input');
  var bookTitleDatalist = document.getElementById('qc-book-title-list');
  var inboxNewBtn = document.getElementById('qc-inbox-new-btn');
  var previewWrapper = document.getElementById('qc-preview-wrapper');
  var previewPanel = document.getElementById('qc-preview-panel');
  var notePreviewWrapper = document.getElementById('qc-note-preview-wrapper');
  var notePreviewPanel = document.getElementById('qc-note-preview-panel');
  var dialog = modal.querySelector('.quick-capture-dialog');
  var toolbar = document.getElementById('qc-toolbar');
  var toolbarButtons = toolbar ? toolbar.querySelectorAll('.qc-toolbar-btn') : [];

  // Auth elements
  var signinBtn = document.getElementById('qc-signin');
  var signoutBtn = document.getElementById('qc-signout');
  var authUserEl = document.getElementById('qc-auth-user');
  var authAvatarEl = document.getElementById('qc-auth-avatar');
  var authNameEl = document.getElementById('qc-auth-name');

  // Feedback elements
  var feedbackEl = document.getElementById('qc-feedback');
  var feedbackIconEl = document.getElementById('qc-feedback-icon');
  var feedbackTextEl = document.getElementById('qc-feedback-text');

  // Todo mode elements
  var todoFieldsEl = document.getElementById('qc-todo-fields');
  var todoTitleInput = document.getElementById('qc-todo-title');
  var todoEstimateInput = document.getElementById('qc-todo-estimate');
  var todoDateBtn = document.getElementById('qc-todo-date-btn');
  var todoDateChip = document.getElementById('qc-todo-date-chip');
  var todoDateChipText = document.getElementById('qc-todo-date-chip-text');
  var todoDateClear = document.getElementById('qc-todo-date-clear');
  var todoReminderBtn = document.getElementById('qc-todo-reminder-btn');
  var todoReminderChip = document.getElementById('qc-todo-reminder-chip');
  var todoReminderChipText = document.getElementById('qc-todo-reminder-chip-text');
  var todoReminderClear = document.getElementById('qc-todo-reminder-clear');

  // State
  var currentMode = 'note'; // 'note', 'code', or 'todo'
  var selectedLang = 'kotlin';
  var inboxMode = 'append'; // 'append' or 'new'
  var selectedDest = {
    path: 'content/docs/inbox',
    tag: 'inbox'
  };
  var previewTimer = null;
  var isSaving = false;

  // Todo mode state
  var _qcTodoDate = null; // YYYY-MM-DD string
  var _qcTodoReminderMs = null; // timestamp in ms
  var _qcTodoPopover = null; // currently open popover element

  // =========================================================================
  // Firebase Auth
  // =========================================================================
  function updateAuthUI(user) {
    if (user) {
      signinBtn.style.display = 'none';
      authUserEl.style.display = '';
      authAvatarEl.src = user.photoURL || '';
      authAvatarEl.alt = user.displayName || '';
      authNameEl.textContent = user.displayName || user.email || '';
    } else {
      signinBtn.style.display = '';
      authUserEl.style.display = 'none';
    }
  }

  // Listen for auth state changes
  if (window.dmAuth) {
    function subscribeSidebarAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        updateAuthUI(user);
      });
    }
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeSidebarAuth);
    } else {
      subscribeSidebarAuth();
    }
  }

  if (signinBtn) {
    signinBtn.addEventListener('click', function() {
      if (!window.dmAuth || !window.dmGoogleProvider) return;
      if (window.dmIsLocalhost) {
        window.dmAuth.signInWithRedirect(window.dmGoogleProvider);
      } else {
        window.dmAuth.signInWithPopup(window.dmGoogleProvider).catch(function(err) {
          console.error('Sign-in error:', err);
          showFeedback('error', 'Sign-in failed. Please try again.');
        });
      }
    });
  }

  if (signoutBtn) {
    signoutBtn.addEventListener('click', function() {
      if (window.dmAuth) window.dmAuth.signOut();
    });
  }

  // =========================================================================
  // Feedback (success / error overlay)
  // =========================================================================
  function showFeedback(type, message) {
    if (!feedbackEl) return;
    feedbackEl.className = 'qc-feedback qc-feedback--' + type;
    feedbackEl.style.display = '';

    if (type === 'success') {
      feedbackIconEl.innerHTML = '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
    } else {
      feedbackIconEl.innerHTML = '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
    }
    feedbackTextEl.textContent = message;

    if (type === 'success') {
      setTimeout(function() {
        feedbackEl.style.display = 'none';
        closeModal();
      }, 1200);
    } else {
      setTimeout(function() {
        feedbackEl.style.display = 'none';
      }, 3000);
    }
  }

  // Slug helper: lowercase, replace non-alphanum with hyphens, collapse, trim
  function slugify(str) {
    return str.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 60);
  }

  // =========================================================================
  // Markdown formatting toolbar helpers
  // =========================================================================

  // Wrap selected text with before/after markers (bold, italic, code)
  function wrapSelection(before, after) {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;
    var selected = text.slice(start, end);

    // If no selection, insert markers with cursor between them
    if (start === end) {
      var inserted = before + after;
      input.value = text.slice(0, start) + inserted + text.slice(end);
      input.selectionStart = input.selectionEnd = start + before.length;
    } else {
      input.value = text.slice(0, start) + before + selected + after + text.slice(end);
      input.selectionStart = start + before.length;
      input.selectionEnd = end + before.length;
    }
    input.focus();
  }

  // Prefix each selected line (or current line) with a string
  function prefixLines(prefix) {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;

    // Find the start of the first selected line
    var lineStart = text.lastIndexOf('\n', start - 1) + 1;
    // Find the end of the last selected line
    var lineEnd = text.indexOf('\n', end);
    if (lineEnd === -1) lineEnd = text.length;

    var block = text.slice(lineStart, lineEnd);
    var lines = block.split('\n');
    var prefixed = lines.map(function(line) { return prefix + line; }).join('\n');

    input.value = text.slice(0, lineStart) + prefixed + text.slice(lineEnd);

    // Place cursor at end of modified block
    var newEnd = lineStart + prefixed.length;
    input.selectionStart = lineStart;
    input.selectionEnd = newEnd;
    input.focus();
  }

  // Insert link markdown: [text](url) or [](url) if no selection
  function insertLink() {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    var text = input.value;
    var selected = text.slice(start, end);

    if (selected) {
      var inserted = '[' + selected + '](url)';
      input.value = text.slice(0, start) + inserted + text.slice(end);
      // Select "url" so user can type over it
      input.selectionStart = start + selected.length + 2;
      input.selectionEnd = start + selected.length + 5;
    } else {
      input.value = text.slice(0, start) + '[](url)' + text.slice(end);
      // Place cursor inside [] for link text
      input.selectionStart = input.selectionEnd = start + 1;
    }
    input.focus();
  }

  function applyFormat(format) {
    switch (format) {
      case 'bold':    wrapSelection('**', '**'); break;
      case 'italic':  wrapSelection('*', '*'); break;
      case 'code':    wrapSelection('`', '`'); break;
      case 'heading': prefixLines('## '); break;
      case 'bullet':  prefixLines('- '); break;
      case 'todo':    prefixLines('- [ ] '); break;
      case 'link':    insertLink(); break;
    }
  }

  // Toolbar button click handlers
  toolbarButtons.forEach(function(tbtn) {
    tbtn.addEventListener('click', function(e) {
      e.preventDefault();
      var format = tbtn.getAttribute('data-format');
      applyFormat(format);
      scheduleNotePreview();
    });
  });

  // =========================================================================
  // Mini Markdown → HTML renderer for Note mode preview
  // Supports: headings, bold, italic, inline code, links, bullets, todos,
  //           paragraphs, and blank-line separation.
  // =========================================================================
  function renderMarkdown(src) {
    if (!src) return '';
    var lines = src.split('\n');
    var html = '';
    var inList = false; // track if we are inside a <ul>

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];

      // Headings: ## text
      var headingMatch = line.match(/^(#{1,6})\s+(.*)/);
      if (headingMatch) {
        if (inList) { html += '</ul>'; inList = false; }
        var level = headingMatch[1].length;
        html += '<h' + level + '>' + inlineMarkdown(escapeHtml(headingMatch[2])) + '</h' + level + '>';
        continue;
      }

      // Todo items: - [ ] text  or  - [x] text
      var todoMatch = line.match(/^[-*]\s+\[([ xX])\]\s+(.*)/);
      if (todoMatch) {
        if (!inList) { html += '<ul class="qc-md-list">'; inList = true; }
        var checked = todoMatch[1] !== ' ';
        html += '<li class="qc-md-todo">'
          + '<input type="checkbox" disabled' + (checked ? ' checked' : '') + '> '
          + inlineMarkdown(escapeHtml(todoMatch[2]))
          + '</li>';
        continue;
      }

      // Bullet / list items: - text or * text
      var bulletMatch = line.match(/^[-*]\s+(.*)/);
      if (bulletMatch) {
        if (!inList) { html += '<ul class="qc-md-list">'; inList = true; }
        html += '<li>' + inlineMarkdown(escapeHtml(bulletMatch[1])) + '</li>';
        continue;
      }

      // Close any open list before non-list content
      if (inList) { html += '</ul>'; inList = false; }

      // Blank lines
      if (!line.trim()) {
        continue;
      }

      // Normal paragraph
      html += '<p>' + inlineMarkdown(escapeHtml(line)) + '</p>';
    }

    if (inList) html += '</ul>';
    return html;
  }

  // Inline markdown: bold, italic, inline code, links
  function inlineMarkdown(text) {
    // Inline code: `code`
    text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
    // Bold: **text**
    text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    // Italic: *text*  (but not inside **)
    text = text.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
    // Links: [text](url)
    text = text.replace(/\[([^\]]*)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    return text;
  }

  function updateNotePreview() {
    if (currentMode !== 'note' || !notePreviewPanel) return;
    var text = input.value;
    if (!text.trim()) {
      notePreviewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see a preview...</div>';
      notePreviewWrapper.style.display = 'none';
      return;
    }
    notePreviewWrapper.style.display = '';
    notePreviewPanel.innerHTML = renderMarkdown(text);
  }

  var notePreviewTimer = null;
  function scheduleNotePreview() {
    if (notePreviewTimer) clearTimeout(notePreviewTimer);
    notePreviewTimer = setTimeout(updateNotePreview, 150);
  }

  // =========================================================================
  // Mini syntax highlighter — outputs <span> with Chroma-compatible classes
  // Covers keywords, strings, comments, numbers, and functions for our 8 langs.
  // =========================================================================
  var langKeywords = {
    kotlin: /\b(fun|val|var|class|object|interface|if|else|when|for|while|do|return|break|continue|import|package|is|as|in|null|true|false|this|super|throw|try|catch|finally|typealias|companion|data|sealed|enum|open|abstract|override|private|public|protected|internal|inline|suspend|lateinit|by|init|constructor|get|set|it)\b/g,
    bash: /\b(if|then|else|elif|fi|for|while|do|done|case|esac|function|return|in|select|until|local|export|source|alias|unalias|readonly|declare|typeset|set|unset|shift|trap|exec|eval|exit|echo|printf|read|test|true|false)\b/g,
    sql: /\b(SELECT|FROM|WHERE|INSERT|INTO|UPDATE|SET|DELETE|CREATE|DROP|ALTER|TABLE|INDEX|VIEW|JOIN|INNER|LEFT|RIGHT|OUTER|CROSS|ON|AND|OR|NOT|IN|IS|NULL|AS|ORDER|BY|GROUP|HAVING|LIMIT|OFFSET|UNION|ALL|EXISTS|BETWEEN|LIKE|DISTINCT|COUNT|SUM|AVG|MIN|MAX|CASE|WHEN|THEN|ELSE|END|VALUES|PRIMARY|KEY|FOREIGN|REFERENCES|DEFAULT|CONSTRAINT|UNIQUE|CHECK|CASCADE|TRIGGER|FUNCTION|PROCEDURE|BEGIN|COMMIT|ROLLBACK|GRANT|REVOKE|WITH|RECURSIVE|RETURNING|COALESCE|CAST|NULLIF|select|from|where|insert|into|update|set|delete|create|drop|alter|table|index|view|join|inner|left|right|outer|cross|on|and|or|not|in|is|null|as|order|by|group|having|limit|offset|union|all|exists|between|like|distinct|count|sum|avg|min|max|case|when|then|else|end|values|primary|key|foreign|references|default|constraint|unique|check|cascade|trigger|function|procedure|begin|commit|rollback|grant|revoke|with|recursive|returning|coalesce|cast|nullif)\b/g,
    ruby: /\b(def|end|class|module|if|elsif|else|unless|while|until|for|do|begin|rescue|ensure|raise|return|yield|require|include|extend|attr_accessor|attr_reader|attr_writer|puts|print|nil|true|false|self|super|then|and|or|not|in|case|when|lambda|proc|block_given)\b/g,
    python: /\b(def|class|if|elif|else|for|while|return|import|from|as|try|except|finally|raise|with|yield|lambda|pass|break|continue|and|or|not|in|is|None|True|False|self|print|async|await|global|nonlocal|assert|del)\b/g,
    go: /\b(func|package|import|var|const|type|struct|interface|map|chan|range|if|else|for|switch|case|default|select|break|continue|return|go|defer|fallthrough|nil|true|false|make|new|len|cap|append|copy|delete|close|panic|recover|error|string|int|int8|int16|int32|int64|uint|float32|float64|bool|byte|rune)\b/g,
    javascript: /\b(function|var|let|const|if|else|for|while|do|switch|case|default|break|continue|return|class|extends|new|this|super|import|export|from|as|try|catch|finally|throw|async|await|yield|typeof|instanceof|in|of|delete|void|null|undefined|true|false|console|window|document|NaN|Infinity|require|module|Promise|Map|Set|Symbol|Array|Object|RegExp)\b/g,
    yaml: /\b(true|false|null|yes|no|on|off)\b/g
  };

  var langComments = {
    kotlin:     { line: '//', block: ['/\\*', '\\*/'] },
    bash:       { line: '#', block: null },
    sql:        { line: '--', block: ['/\\*', '\\*/'] },
    ruby:       { line: '#', block: ['=begin', '=end'] },
    python:     { line: '#', block: null },
    go:         { line: '//', block: ['/\\*', '\\*/'] },
    javascript: { line: '//', block: ['/\\*', '\\*/'] },
    yaml:       { line: '#', block: null }
  };

  function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function highlightCode(code, lang) {
    if (!code) return '';

    // Tokenize: we process the string linearly to avoid overlapping matches.
    // Tokens: { start, end, cls }
    var tokens = [];
    var src = code;

    // 1) Strings (double-quoted, single-quoted, backtick for JS)
    var strPatterns = lang === 'python'
      ? [/"""[\s\S]*?"""/g, /'''[\s\S]*?'''/g, /"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g]
      : lang === 'javascript'
      ? [/"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g, /`(?:[^`\\]|\\.)*`/g]
      : [/"(?:[^"\\]|\\.)*"/g, /'(?:[^'\\]|\\.)*'/g];

    strPatterns.forEach(function(re) {
      var m;
      while ((m = re.exec(src)) !== null) {
        tokens.push({ start: m.index, end: m.index + m[0].length, cls: 's' });
      }
    });

    // 2) Comments
    var cmt = langComments[lang];
    if (cmt) {
      if (cmt.line) {
        var lineRe = new RegExp(cmt.line.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '.*', 'gm');
        var m;
        while ((m = lineRe.exec(src)) !== null) {
          tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'c1' });
        }
      }
      if (cmt.block) {
        var blockRe = new RegExp(cmt.block[0] + '[\\s\\S]*?' + cmt.block[1], 'g');
        var m;
        while ((m = blockRe.exec(src)) !== null) {
          tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'cm' });
        }
      }
    }

    // 3) Numbers
    var numRe = /\b(?:0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+\.?\d*(?:[eE][+-]?\d+)?)\b/g;
    var m;
    while ((m = numRe.exec(src)) !== null) {
      tokens.push({ start: m.index, end: m.index + m[0].length, cls: 'mi' });
    }

    // Sort tokens by start, then by length descending (longer wins)
    tokens.sort(function(a, b) { return a.start - b.start || (b.end - b.start) - (a.end - a.start); });

    // Remove overlapping tokens (first one wins)
    var filtered = [];
    var lastEnd = 0;
    tokens.forEach(function(t) {
      if (t.start >= lastEnd) {
        filtered.push(t);
        lastEnd = t.end;
      }
    });

    // Build output: interleave plain text (with keyword highlighting) and tokens
    var out = '';
    var pos = 0;

    function highlightKeywords(text) {
      var kwRe = langKeywords[lang];
      if (!kwRe) return escapeHtml(text);
      // Reset regex
      kwRe.lastIndex = 0;
      var result = '';
      var last = 0;
      var km;
      while ((km = kwRe.exec(text)) !== null) {
        result += escapeHtml(text.slice(last, km.index));
        result += '<span class="k">' + escapeHtml(km[0]) + '</span>';
        last = km.index + km[0].length;
      }
      result += escapeHtml(text.slice(last));

      // Also highlight function calls: word followed by (
      result = result.replace(/\b([a-zA-Z_]\w*)(\()/g, function(match, name, paren) {
        // Don't re-wrap already-wrapped keywords
        if (match.indexOf('<span') !== -1) return match;
        return '<span class="nf">' + name + '</span>' + paren;
      });

      return result;
    }

    filtered.forEach(function(t) {
      if (t.start > pos) {
        out += highlightKeywords(src.slice(pos, t.start));
      }
      out += '<span class="' + t.cls + '">' + escapeHtml(src.slice(t.start, t.end)) + '</span>';
      pos = t.end;
    });
    if (pos < src.length) {
      out += highlightKeywords(src.slice(pos));
    }

    return out;
  }

  function updatePreview() {
    if (currentMode !== 'code' || !previewPanel) return;
    var code = input.value;
    if (!code.trim()) {
      previewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see highlighted preview...</div>';
      return;
    }
    var highlighted = highlightCode(code, selectedLang);
    previewPanel.innerHTML = '<pre class="chroma"><code>' + highlighted + '</code></pre>';
  }

  function schedulePreview() {
    if (previewTimer) clearTimeout(previewTimer);
    previewTimer = setTimeout(updatePreview, 150);
  }

  // Listen for input on textarea
  input.addEventListener('input', function() {
    if (currentMode === 'code') schedulePreview();
    if (currentMode === 'note') scheduleNotePreview();
  });

  // Mode switching logic
  var modes = ['note', 'code', 'todo'];

  function setMode(mode) {
    if (mode === currentMode) return;
    currentMode = mode;
    modeButtons.forEach(function(b) { b.classList.remove('active'); });
    modeButtons.forEach(function(b) {
      if (b.getAttribute('data-mode') === mode) b.classList.add('active');
    });

    // Hide everything first
    destRow.style.display = 'none';
    langRow.style.display = 'none';
    if (bookTitleRow) bookTitleRow.style.display = 'none';
    previewWrapper.style.display = 'none';
    notePreviewWrapper.style.display = 'none';
    if (todoFieldsEl) todoFieldsEl.style.display = 'none';

    if (mode === 'code') {
      langRow.style.display = '';
      previewWrapper.style.display = '';
      if (toolbar) toolbar.style.display = 'none';
      input.classList.add('code-mode');
      dialog.classList.add('code-mode');
      input.placeholder = 'Paste or type your code here...';
      titleInput.style.display = '';
      document.getElementById('qc-editor-box').style.display = '';
      updatePreview();
    } else if (mode === 'todo') {
      if (todoFieldsEl) todoFieldsEl.style.display = '';
      if (toolbar) toolbar.style.display = 'none';
      titleInput.style.display = 'none';
      document.getElementById('qc-editor-box').style.display = 'none';
      input.classList.remove('code-mode');
      dialog.classList.remove('code-mode');
    } else {
      // note mode
      destRow.style.display = '';
      if (toolbar) toolbar.style.display = '';
      if (bookTitleRow) bookTitleRow.style.display = selectedDest.tag === 'book-note' ? '' : 'none';
      input.classList.remove('code-mode');
      dialog.classList.remove('code-mode');
      input.placeholder = "What's on your mind?";
      titleInput.style.display = '';
      document.getElementById('qc-editor-box').style.display = '';
      updateNotePreview();
    }

    // Focus the primary input for the new mode
    if (mode === 'todo') {
      if (todoTitleInput) todoTitleInput.focus();
    } else {
      titleInput.focus();
    }
  }

  // Mode toggle click handlers
  modeButtons.forEach(function(mbtn) {
    mbtn.addEventListener('click', function() {
      setMode(mbtn.getAttribute('data-mode'));
    });
  });

  // Destination button click handling
  destButtons.forEach(function(dbtn) {
    dbtn.addEventListener('click', function() {
      destButtons.forEach(function(b) { b.classList.remove('active'); });
      dbtn.classList.add('active');
      selectedDest.path = dbtn.getAttribute('data-path');
      selectedDest.tag = dbtn.getAttribute('data-tag');

      // Show/hide book title input
      if (selectedDest.tag === 'book-note' && bookTitleRow) {
        bookTitleRow.style.display = '';
        populateBookTitleDatalist();
      } else if (bookTitleRow) {
        bookTitleRow.style.display = 'none';
      }

      // Show/hide new-note toggle (only visible when Inbox is selected)
      if (inboxNewBtn) {
        inboxNewBtn.style.display = selectedDest.tag === 'inbox' ? '' : 'none';
        if (selectedDest.tag !== 'inbox') {
          inboxNewBtn.classList.remove('active');
          inboxMode = 'append';
        }
      }
    });
  });

  // Inbox new-note toggle click handling
  if (inboxNewBtn) {
    inboxNewBtn.addEventListener('click', function() {
      var isNew = inboxNewBtn.classList.toggle('active');
      inboxMode = isNew ? 'new' : 'append';
    });
  }

  // Language button click handling
  langButtons.forEach(function(lbtn) {
    lbtn.addEventListener('click', function() {
      langButtons.forEach(function(b) { b.classList.remove('active'); });
      lbtn.classList.add('active');
      selectedLang = lbtn.getAttribute('data-lang');
      updatePreview();
    });
  });

  // Populate the book title datalist with existing book titles from IndexedDB
  function populateBookTitleDatalist() {
    if (!bookTitleDatalist || !window.dmSync) return;
    window.dmSync.getAllNotes().then(function(notes) {
      var titles = {};
      notes.forEach(function(n) {
        if (n.destination === 'book-note' && n.bookTitle) {
          titles[n.bookTitle] = true;
        }
      });
      var html = '';
      Object.keys(titles).sort().forEach(function(t) {
        html += '<option value="' + t.replace(/"/g, '&quot;') + '">';
      });
      bookTitleDatalist.innerHTML = html;
    });
  }

  // =========================================================================
  // Todo mode: date/reminder popovers and chips
  // =========================================================================

  function closeQcTodoPopover() {
    if (_qcTodoPopover && _qcTodoPopover.parentNode) {
      _qcTodoPopover.parentNode.removeChild(_qcTodoPopover);
    }
    _qcTodoPopover = null;
  }

  function formatQcDateChip(dateStr) {
    var today = new Date(); today.setHours(0,0,0,0);
    var d = new Date(dateStr + 'T00:00:00');
    var diff = Math.round((d - today) / 86400000);
    if (diff === 0) return 'Today';
    if (diff === 1) return 'Tomorrow';
    var days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    if (diff > 1 && diff < 7) return days[d.getDay()];
    return months[d.getMonth()] + ' ' + d.getDate();
  }

  function formatQcReminderChip(ms) {
    var d = new Date(ms);
    var now = new Date();
    var diffMin = Math.round((ms - now.getTime()) / 60000);
    if (diffMin > 0 && diffMin <= 90) return 'In ' + diffMin + ' min';
    var today = new Date(); today.setHours(0,0,0,0);
    var target = new Date(ms); target.setHours(0,0,0,0);
    var dayDiff = Math.round((target - today) / 86400000);
    var timeStr = d.getHours() + ':' + (d.getMinutes() < 10 ? '0' : '') + d.getMinutes();
    if (dayDiff === 0) return 'Today ' + timeStr;
    if (dayDiff === 1) return 'Tmrw ' + timeStr;
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[d.getMonth()] + ' ' + d.getDate() + ' ' + timeStr;
  }

  function updateQcDateChip() {
    if (_qcTodoDate) {
      todoDateChipText.textContent = formatQcDateChip(_qcTodoDate);
      todoDateChip.style.display = '';
    } else {
      todoDateChip.style.display = 'none';
    }
  }

  function updateQcReminderChip() {
    if (_qcTodoReminderMs) {
      todoReminderChipText.textContent = formatQcReminderChip(_qcTodoReminderMs);
      todoReminderChip.style.display = '';
    } else {
      todoReminderChip.style.display = 'none';
    }
  }

  function showQcDatePopover() {
    closeQcTodoPopover();
    var pop = document.createElement('div');
    pop.className = 'qc-todo-popover';

    var today = new Date();
    var todayStr = today.getFullYear() + '-' + pad(today.getMonth()+1) + '-' + pad(today.getDate());
    var tmrw = new Date(today); tmrw.setDate(tmrw.getDate()+1);
    var tmrwStr = tmrw.getFullYear() + '-' + pad(tmrw.getMonth()+1) + '-' + pad(tmrw.getDate());

    pop.innerHTML =
      '<button type="button" class="qc-todo-popover-shortcut" data-val="' + todayStr + '">Today</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-val="' + tmrwStr + '">Tomorrow</button>' +
      '<input type="date" class="qc-todo-popover-date" min="' + todayStr + '" />';

    pop.querySelectorAll('.qc-todo-popover-shortcut').forEach(function(btn) {
      btn.addEventListener('click', function() {
        _qcTodoDate = btn.getAttribute('data-val');
        updateQcDateChip();
        closeQcTodoPopover();
      });
    });
    pop.querySelector('.qc-todo-popover-date').addEventListener('change', function() {
      if (this.value) {
        _qcTodoDate = this.value;
        updateQcDateChip();
        closeQcTodoPopover();
      }
    });

    // Position below the button
    var rect = todoDateBtn.getBoundingClientRect();
    var dialogRect = dialog.getBoundingClientRect();
    pop.style.position = 'absolute';
    pop.style.top = (rect.bottom - dialogRect.top + 4) + 'px';
    pop.style.left = (rect.left - dialogRect.left) + 'px';

    dialog.appendChild(pop);
    _qcTodoPopover = pop;
  }

  function showQcReminderPopover() {
    closeQcTodoPopover();
    var pop = document.createElement('div');
    pop.className = 'qc-todo-popover';

    var now = new Date();
    var in30 = new Date(now.getTime() + 30*60000);
    var in60 = new Date(now.getTime() + 60*60000);
    var tmrw9 = new Date(now); tmrw9.setDate(tmrw9.getDate()+1); tmrw9.setHours(9,0,0,0);

    pop.innerHTML =
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + in30.getTime() + '">In 30 min</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + in60.getTime() + '">In 1 hour</button>' +
      '<button type="button" class="qc-todo-popover-shortcut" data-ms="' + tmrw9.getTime() + '">Tomorrow 9 AM</button>' +
      '<input type="datetime-local" class="qc-todo-popover-datetime" />';

    pop.querySelectorAll('.qc-todo-popover-shortcut').forEach(function(btn) {
      btn.addEventListener('click', function() {
        _qcTodoReminderMs = parseInt(btn.getAttribute('data-ms'), 10);
        updateQcReminderChip();
        closeQcTodoPopover();
      });
    });
    pop.querySelector('.qc-todo-popover-datetime').addEventListener('change', function() {
      if (this.value) {
        _qcTodoReminderMs = new Date(this.value).getTime();
        updateQcReminderChip();
        closeQcTodoPopover();
      }
    });

    var rect = todoReminderBtn.getBoundingClientRect();
    var dialogRect = dialog.getBoundingClientRect();
    pop.style.position = 'absolute';
    pop.style.top = (rect.bottom - dialogRect.top + 4) + 'px';
    pop.style.left = (rect.left - dialogRect.left) + 'px';

    dialog.appendChild(pop);
    _qcTodoPopover = pop;
  }

  // Wire up todo icon buttons
  if (todoDateBtn) {
    todoDateBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (_qcTodoPopover) { closeQcTodoPopover(); return; }
      showQcDatePopover();
    });
  }
  if (todoReminderBtn) {
    todoReminderBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (_qcTodoPopover) { closeQcTodoPopover(); return; }
      showQcReminderPopover();
    });
  }
  if (todoDateClear) {
    todoDateClear.addEventListener('click', function() {
      _qcTodoDate = null;
      updateQcDateChip();
    });
  }
  if (todoReminderClear) {
    todoReminderClear.addEventListener('click', function() {
      _qcTodoReminderMs = null;
      updateQcReminderChip();
    });
  }

  // Dismiss popover on outside click
  document.addEventListener('click', function(e) {
    if (_qcTodoPopover && !_qcTodoPopover.contains(e.target) &&
        e.target !== todoDateBtn && e.target !== todoReminderBtn &&
        !todoDateBtn.contains(e.target) && !todoReminderBtn.contains(e.target)) {
      closeQcTodoPopover();
    }
  });

  function openModal() {
    // Reset state
    currentMode = 'note';
    selectedLang = 'kotlin';
    modeButtons.forEach(function(b) { b.classList.remove('active'); });
    modeButtons[0].classList.add('active');
    destRow.style.display = '';
    langRow.style.display = 'none';
    if (bookTitleRow) bookTitleRow.style.display = 'none';
    if (bookTitleInput) bookTitleInput.value = '';
    // Reset inbox new-note toggle
    inboxMode = 'append';
    if (inboxNewBtn) inboxNewBtn.classList.remove('active');
    previewWrapper.style.display = 'none';
    notePreviewWrapper.style.display = 'none';
    if (toolbar) toolbar.style.display = '';
    langButtons.forEach(function(b) { b.classList.remove('active'); });
    langButtons[0].classList.add('active');
    // Reset destination to Inbox
    destButtons.forEach(function(b) { b.classList.remove('active'); });
    destButtons[0].classList.add('active');
    selectedDest.path = destButtons[0].getAttribute('data-path');
    selectedDest.tag = destButtons[0].getAttribute('data-tag');
    input.classList.remove('code-mode');
    dialog.classList.remove('code-mode');
    input.placeholder = "What's on your mind?";

    // Reset todo state
    if (todoFieldsEl) todoFieldsEl.style.display = 'none';
    if (todoTitleInput) todoTitleInput.value = '';
    if (todoEstimateInput) todoEstimateInput.value = '';
    _qcTodoDate = null;
    _qcTodoReminderMs = null;
    updateQcDateChip();
    updateQcReminderChip();
    closeQcTodoPopover();

    // Show note/code fields (default: note mode)
    titleInput.style.display = '';
    document.getElementById('qc-editor-box').style.display = '';

    modal.classList.add('active');
    modal.setAttribute('aria-hidden', 'false');
    titleInput.value = '';
    input.value = '';
    if (previewPanel) previewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see highlighted preview...</div>';
    if (notePreviewPanel) notePreviewPanel.innerHTML = '<div class="qc-preview-empty">Start typing to see a preview...</div>';
    titleInput.focus();
  }

  function closeModal() {
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
    titleInput.value = '';
    input.value = '';
    if (bookTitleInput) bookTitleInput.value = '';
    if (todoTitleInput) todoTitleInput.value = '';
    if (todoEstimateInput) todoEstimateInput.value = '';
    _qcTodoDate = null;
    _qcTodoReminderMs = null;
    closeQcTodoPopover();
    isSaving = false;
    if (feedbackEl) feedbackEl.style.display = 'none';
  }

  function pad(n) { return n < 10 ? '0' + n : '' + n; }

  function submit() {
    if (isSaving) return;

    // Todo mode — different submit path
    if (currentMode === 'todo') {
      submitTodo();
      return;
    }

    var text = input.value.trim();
    if (!text) {
      input.focus();
      return;
    }

    // Check auth
    if (!window.dmAuth || !window.dmAuth.currentUser) {
      showFeedback('error', 'Please sign in with Google to save notes.');
      return;
    }

    isSaving = true;
    submitBtn.disabled = true;

    var user = window.dmAuth.currentUser;
    var now = new Date();
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    var displayDate = months[now.getMonth()] + ' ' + now.getDate() + ', ' + now.getFullYear();

    var userTitle = titleInput.value.trim();
    var noteData = {
      userId: user.uid,
      userEmail: user.email,
      userName: user.displayName || '',
      content: text,
      mode: currentMode,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    if (currentMode === 'code') {
      var langLabel = selectedLang.charAt(0).toUpperCase() + selectedLang.slice(1);
      noteData.title = userTitle || (langLabel + ' Snippet - ' + displayDate);
      noteData.language = selectedLang;
      noteData.tags = ['snippet', selectedLang];
      noteData.destination = 'snippets';
    } else {
      noteData.title = userTitle || ('Quick Note - ' + displayDate);
      noteData.destination = selectedDest.tag;
      noteData.tags = [selectedDest.tag];
      noteData.language = null;

      // Include bookTitle for book notes
      if (selectedDest.tag === 'book-note' && bookTitleInput) {
        noteData.bookTitle = bookTitleInput.value.trim() || null;
      }
    }

    // Inbox append mode: prepend to existing single note (newest on top)
    if (noteData.destination === 'inbox' && inboxMode === 'append' && window.dmSync) {
      window.dmSync.getNotesByDestination('inbox').then(function(inboxNotes) {
        if (inboxNotes && inboxNotes.length > 0) {
          // Prepend to existing inbox note (newest content on top)
          inboxNotes.sort(function(a, b) { return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0); });
          var existing = inboxNotes[0];
          var separator = '\n\n---\n\n';
          var heading = userTitle ? ('## ' + userTitle + '\n\n') : '';
          var prepended = heading + text + separator + existing.content;

          var updateData = {
            content: prepended,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          };

          window.dmSync.firestoreWrite({
              collection: 'notes',
              docId: existing.id,
              op: 'update',
              data: updateData,
              localOp: function() {
                existing.content = prepended;
                existing.updatedAt = Date.now();
                return window.dmSync.putNote(existing);
              }
            })
            .then(function() {
              isSaving = false;
              submitBtn.disabled = false;
              showFeedback('success', 'Added to Inbox!');
              window.dispatchEvent(new CustomEvent('dm-sync-complete'));
            })
            .catch(function(err) {
              console.error('Firestore append error:', err);
              isSaving = false;
              submitBtn.disabled = false;
              showFeedback('error', 'Failed to save. Please try again.');
            });
        } else {
          // No inbox note exists yet — create one
          noteData.title = 'Inbox';
          var heading = userTitle ? ('## ' + userTitle + '\n\n') : '';
          noteData.content = heading + text;
          createNewNote(noteData);
        }
      }).catch(function(err) {
        console.error('Error checking inbox notes:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to save. Please try again.');
      });
      return;
    }

    // All other destinations: create a new note
    createNewNote(noteData);
  }

  function createNewNote(noteData) {
    var newDocId = window.dmDb ? window.dmDb.collection('notes').doc().id : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    var localNote = Object.assign({}, noteData, {
      id: newDocId,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });

    window.dmSync.firestoreWrite({
      collection: 'notes',
      docId: newDocId,
      op: 'set',
      data: noteData,
      localOp: function() { return window.dmSync.putNote(localNote); }
    })
      .then(function() {
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('success', 'Note saved!');
        // Fire sync event so sidebar updates
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      })
      .catch(function(err) {
        console.error('Firestore write error:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to save. Please try again.');
      });
  }

  function submitTodo() {
    var title = todoTitleInput ? todoTitleInput.value.trim() : '';
    if (!title) {
      if (todoTitleInput) todoTitleInput.focus();
      return;
    }

    if (!window.dmAuth || !window.dmAuth.currentUser) {
      showFeedback('error', 'Please sign in with Google to save tasks.');
      return;
    }

    if (!window.dmDb) {
      showFeedback('error', 'Database not ready. Try again.');
      return;
    }

    isSaving = true;
    submitBtn.disabled = true;

    var user = window.dmAuth.currentUser;
    var est = todoEstimateInput ? (parseInt(todoEstimateInput.value, 10) || 25) : 25;
    var scheduledDate = _qcTodoDate || null;
    var reminderAtMs = (_qcTodoReminderMs && _qcTodoReminderMs > Date.now()) ? _qcTodoReminderMs : null;

    var todoData = {
      userId: user.uid,
      title: title,
      estimatedMin: est,
      actualMin: null,
      category: null,
      done: false,
      parentId: null,
      order: Date.now(),
      scheduledDate: scheduledDate,
      reminderAt: reminderAtMs ? firebase.firestore.Timestamp.fromMillis(reminderAtMs) : null,
      reminderFired: false,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      completedAt: null
    };

    var newTodoId = window.dmDb ? window.dmDb.collection('todos').doc().id : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    var localTodo = Object.assign({}, todoData, {
      id: newTodoId,
      reminderAt: reminderAtMs || null,
      reminderFired: false,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });

    window.dmSync.firestoreWrite({
      collection: 'todos',
      docId: newTodoId,
      op: 'set',
      data: todoData,
      localOp: function() { return window.dmSync.putTodo(localTodo); }
    })
      .then(function() {
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('success', 'Task added!');
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      })
      .catch(function(err) {
        console.error('Firestore todo write error:', err);
        isSaving = false;
        submitBtn.disabled = false;
        showFeedback('error', 'Failed to add task. Please try again.');
      });
  }

  btn.addEventListener('click', openModal);
  cancelBtn.addEventListener('click', closeModal);
  submitBtn.addEventListener('click', submit);
  backdrop.addEventListener('click', closeModal);

  document.addEventListener('keydown', function(e) {
    // Global shortcut: E to open Quick Capture (when not typing)
    if (!modal.classList.contains('active')) {
      if (e.key === 'e' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
        e.preventDefault();
        openModal();
      }
      return;
    }

    // Modal-specific shortcuts
    if (e.key === 'Escape') {
      e.preventDefault();
      closeModal();
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      e.preventDefault();
      submit();
    }
    // Tab cycles modes: Note → Code → Todo → Note
    if (e.key === 'Tab' && !e.metaKey && !e.ctrlKey && !e.altKey) {
      e.preventDefault();
      var idx = modes.indexOf(currentMode);
      var next = e.shiftKey
        ? modes[(idx - 1 + modes.length) % modes.length]
        : modes[(idx + 1) % modes.length];
      setMode(next);
    }

    // Formatting shortcuts (Note mode only, when textarea is focused)
    if (currentMode === 'note' && e.target === input && (e.metaKey || e.ctrlKey)) {
      if (e.key === 'b') {
        e.preventDefault();
        applyFormat('bold');
      } else if (e.key === 'i') {
        e.preventDefault();
        applyFormat('italic');
      } else if (e.key === 'e') {
        e.preventDefault();
        applyFormat('code');
      } else if (e.shiftKey && (e.key === 'T' || e.key === 't')) {
        e.preventDefault();
        applyFormat('todo');
      } else if (e.shiftKey && (e.key === 'H' || e.key === 'h')) {
        e.preventDefault();
        applyFormat('heading');
      }
    }
  });
})();
</script>

<!-- Landing page auth (garden-hero) -->
<script>
(function() {
  if (typeof firebase === 'undefined' || !window.dmAuth) return;

  var gardenSignin = document.getElementById('garden-signin');
  var gardenSignout = document.getElementById('garden-signout');
  var gardenAuthUser = document.getElementById('garden-auth-user');
  var gardenAvatar = document.getElementById('garden-auth-avatar');
  var gardenName = document.getElementById('garden-auth-name');

  // Only run on pages that have the landing page auth elements
  if (!gardenSignin) return;

  function subscribeGardenAuth() {
    window.dmAuth.onAuthStateChanged(function(user) {
      if (user) {
        gardenSignin.style.display = 'none';
        gardenAuthUser.style.display = '';
        gardenAvatar.src = user.photoURL || '';
        gardenAvatar.alt = user.displayName || '';
        gardenName.textContent = user.displayName || user.email || '';
      } else {
        gardenSignin.style.display = '';
        gardenAuthUser.style.display = 'none';
      }
    });
  }
  if (window.dmAuthReady) {
    window.dmAuthReady.then(subscribeGardenAuth);
  } else {
    subscribeGardenAuth();
  }

  gardenSignin.addEventListener('click', function() {
    if (!window.dmGoogleProvider) return;
    if (window.dmIsLocalhost) {
      window.dmAuth.signInWithRedirect(window.dmGoogleProvider);
    } else {
      window.dmAuth.signInWithPopup(window.dmGoogleProvider).catch(function(err) {
        console.error('Landing page sign-in error:', err);
      });
    }
  });

  gardenSignout.addEventListener('click', function() {
    window.dmAuth.signOut();
  });
})();
</script>

<!-- Dynamic sidebar: populates sidebar entries from IndexedDB cache -->
<script>
(function() {
  'use strict';

  var SIDEBAR_CACHE_KEY = 'dm-sidebar-html';
  var SIDEBAR_CACHE_VERSION_KEY = 'dm-sidebar-version';
  var SIDEBAR_VERSION = '{{ now.Unix }}'; // changes on each Hugo build

  // Immediately restore cached sidebar HTML to prevent flicker on navigation
  (function restoreSidebarCache() {
    try {
      // Invalidate cache if version changed (new deploy)
      var cachedVersion = sessionStorage.getItem(SIDEBAR_CACHE_VERSION_KEY);
      if (cachedVersion !== SIDEBAR_VERSION) {
        sessionStorage.removeItem(SIDEBAR_CACHE_KEY);
        sessionStorage.setItem(SIDEBAR_CACHE_VERSION_KEY, SIDEBAR_VERSION);
        return;
      }
      var cached = sessionStorage.getItem(SIDEBAR_CACHE_KEY);
      if (!cached) return;
      var menuNav = document.querySelector('.book-menu-content nav');
      if (!menuNav) return;
      var ul = menuNav.querySelector('ul');
      if (!ul) return;

      ul.innerHTML = cached;

      // Update active states to match current page
      var links = ul.querySelectorAll('a[href]');
      var pathname = window.location.pathname;
      var search = window.location.search;
      var params = new URLSearchParams(search);
      var viewId = params.get('id');
      links.forEach(function(a) {
        a.classList.remove('active');
        var href = a.getAttribute('href');
        if (!href) return;
        // Check if this is the current view page
        if (viewId && href.indexOf('id=' + viewId) !== -1) {
          a.classList.add('active');
        }
        // Check if this is the current section page
        else if (!viewId && (pathname === href || pathname === href.replace(/\/$/, ''))) {
          a.classList.add('active');
        }
      });

      // Also update inbox accent: only active when on inbox page
      var inboxItem = ul.querySelector('.sidebar-inbox');
      if (inboxItem) {
        var inboxLink = inboxItem.querySelector('a');
        if (inboxLink) {
          if (pathname.indexOf('/docs/inbox') !== -1) {
            inboxLink.classList.add('active');
          } else {
            inboxLink.classList.remove('active');
          }
        }
      }
    } catch (e) { /* sessionStorage may be unavailable */ }
  })();

  var ICONS = {
    books: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>',
    topics: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
    inbox: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path></svg>',
    snippets: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>',
    tags: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>',
    dashboard: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="3" width="7" height="7" rx="1"></rect><rect x="3" y="14" width="7" height="7" rx="1"></rect><rect x="14" y="14" width="7" height="7" rx="1"></rect></svg>',
    trash: '<svg class="sidebar-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>'
  };

  function getBaseUrl() {
    var manifest = document.querySelector('link[rel="manifest"]');
    if (manifest) return manifest.getAttribute('href').replace('/manifest.json', '');
    return '';
  }

  function viewUrl(noteId) {
    return getBaseUrl() + '/docs/view/?id=' + encodeURIComponent(noteId);
  }

  function sectionUrl(section) {
    return getBaseUrl() + '/docs/' + section + '/';
  }

  function escapeHtml(text) {
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function randomId() {
    return 'dmsb-' + Math.random().toString(36).substr(2, 9);
  }

  // Check if current page matches a URL
  function isActive(url) {
    return window.location.pathname === url || window.location.pathname === url.replace(/\/$/, '');
  }

  function isViewPage(noteId) {
    var params = new URLSearchParams(window.location.search);
    return params.get('id') === noteId;
  }

  function buildSectionHtml(title, icon, sectionPath, children, isOpen) {
    var checkId = randomId();
    var checked = isOpen ? ' checked' : '';
    var html = '<li class="sidebar-section" data-section="' + escapeHtml(title.toLowerCase()) + '">';
    html += '<input type="checkbox" id="' + checkId + '" class="toggle"' + checked + ' />';
    html += '<label for="' + checkId + '" class="flex justify-between">';
    html += '<a href="' + sectionPath + '">' + icon + escapeHtml(title) + '</a>';
    html += '</label>';
    html += '<ul>' + children + '</ul>';
    html += '</li>';
    return html;
  }

  function buildNoteItem(note) {
    var active = isViewPage(note.id) ? ' class="active"' : '';
    return '<li class="sidebar-item" data-section="' + escapeHtml((note.title || '').toLowerCase()) + '">' +
      '<a href="' + viewUrl(note.id) + '"' + active + '>' + escapeHtml(note.title || 'Untitled') + '</a>' +
      '</li>';
  }

  function buildSubSection(title, notes, isOpen) {
    var checkId = randomId();
    var checked = isOpen ? ' checked' : '';
    var children = '';
    notes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.createdAt || 0) - (a.createdAt || 0);
    });
    notes.forEach(function(n) { children += buildNoteItem(n); });

    var html = '<li class="sidebar-section" data-section="' + escapeHtml(title.toLowerCase()) + '">';
    html += '<input type="checkbox" id="' + checkId + '" class="toggle"' + checked + ' />';
    html += '<label for="' + checkId + '" class="flex justify-between">';
    html += '<a role="button">' + escapeHtml(title) + '</a>';
    html += '</label>';
    html += '<ul>' + children + '</ul>';
    html += '</li>';
    return html;
  }

  function sortByCreatedAt(notes) {
    return notes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.createdAt || 0) - (a.createdAt || 0);
    });
  }

  var SIDEBAR_MAX = 10;

  function renderDynamicSidebar(allNotes) {
    var menuNav = document.querySelector('.book-menu-content nav');
    if (!menuNav) return;

    // Find the existing <ul> that contains sections
    var existingUl = menuNav.querySelector('ul');
    if (!existingUl) return;

    // Categorize notes (inbox excluded — it's a single scrollable page)
    var bookNotes = {};      // grouped by bookTitle
    var topicNotes = [];
    var snippetNotes = {};   // grouped by language

    allNotes.forEach(function(n) {
      if (n.destination === 'book-note') {
        var bt = n.bookTitle || 'Uncategorized';
        if (!bookNotes[bt]) bookNotes[bt] = [];
        bookNotes[bt].push(n);
      } else if (n.destination === 'topic') {
        topicNotes.push(n);
      } else if (n.destination === 'snippets') {
        var lang = n.language || 'other';
        if (!snippetNotes[lang]) snippetNotes[lang] = [];
        snippetNotes[lang].push(n);
      }
    });

    // Check which note is currently being viewed
    var currentNoteId = new URLSearchParams(window.location.search).get('id');
    var currentNote = currentNoteId ? allNotes.find(function(n) { return n.id === currentNoteId; }) : null;

    // Build Books section — flat list, one entry per book (no sub-grouping)
    var booksChildren = '';
    // Flatten all book notes, sorted by most recently updated
    var allBookNotes = [];
    Object.keys(bookNotes).sort().forEach(function(bt) {
      sortByCreatedAt(bookNotes[bt]);
      bookNotes[bt].forEach(function(n) { allBookNotes.push(n); });
    });
    allBookNotes.sort(function(a, b) {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0);
    });
    var shownBooks = allBookNotes.slice(0, SIDEBAR_MAX);
    shownBooks.forEach(function(n) { booksChildren += buildNoteItem(n); });
    if (allBookNotes.length > SIDEBAR_MAX) {
      booksChildren += '<li class="sidebar-item sidebar-viewall"><a href="' + sectionUrl('books') + '">View all ' + allBookNotes.length + '</a></li>';
    }

    // Build Topics section
    var topicsChildren = '';
    sortByCreatedAt(topicNotes);
    var shownTopics = topicNotes.slice(0, SIDEBAR_MAX);
    shownTopics.forEach(function(n) { topicsChildren += buildNoteItem(n); });
    if (topicNotes.length > SIDEBAR_MAX) {
      topicsChildren += '<li class="sidebar-item sidebar-viewall"><a href="' + sectionUrl('topics') + '">View all ' + topicNotes.length + '</a></li>';
    }

    // Build Inbox section — no children, inbox is a single scrollable page
    var inboxActive = window.location.pathname.indexOf('/docs/inbox') !== -1 ? ' class="active"' : '';

    // Build Snippets section — sub-sections by language, each limited to top 10
    var snippetsChildren = '';
    Object.keys(snippetNotes).sort().forEach(function(lang) {
      var langTitle = lang.charAt(0).toUpperCase() + lang.slice(1);
      var subOpen = currentNote && currentNote.language === lang;
      var langNotes = snippetNotes[lang];
      langNotes.sort(function(a, b) {
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;
        return (b.updatedAt || b.createdAt || 0) - (a.updatedAt || a.createdAt || 0);
      });
      snippetsChildren += buildSubSection(langTitle, langNotes.slice(0, SIDEBAR_MAX), subOpen);
    });

    // All sections expanded by default
    var booksOpen = true;
    var topicsOpen = true;
    var snippetsOpen = true;

    // Build the full sidebar HTML
    var html = '';
    // Inbox first — accented, single page, no sub-entries
    html += '<li class="sidebar-item sidebar-inbox" data-section="inbox">' +
      '<a href="' + sectionUrl('inbox') + '"' + inboxActive + '>' + ICONS.inbox + 'Inbox</a>' +
      '</li>';
    html += buildSectionHtml('Books', ICONS.books, sectionUrl('books'), booksChildren, booksOpen);
    html += buildSectionHtml('Topics', ICONS.topics, sectionUrl('topics'), topicsChildren, topicsOpen);
    html += buildSectionHtml('Snippets', ICONS.snippets, sectionUrl('snippets'), snippetsChildren, snippetsOpen);

    // Add Tags entry (static)
    var tagsActive = window.location.pathname.indexOf('/docs/tags') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="tags">' +
      '<a href="' + sectionUrl('tags') + '"' + tagsActive + '>' + ICONS.tags + 'Tags</a>' +
      '</li>';

    // Add Dashboard entry (static)
    var dashboardActive = window.location.pathname.indexOf('/docs/dashboard') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="dashboard">' +
      '<a href="' + sectionUrl('dashboard') + '"' + dashboardActive + '>' + ICONS.dashboard + 'Dashboard</a>' +
      '</li>';

    // Add Trash entry (static)
    var trashActive = window.location.pathname.indexOf('/docs/trash') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item sidebar-trash" data-section="trash">' +
      '<a href="' + sectionUrl('trash') + '"' + trashActive + '>' + ICONS.trash + 'Trash</a>' +
      '</li>';

    // Replace sidebar content
    existingUl.innerHTML = html;

    // Cache sidebar HTML for instant restore on next navigation
    try { sessionStorage.setItem(SIDEBAR_CACHE_KEY, html); } catch (e) {}
  }

  function renderAuthPrompt() {
    var menuNav = document.querySelector('.book-menu-content nav');
    if (!menuNav) return;

    var existingUl = menuNav.querySelector('ul');
    if (!existingUl) return;

    // Clear cached sidebar since user signed out
    try { sessionStorage.removeItem(SIDEBAR_CACHE_KEY); } catch (e) {}

    var base = getBaseUrl();
    var html = '';

    // Show section headers without children
    html += buildSectionHtml('Books', ICONS.books, sectionUrl('books'), '', false);
    html += buildSectionHtml('Topics', ICONS.topics, sectionUrl('topics'), '', false);
    // Inbox: simple link, no sub-entries
    html += '<li class="sidebar-item" data-section="inbox">' +
      '<a href="' + sectionUrl('inbox') + '">' + ICONS.inbox + 'Inbox</a>' +
      '</li>';
    html += buildSectionHtml('Snippets', ICONS.snippets, sectionUrl('snippets'), '', false);

    var tagsActive = window.location.pathname.indexOf('/docs/tags') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="tags">' +
      '<a href="' + sectionUrl('tags') + '"' + tagsActive + '>' + ICONS.tags + 'Tags</a>' +
      '</li>';

    var dashboardActive = window.location.pathname.indexOf('/docs/dashboard') !== -1 ? ' class="active"' : '';
    html += '<li class="sidebar-item" data-section="dashboard">' +
      '<a href="' + sectionUrl('dashboard') + '"' + dashboardActive + '>' + ICONS.dashboard + 'Dashboard</a>' +
      '</li>';

    existingUl.innerHTML = html;
  }

  // Listen for sync completion
  window.addEventListener('dm-sync-complete', function() {
    if (!window.dmSync) return;
    window.dmSync.getAllNotes().then(function(notes) {
      if (notes.length > 0) {
        renderDynamicSidebar(notes);
      }
    });
  });

  // Auth state change
  if (window.dmAuth) {
    function subscribeDynSidebarAuth() {
      window.dmAuth.onAuthStateChanged(function(user) {
        if (user) {
          // Try to render from cache immediately
          if (window.dmSync) {
            window.dmSync.getAllNotes().then(function(notes) {
              if (notes.length > 0) {
                renderDynamicSidebar(notes);
              }
              // Sync will fire dm-sync-complete which will re-render
            });
          }
        } else {
          renderAuthPrompt();
        }
      });
    }
    if (window.dmAuthReady) {
      window.dmAuthReady.then(subscribeDynSidebarAuth);
    } else {
      subscribeDynSidebarAuth();
    }
  }
})();
</script>

<!-- Dynamic ToC builder + scroll spy -->
<script>
(function() {
  'use strict';

  var toc = document.querySelector('.book-toc');
  if (!toc) return;

  var tocContent = toc.querySelector('.book-toc-content');
  if (!tocContent) return;

  var progressBar = document.getElementById('toc-progress-bar');
  var rafId = null;
  var headingMap = [];
  var tocLinks = [];

  // Slugify heading text to create IDs
  function slugify(text) {
    return text.toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  // Build ToC from rendered DOM headings
  function buildDynamicToc() {
    // Find the content area where marked.js renders
    var contentArea = document.querySelector('.note-viewer-body') ||
                      document.querySelector('.single-note-body') ||
                      document.querySelector('.section-notes-list') ||
                      document.querySelector('article.markdown');
    if (!contentArea) return;

    var headings = contentArea.querySelectorAll('h1, h2, h3, h4');
    if (headings.length < 2) {
      toc.style.display = 'none';
      return;
    }

    // Ensure headings have IDs (deduplicate slugs)
    var usedIds = {};
    headings.forEach(function(h) {
      if (!h.id) {
        var base = slugify(h.textContent);
        if (!base) base = 'heading';
        var id = base;
        if (usedIds[id]) {
          var n = 1;
          while (usedIds[id + '-' + n]) n++;
          id = id + '-' + n;
        }
        usedIds[id] = true;
        h.id = id;
      } else {
        usedIds[h.id] = true;
      }
    });

    // Determine the minimum heading level present
    var minLevel = 6;
    headings.forEach(function(h) {
      var level = parseInt(h.tagName.charAt(1));
      if (level < minLevel) minLevel = level;
    });

    // Build nested list HTML
    var html = '<nav id="TableOfContents"><ul>';
    var prevLevel = minLevel;

    headings.forEach(function(h) {
      var level = parseInt(h.tagName.charAt(1));
      var text = h.textContent;
      var id = h.id;

      // Handle nesting
      if (level > prevLevel) {
        for (var i = 0; i < level - prevLevel; i++) {
          html += '<ul>';
        }
      } else if (level < prevLevel) {
        for (var i = 0; i < prevLevel - level; i++) {
          html += '</li></ul>';
        }
        html += '</li>';
      } else if (html !== '<nav id="TableOfContents"><ul>') {
        html += '</li>';
      }

      html += '<li><a href="#' + id + '">' + text + '</a>';
      prevLevel = level;
    });

    // Close remaining tags
    for (var i = 0; i < prevLevel - minLevel; i++) {
      html += '</li></ul>';
    }
    html += '</li></ul></nav>';

    // Inject into ToC container (after progress bar and header)
    var existingNav = tocContent.querySelector('nav#TableOfContents');
    if (existingNav) {
      existingNav.remove();
    }
    tocContent.insertAdjacentHTML('beforeend', html);

    toc.style.display = '';

    // Re-initialize scroll spy
    initScrollSpy();
  }

  function initScrollSpy() {
    headingMap = [];
    var tocNav = tocContent.querySelector('nav#TableOfContents');
    tocLinks = tocNav ? Array.from(tocNav.querySelectorAll('a')) : [];

    if (tocLinks.length < 2) {
      toc.style.display = 'none';
      return;
    }

    tocLinks.forEach(function(link) {
      var href = link.getAttribute('href');
      if (!href || href.charAt(0) !== '#') return;
      var id = decodeURIComponent(href.substring(1));
      var heading = document.getElementById(id);
      if (heading) {
        headingMap.push({ el: heading, link: link });
      }
    });

    if (!headingMap.length) return;
    // Defer initial highlight so the browser has computed layout positions
    requestAnimationFrame(function() {
      requestAnimationFrame(update);
    });
  }

  function update() {
    rafId = null;

    // Reading progress
    if (progressBar) {
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      var docHeight = document.documentElement.scrollHeight - window.innerHeight;
      var progress = docHeight > 0 ? Math.min(scrollTop / docHeight, 1) : 0;
      progressBar.style.setProperty('--progress', (progress * 100) + '%');
    }

    // Scroll spy — find the heading closest to (but above) the current scroll position
    var scrollPos = window.scrollY || document.documentElement.scrollTop;
    var offset = 80;
    var activeHeading = null;

    // If at or near the top of the page, always highlight the first heading
    if (scrollPos <= offset) {
      activeHeading = headingMap.length > 0 ? headingMap[0] : null;
    } else {
      for (var i = headingMap.length - 1; i >= 0; i--) {
        if (headingMap[i].el.offsetTop <= scrollPos + offset) {
          activeHeading = headingMap[i];
          break;
        }
      }

      if (!activeHeading && headingMap.length > 0) {
        activeHeading = headingMap[0];
      }
    }

    tocLinks.forEach(function(link) {
      link.classList.remove('active');
      link.parentElement.classList.remove('toc-active');
    });

    if (activeHeading) {
      activeHeading.link.classList.add('active');
      activeHeading.link.parentElement.classList.add('toc-active');
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = requestAnimationFrame(update);
    }
  }

  window.addEventListener('scroll', onScroll, { passive: true });

  // Listen for dynamically rendered content
  window.addEventListener('dm-content-rendered', function() {
    buildDynamicToc();
  });

  // Also try building from Hugo's static ToC on page load
  var existingNav = tocContent.querySelector('nav#TableOfContents');
  var existingLinks = existingNav ? existingNav.querySelectorAll('a') : [];
  if (existingLinks.length >= 2) {
    initScrollSpy();
  } else {
    // No static ToC — hide until dynamic content arrives
    toc.style.display = 'none';
  }
})();
</script>

