<!-- dm-sync: IndexedDB cache layer + Firestore sync engine -->

<!-- Reminder banner container -->
<div id="dm-reminder-banner-container"></div>

<!-- Offline indicator -->
<div id="dm-offline-indicator" class="dm-offline-indicator" style="display: none;">
  <svg class="dm-offline-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.56 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>
  <span class="dm-offline-text">Offline</span>
</div>
<style>
#dm-reminder-banner-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100000;
  display: flex;
  flex-direction: column;
}
.dm-reminder-banner {
  background: var(--color-link, #0055bb);
  color: #fff;
  padding: 0.5rem 1rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  transform: translateY(-100%);
  opacity: 0;
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s ease;
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}
.dm-reminder-banner.dm-banner--in {
  transform: translateY(0);
  opacity: 1;
}
.dm-reminder-banner.dm-banner--out {
  transform: translateY(-100%);
  opacity: 0;
}
.dm-reminder-banner-icon {
  flex-shrink: 0;
  width: 20px;
  height: 20px;
  animation: dm-bell-ring 0.8s ease-in-out 0.4s;
  transform-origin: top center;
}
@keyframes dm-bell-ring {
  0%, 100% { transform: rotate(0); }
  15% { transform: rotate(14deg); }
  30% { transform: rotate(-12deg); }
  45% { transform: rotate(10deg); }
  60% { transform: rotate(-8deg); }
  75% { transform: rotate(4deg); }
}
.dm-reminder-banner-body {
  flex: 1;
  min-width: 0;
  display: flex;
  align-items: baseline;
  gap: 0.5rem;
  overflow: hidden;
}
.dm-reminder-banner-label {
  font-weight: 600;
  font-size: 0.8125rem;
  white-space: nowrap;
  flex-shrink: 0;
}
.dm-reminder-banner-text {
  font-size: 0.8125rem;
  opacity: 0.9;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.dm-reminder-banner-ack {
  flex-shrink: 0;
  background: rgba(255,255,255,0.2);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: 5px;
  padding: 0.25rem 0.75rem;
  font-size: 0.75rem;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.15s;
}
.dm-reminder-banner-ack:hover {
  background: rgba(255,255,255,0.35);
}

@media (max-width: 600px) {
  .dm-reminder-banner {
    padding: 0.5rem 0.75rem;
    gap: 0.5rem;
  }
  .dm-reminder-banner-body {
    flex-direction: column;
    gap: 0;
  }
  .dm-reminder-banner-ack {
    padding: 0.2rem 0.6rem;
  }
}

/* Offline indicator */
.dm-offline-indicator {
  position: fixed;
  bottom: 24px;
  left: 24px;
  z-index: 1060;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--gray-800, #333);
  color: #fff;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s, transform 0.3s;
  pointer-events: none;
}
.dm-offline-indicator.dm-offline--show {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
.dm-offline-icon {
  flex-shrink: 0;
}
@media (max-width: 600px) {
  .dm-offline-indicator {
    bottom: 16px;
    left: 16px;
  }
}
</style>

<script>
(function() {
  'use strict';

  var DB_NAME = 'dm-notes';
  var DB_VERSION = 4;
  var STORE_NOTES = 'notes';
  var STORE_TODOS = 'todos';
  var STORE_META = 'meta';
  var STORE_WRITE_QUEUE = 'writeQueue';
  var SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes
  var _db = null;
  var _syncTimer = null;
  var _syncing = false;
  var _isOnline = navigator.onLine;
  var _draining = false;

  // ─── IndexedDB Wrapper ───

  function openDB() {
    return new Promise(function(resolve, reject) {
      if (_db) { resolve(_db); return; }
      var req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = function(e) {
        var db = e.target.result;
        var tx = e.target.transaction;
        if (!db.objectStoreNames.contains(STORE_NOTES)) {
          var store = db.createObjectStore(STORE_NOTES, { keyPath: 'id' });
          store.createIndex('destination', 'destination', { unique: false });
          store.createIndex('language', 'language', { unique: false });
          store.createIndex('bookTitle', 'bookTitle', { unique: false });
          store.createIndex('updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_META)) {
          db.createObjectStore(STORE_META, { keyPath: 'key' });
        }
        if (!db.objectStoreNames.contains(STORE_TODOS)) {
          var todoStore = db.createObjectStore(STORE_TODOS, { keyPath: 'id' });
          todoStore.createIndex('parentId', 'parentId', { unique: false });
          todoStore.createIndex('done', 'done', { unique: false });
          todoStore.createIndex('order', 'order', { unique: false });
          todoStore.createIndex('updatedAt', 'updatedAt', { unique: false });
          todoStore.createIndex('reminderAt', 'reminderAt', { unique: false });
        } else {
          // Upgrading existing todos store — add reminderAt index if missing
          var existingStore = tx.objectStore(STORE_TODOS);
          if (!existingStore.indexNames.contains('reminderAt')) {
            existingStore.createIndex('reminderAt', 'reminderAt', { unique: false });
          }
        }
        // Offline write queue store (v4)
        if (!db.objectStoreNames.contains(STORE_WRITE_QUEUE)) {
          db.createObjectStore(STORE_WRITE_QUEUE, { keyPath: 'queueId', autoIncrement: true });
        }
      };
      req.onsuccess = function(e) {
        _db = e.target.result;
        resolve(_db);
      };
      req.onerror = function(e) {
        console.error('IndexedDB open error:', e.target.error);
        reject(e.target.error);
      };
    });
  }

  function idbPut(storeName, data) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(data);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGet(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).get(key);
        req.onsuccess = function() { resolve(req.result); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGetAll(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).getAll();
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbDelete(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbClear(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).clear();
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbPutBatch(storeName, items) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        var store = tx.objectStore(storeName);
        items.forEach(function(item) { store.put(item); });
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  // ─── Offline Write Queue ───
  // Queues Firestore operations when offline; drains on reconnect.
  // Each queued entry: { collection, docId, op: 'set'|'update'|'delete', data, timestamp }

  function queueWrite(entry) {
    entry.timestamp = Date.now();
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).add(entry);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function getAllQueued() {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readonly');
        var req = tx.objectStore(STORE_WRITE_QUEUE).getAll();
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function removeQueued(queueId) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).delete(queueId);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function clearQueue() {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).clear();
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  /**
   * Execute a Firestore write with offline queue fallback.
   * @param {Object} opts
   *   collection: string — 'notes' or 'todos'
   *   docId: string — document ID
   *   op: 'set'|'update'|'delete' — Firestore operation
   *   data: Object|null — data for set/update (null for delete)
   *   localOp: function|null — optional callback to apply optimistic IDB write immediately
   * @returns {Promise}
   */
  function firestoreWrite(opts) {
    // Always apply local operation first (optimistic)
    var localPromise = opts.localOp ? opts.localOp() : Promise.resolve();

    return localPromise.then(function() {
      if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser || !_isOnline) {
        // Offline or no Firestore — queue for later
        console.log('[dm-sync] Queuing offline write:', opts.op, opts.collection, opts.docId);
        return queueWrite({
          collection: opts.collection,
          docId: opts.docId,
          op: opts.op,
          data: opts.data || null
        }).then(function() {
          updateOfflineIndicator();
        });
      }

      // Online — try Firestore directly
      var ref = window.dmDb.collection(opts.collection).doc(opts.docId);
      var fsPromise;
      if (opts.op === 'set') {
        fsPromise = ref.set(opts.data);
      } else if (opts.op === 'update') {
        fsPromise = ref.update(opts.data);
      } else if (opts.op === 'delete') {
        fsPromise = ref.delete();
      } else {
        return Promise.reject(new Error('Unknown op: ' + opts.op));
      }

      return fsPromise.catch(function(err) {
        // Firestore write failed (maybe went offline mid-write) — queue it
        console.warn('[dm-sync] Firestore write failed, queuing:', err.message);
        return queueWrite({
          collection: opts.collection,
          docId: opts.docId,
          op: opts.op,
          data: opts.data || null
        }).then(function() {
          updateOfflineIndicator();
        });
      });
    });
  }

  /**
   * Drain the offline write queue. Called on reconnect.
   * Processes entries in FIFO order. If an entry fails, stops and retries later.
   */
  function drainQueue() {
    if (_draining) return Promise.resolve();
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser || !_isOnline) {
      return Promise.resolve();
    }
    _draining = true;
    console.log('[dm-sync] Draining offline write queue...');

    return getAllQueued().then(function(entries) {
      if (entries.length === 0) {
        _draining = false;
        updateOfflineIndicator();
        return;
      }

      console.log('[dm-sync] Queue has ' + entries.length + ' pending write(s)');

      // Process sequentially to preserve order
      var chain = Promise.resolve();
      var processed = 0;
      var failed = false;

      entries.forEach(function(entry) {
        chain = chain.then(function() {
          if (failed) return; // stop on first failure

          var ref = window.dmDb.collection(entry.collection).doc(entry.docId);
          var fsPromise;
          if (entry.op === 'set') {
            fsPromise = ref.set(entry.data);
          } else if (entry.op === 'update') {
            fsPromise = ref.update(entry.data);
          } else if (entry.op === 'delete') {
            fsPromise = ref.delete();
          } else {
            // Unknown op — remove from queue
            return removeQueued(entry.queueId);
          }

          return fsPromise.then(function() {
            processed++;
            return removeQueued(entry.queueId);
          }).catch(function(err) {
            // Check if it's a "not found" error for update/delete — remove from queue
            if (err.code === 'not-found') {
              console.warn('[dm-sync] Doc not found, removing queued op:', entry.collection, entry.docId);
              return removeQueued(entry.queueId);
            }
            console.warn('[dm-sync] Queue drain failed at entry, will retry:', err.message);
            failed = true;
          });
        });
      });

      return chain.then(function() {
        _draining = false;
        console.log('[dm-sync] Queue drain complete. Processed: ' + processed + '/' + entries.length);
        updateOfflineIndicator();

        // If all succeeded, trigger a sync to reconcile
        if (!failed && processed > 0) {
          var user = window.dmAuth.currentUser;
          if (user) {
            syncAll(user.uid).catch(function() {});
          }
        }

        // If some failed, retry after a delay
        if (failed) {
          setTimeout(drainQueue, 10000);
        }
      });
    }).catch(function(err) {
      console.warn('[dm-sync] Queue drain error:', err);
      _draining = false;
    });
  }

  // ─── Online/Offline Detection ───

  function updateOfflineIndicator() {
    getAllQueued().then(function(entries) {
      var indicator = document.getElementById('dm-offline-indicator');
      if (!indicator) return;

      if (!_isOnline) {
        indicator.style.display = '';
        indicator.querySelector('.dm-offline-text').textContent = 'Offline' + (entries.length ? ' (' + entries.length + ' pending)' : '');
        indicator.classList.add('dm-offline--show');
      } else if (entries.length > 0) {
        indicator.style.display = '';
        indicator.querySelector('.dm-offline-text').textContent = 'Syncing ' + entries.length + ' change' + (entries.length > 1 ? 's' : '') + '...';
        indicator.classList.add('dm-offline--show');
      } else {
        indicator.classList.remove('dm-offline--show');
        setTimeout(function() { indicator.style.display = 'none'; }, 300);
      }
    }).catch(function() {});
  }

  window.addEventListener('online', function() {
    _isOnline = true;
    console.log('[dm-sync] Back online');
    updateOfflineIndicator();
    // Drain queue after a short delay to let network stabilize
    setTimeout(drainQueue, 1500);
  });

  window.addEventListener('offline', function() {
    _isOnline = false;
    console.log('[dm-sync] Gone offline');
    updateOfflineIndicator();
  });

  // ─── Firestore Document Serializer ───

  function serializeNote(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    return {
      id: doc.id,
      title: data.title || '',
      content: data.content || '',
      mode: data.mode || 'note',
      destination: data.destination || 'inbox',
      language: data.language || null,
      bookTitle: data.bookTitle || null,
      tags: data.tags || [],
      userId: data.userId || '',
      userEmail: data.userEmail || '',
      userName: data.userName || '',
      createdAt: createdAt,
      updatedAt: updatedAt
    };
  }

  function serializeTodo(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    var completedAt = data.completedAt ? data.completedAt.toMillis() : null;
    var reminderAt = data.reminderAt ? data.reminderAt.toMillis() : null;
    return {
      id: doc.id,
      userId: data.userId || '',
      title: data.title || '',
      estimatedMin: data.estimatedMin || 0,
      actualMin: data.actualMin != null ? data.actualMin : null,
      category: data.category || null,
      done: !!data.done,
      parentId: data.parentId || null,
      order: data.order || 0,
      scheduledDate: data.scheduledDate || null,
      reminderAt: reminderAt,
      reminderFired: !!data.reminderFired,
      createdAt: createdAt,
      updatedAt: updatedAt,
      completedAt: completedAt
    };
  }

  // ─── Sync Engine ───

  function syncNotes(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Starting sync...');
    var startTime = Date.now();

    // Full sync: fetch all notes for user, diff with local
    return window.dmDb.collection('notes')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteNotes = [];
        snapshot.forEach(function(doc) {
          remoteNotes.push(serializeNote(doc));
        });

        return idbGetAll(STORE_NOTES).then(function(localNotes) {
          var localMap = {};
          localNotes.forEach(function(n) { localMap[n.id] = n; });

          var remoteMap = {};
          remoteNotes.forEach(function(n) { remoteMap[n.id] = n; });

          // Find notes to upsert (new or updated)
          var toUpsert = [];
          remoteNotes.forEach(function(rn) {
            var ln = localMap[rn.id];
            if (!ln || ln.updatedAt !== rn.updatedAt) {
              toUpsert.push(rn);
            }
          });

          // Find notes to delete locally (exist locally but not remotely)
          var toDelete = [];
          localNotes.forEach(function(ln) {
            if (!remoteMap[ln.id]) {
              toDelete.push(ln.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_NOTES, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_NOTES, id));
          });

          return Promise.all(promises).then(function() {
            return idbPut(STORE_META, { key: 'lastSyncTime', value: Date.now() });
          }).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Notes sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  function syncTodos(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Syncing todos...');
    var startTime = Date.now();

    return window.dmDb.collection('todos')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteTodos = [];
        snapshot.forEach(function(doc) {
          remoteTodos.push(serializeTodo(doc));
        });

        return idbGetAll(STORE_TODOS).then(function(localTodos) {
          var localMap = {};
          localTodos.forEach(function(t) { localMap[t.id] = t; });

          var remoteMap = {};
          remoteTodos.forEach(function(t) { remoteMap[t.id] = t; });

          var toUpsert = [];
          remoteTodos.forEach(function(rt) {
            var lt = localMap[rt.id];
            if (!lt || lt.updatedAt !== rt.updatedAt) {
              toUpsert.push(rt);
            }
          });

          var toDelete = [];
          localTodos.forEach(function(lt) {
            if (!remoteMap[lt.id]) {
              toDelete.push(lt.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_TODOS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_TODOS, id));
          });

          return Promise.all(promises).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Todos sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  function syncAll(userId) {
    if (_syncing) return Promise.resolve();
    _syncing = true;

    return syncNotes(userId)
      .then(function() { return syncTodos(userId); })
      .then(function() {
        _syncing = false;
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      })
      .catch(function(err) {
        console.error('[dm-sync] Sync error:', err);
        _syncing = false;
        throw err;
      });
  }

  function startBackgroundSync(userId) {
    stopBackgroundSync();
    _syncTimer = setInterval(function() {
      syncAll(userId).catch(function(err) {
        console.warn('[dm-sync] Background sync failed:', err);
      });
    }, SYNC_INTERVAL);
  }

  function stopBackgroundSync() {
    if (_syncTimer) {
      clearInterval(_syncTimer);
      _syncTimer = null;
    }
  }

  // ─── Reminder Timer Engine ───

  var _reminderTimers = {}; // todoId -> timeoutId
  var MAX_TIMEOUT = 2147483647; // 2^31 - 1 ms (~24.8 days)

  // ─── Notification Chime (Web Audio API) ───

  function playReminderChime() {
    try {
      var ctx = new (window.AudioContext || window.webkitAudioContext)();
      var notes = [
        { freq: 830, start: 0, dur: 0.12 },
        { freq: 1050, start: 0.13, dur: 0.12 },
        { freq: 1250, start: 0.26, dur: 0.18 }
      ];
      notes.forEach(function(n) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = n.freq;
        gain.gain.setValueAtTime(0.15, ctx.currentTime + n.start);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + n.start + n.dur);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + n.start);
        osc.stop(ctx.currentTime + n.start + n.dur + 0.05);
      });
      // Close context after sound finishes
      setTimeout(function() { ctx.close(); }, 600);
    } catch(e) {
      // Audio not available — silent fallback
    }
  }

  // ─── Persistent Reminder Banner ───

  function showReminderBanner(title, text) {
    var container = document.getElementById('dm-reminder-banner-container');
    if (!container) return;

    var banner = document.createElement('div');
    banner.className = 'dm-reminder-banner';
    banner.innerHTML =
      '<svg class="dm-reminder-banner-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">' +
        '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>' +
        '<path d="M13.73 21a2 2 0 0 1-3.46 0"/>' +
      '</svg>' +
      '<div class="dm-reminder-banner-body">' +
        '<span class="dm-reminder-banner-label"></span>' +
        '<span class="dm-reminder-banner-text"></span>' +
      '</div>' +
      '<button class="dm-reminder-banner-ack">Acknowledge</button>';

    // Set text content safely (no innerHTML for user data)
    banner.querySelector('.dm-reminder-banner-label').textContent = title;
    banner.querySelector('.dm-reminder-banner-text').textContent = text;

    container.appendChild(banner);

    // Slide down
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        banner.classList.add('dm-banner--in');
      });
    });

    // Acknowledge = dismiss
    banner.querySelector('.dm-reminder-banner-ack').addEventListener('click', function() {
      banner.classList.remove('dm-banner--in');
      banner.classList.add('dm-banner--out');
      setTimeout(function() {
        if (banner.parentNode) banner.parentNode.removeChild(banner);
      }, 450);
    });
  }

  function clearReminderTimer(todoId) {
    if (_reminderTimers[todoId]) {
      clearTimeout(_reminderTimers[todoId]);
      delete _reminderTimers[todoId];
    }
  }

  function clearAllReminderTimers() {
    Object.keys(_reminderTimers).forEach(function(id) {
      clearTimeout(_reminderTimers[id]);
    });
    _reminderTimers = {};
  }

  function buildReminderBody(todo) {
    var parts = [todo.title];
    if (todo.estimatedMin) parts.push(todo.estimatedMin + 'min');
    if (todo.scheduledDate) {
      var today = new Date(); today.setHours(0,0,0,0);
      var d = new Date(todo.scheduledDate + 'T00:00:00');
      var diff = Math.round((d - today) / 86400000);
      if (diff === 0) parts.push('Today');
      else if (diff === 1) parts.push('Tomorrow');
      else parts.push(todo.scheduledDate);
    }
    return parts.join(' \u2014 '); // em dash
  }

  function fireReminder(todo) {
    var body = buildReminderBody(todo);

    // Show persistent banner + play chime
    playReminderChime();
    showReminderBanner('Reminder:', body);

    // Mark as fired — optimistic local write + queued Firestore write
    todo.reminderFired = true;
    todo.updatedAt = Date.now();
    firestoreWrite({
      collection: 'todos',
      docId: todo.id,
      op: 'update',
      data: {
        reminderFired: true,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      },
      localOp: function() {
        return idbPut(STORE_TODOS, todo);
      }
    }).then(function() {
      window.dispatchEvent(new CustomEvent('dm-todos-updated'));
    });
  }

  function scheduleReminder(todo) {
    clearReminderTimer(todo.id);

    if (!todo.reminderAt || todo.reminderFired || todo.done) return;

    var now = Date.now();
    var delay = todo.reminderAt - now;

    if (delay <= 0) {
      // Overdue — fire immediately
      fireReminder(todo);
      return;
    }

    // Cap at MAX_TIMEOUT; for longer delays, re-schedule instead of firing early
    var actualDelay = Math.min(delay, MAX_TIMEOUT);
    _reminderTimers[todo.id] = setTimeout(function() {
      delete _reminderTimers[todo.id];
      // Re-check in case it was cancelled or fired
      idbGet(STORE_TODOS, todo.id).then(function(latest) {
        if (latest && !latest.reminderFired && !latest.done && latest.reminderAt) {
          // If reminder time is still in the future (delay was capped), re-schedule
          if (latest.reminderAt > Date.now()) {
            scheduleReminder(latest);
          } else {
            fireReminder(latest);
          }
        }
      });
    }, actualDelay);
  }

  function scheduleAllReminders() {
    clearAllReminderTimers();
    idbGetAll(STORE_TODOS).then(function(todos) {
      todos.forEach(function(t) {
        if (t.reminderAt && !t.reminderFired && !t.done) {
          scheduleReminder(t);
        }
      });
    }).catch(function(err) {
      console.warn('[dm-sync] Failed to schedule reminders:', err);
    });
  }

  // Re-evaluate timers when todos change
  window.addEventListener('dm-todos-updated', function() {
    scheduleAllReminders();
  });

  // ─── Public API ───

  window.dmSync = {
    // IndexedDB operations — Notes
    getNote: function(id) { return idbGet(STORE_NOTES, id); },
    getAllNotes: function() { return idbGetAll(STORE_NOTES); },
    putNote: function(note) {
      return idbPut(STORE_NOTES, note).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    deleteNote: function(id) {
      return idbDelete(STORE_NOTES, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },

    // IndexedDB operations — Todos
    getTodo: function(id) { return idbGet(STORE_TODOS, id); },
    getAllTodos: function() { return idbGetAll(STORE_TODOS); },
    putTodo: function(todo) {
      return idbPut(STORE_TODOS, todo).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    deleteTodo: function(id) {
      return idbDelete(STORE_TODOS, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    getTodosByParent: function(parentId) {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return t.parentId === parentId; });
      });
    },
    getTopLevelTodos: function() {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return !t.parentId; });
      });
    },
    setReminder: function(todoId, reminderAtMs) {
      return idbGet(STORE_TODOS, todoId).then(function(todo) {
        if (!todo) return;
        todo.reminderAt = reminderAtMs;
        todo.reminderFired = false;
        todo.updatedAt = Date.now();
        return firestoreWrite({
          collection: 'todos',
          docId: todoId,
          op: 'update',
          data: {
            reminderAt: firebase.firestore.Timestamp.fromMillis(reminderAtMs),
            reminderFired: false,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          },
          localOp: function() {
            return idbPut(STORE_TODOS, todo);
          }
        }).then(function() {
          scheduleReminder(todo);
          window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        });
      });
    },
    clearReminder: function(todoId) {
      clearReminderTimer(todoId);
      return idbGet(STORE_TODOS, todoId).then(function(todo) {
        if (!todo) return;
        todo.reminderAt = null;
        todo.reminderFired = false;
        todo.updatedAt = Date.now();
        return firestoreWrite({
          collection: 'todos',
          docId: todoId,
          op: 'update',
          data: {
            reminderAt: null,
            reminderFired: false,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          },
          localOp: function() {
            return idbPut(STORE_TODOS, todo);
          }
        }).then(function() {
          window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        });
      });
    },

    // Query helpers — Notes
    getNotesByDestination: function(destination) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.destination === destination; });
      });
    },
    getNotesByLanguage: function(language) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.language === language; });
      });
    },
    getNotesByBookTitle: function(bookTitle) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.bookTitle === bookTitle; });
      });
    },
    getBookTitles: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var titles = {};
        notes.forEach(function(n) {
          if (n.destination === 'book-note' && n.bookTitle) {
            titles[n.bookTitle] = true;
          }
        });
        return Object.keys(titles).sort();
      });
    },
    getSnippetLanguages: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var langs = {};
        notes.forEach(function(n) {
          if (n.destination === 'snippets' && n.language) {
            langs[n.language] = true;
          }
        });
        return Object.keys(langs).sort();
      });
    },

    // Query helpers — Tags
    getAllTags: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var tagMap = {};
        notes.forEach(function(n) {
          if (n.tags && n.tags.length) {
            n.tags.forEach(function(t) {
              if (!tagMap[t]) tagMap[t] = 0;
              tagMap[t]++;
            });
          }
        });
        return Object.keys(tagMap).map(function(tag) {
          return { tag: tag, count: tagMap[tag] };
        }).sort(function(a, b) { return b.count - a.count || a.tag.localeCompare(b.tag); });
      });
    },
    getNotesByTag: function(tag) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) {
          return n.tags && n.tags.indexOf(tag) !== -1;
        });
      });
    },

    // Query helpers — Backlinks
    getBacklinksForNote: function(noteId) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var targetNote = null;
        notes.forEach(function(n) { if (n.id === noteId) targetNote = n; });
        if (!targetNote || !targetNote.title) return [];

        var results = [];
        var titleLower = targetNote.title.toLowerCase();
        var escapedTitle = targetNote.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var wikilinkPattern = new RegExp('\\[\\[' + escapedTitle + '\\]\\]', 'i');

        notes.forEach(function(n) {
          if (n.id === noteId) return;
          if (!n.content) return;

          var isExplicit = wikilinkPattern.test(n.content);
          var isTitleMatch = !isExplicit && titleLower.length > 3 && n.content.toLowerCase().indexOf(titleLower) !== -1;

          if (isExplicit || isTitleMatch) {
            results.push({
              note: n,
              type: isExplicit ? 'wikilink' : 'mention',
              confidence: isExplicit ? 'high' : 'medium'
            });
          }
        });

        return results.sort(function(a, b) {
          if (a.type !== b.type) return a.type === 'wikilink' ? -1 : 1;
          return (b.note.updatedAt || 0) - (a.note.updatedAt || 0);
        });
      });
    },

    // Sync operations
    sync: function(userId) { return syncAll(userId); },
    syncNotes: function(userId) { return syncNotes(userId); },
    syncTodos: function(userId) { return syncTodos(userId); },
    startBackgroundSync: startBackgroundSync,
    stopBackgroundSync: stopBackgroundSync,

    // Check if cache has data
    hasCachedData: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.length > 0;
      });
    },

    // Clear cache (on logout)
    clearCache: function() {
      stopBackgroundSync();
      return Promise.all([
        idbClear(STORE_NOTES),
        idbClear(STORE_TODOS),
        idbClear(STORE_META),
        clearQueue()
      ]).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        updateOfflineIndicator();
      });
    },

    // Offline write support
    firestoreWrite: firestoreWrite,
    drainQueue: drainQueue,
    isOnline: function() { return _isOnline; },
    getQueuedCount: function() {
      return getAllQueued().then(function(entries) { return entries.length; });
    },

    // Reminder banner (for use by other partials)
    showReminderBanner: showReminderBanner
  };

  // ─── Auto-sync on Auth State Change ───

  if (window.dmAuth) {
    window.dmAuth.onAuthStateChanged(function(user) {
      if (user) {
        // Check if this is a different user than last cached session
        idbGet(STORE_META, 'currentUserId').then(function(meta) {
          var cachedUserId = meta ? meta.value : null;
          var proceed = cachedUserId === user.uid
            ? Promise.resolve()
            : Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META), clearQueue()]);

          return proceed.then(function() {
            return idbPut(STORE_META, { key: 'currentUserId', value: user.uid });
          }).then(function() {
            // Drain any queued offline writes before syncing
            return drainQueue();
          }).then(function() {
            return syncAll(user.uid);
          }).then(function() {
            startBackgroundSync(user.uid);
            scheduleAllReminders();
            updateOfflineIndicator();
          });
        }).catch(function(err) {
          console.warn('[dm-sync] Initial sync failed, using cached data if available');
          window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        });
      } else {
        stopBackgroundSync();
        clearAllReminderTimers();
        // Clear cache on sign-out so no data leaks to another user
        Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META), clearQueue()])
          .then(function() {
            window.dispatchEvent(new CustomEvent('dm-sync-complete'));
            window.dispatchEvent(new CustomEvent('dm-todos-updated'));
          })
          .catch(function(err) {
            console.warn('[dm-sync] Error clearing cache on sign-out:', err);
          });
      }
    });
  }

})();
</script>
