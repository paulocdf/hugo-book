<!-- dm-sync: IndexedDB cache layer + Firestore sync engine -->
<script>
(function() {
  'use strict';

  var DB_NAME = 'dm-notes';
  var DB_VERSION = 2;
  var STORE_NOTES = 'notes';
  var STORE_TODOS = 'todos';
  var STORE_META = 'meta';
  var SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes
  var _db = null;
  var _syncTimer = null;
  var _syncing = false;

  // ─── IndexedDB Wrapper ───

  function openDB() {
    return new Promise(function(resolve, reject) {
      if (_db) { resolve(_db); return; }
      var req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = function(e) {
        var db = e.target.result;
        if (!db.objectStoreNames.contains(STORE_NOTES)) {
          var store = db.createObjectStore(STORE_NOTES, { keyPath: 'id' });
          store.createIndex('destination', 'destination', { unique: false });
          store.createIndex('language', 'language', { unique: false });
          store.createIndex('bookTitle', 'bookTitle', { unique: false });
          store.createIndex('updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_META)) {
          db.createObjectStore(STORE_META, { keyPath: 'key' });
        }
        if (!db.objectStoreNames.contains(STORE_TODOS)) {
          var todoStore = db.createObjectStore(STORE_TODOS, { keyPath: 'id' });
          todoStore.createIndex('parentId', 'parentId', { unique: false });
          todoStore.createIndex('done', 'done', { unique: false });
          todoStore.createIndex('order', 'order', { unique: false });
          todoStore.createIndex('updatedAt', 'updatedAt', { unique: false });
        }
      };
      req.onsuccess = function(e) {
        _db = e.target.result;
        resolve(_db);
      };
      req.onerror = function(e) {
        console.error('IndexedDB open error:', e.target.error);
        reject(e.target.error);
      };
    });
  }

  function idbPut(storeName, data) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(data);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGet(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).get(key);
        req.onsuccess = function() { resolve(req.result); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGetAll(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).getAll();
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbDelete(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbClear(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).clear();
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbPutBatch(storeName, items) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        var store = tx.objectStore(storeName);
        items.forEach(function(item) { store.put(item); });
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  // ─── Firestore Document Serializer ───

  function serializeNote(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    return {
      id: doc.id,
      title: data.title || '',
      content: data.content || '',
      mode: data.mode || 'note',
      destination: data.destination || 'inbox',
      language: data.language || null,
      bookTitle: data.bookTitle || null,
      tags: data.tags || [],
      userId: data.userId || '',
      userEmail: data.userEmail || '',
      userName: data.userName || '',
      createdAt: createdAt,
      updatedAt: updatedAt
    };
  }

  function serializeTodo(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    var completedAt = data.completedAt ? data.completedAt.toMillis() : null;
    return {
      id: doc.id,
      userId: data.userId || '',
      title: data.title || '',
      estimatedMin: data.estimatedMin || 0,
      actualMin: data.actualMin != null ? data.actualMin : null,
      category: data.category || null,
      done: !!data.done,
      parentId: data.parentId || null,
      order: data.order || 0,
      createdAt: createdAt,
      updatedAt: updatedAt,
      completedAt: completedAt
    };
  }

  // ─── Sync Engine ───

  function syncNotes(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Starting sync...');
    var startTime = Date.now();

    // Full sync: fetch all notes for user, diff with local
    return window.dmDb.collection('notes')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteNotes = [];
        snapshot.forEach(function(doc) {
          remoteNotes.push(serializeNote(doc));
        });

        return idbGetAll(STORE_NOTES).then(function(localNotes) {
          var localMap = {};
          localNotes.forEach(function(n) { localMap[n.id] = n; });

          var remoteMap = {};
          remoteNotes.forEach(function(n) { remoteMap[n.id] = n; });

          // Find notes to upsert (new or updated)
          var toUpsert = [];
          remoteNotes.forEach(function(rn) {
            var ln = localMap[rn.id];
            if (!ln || ln.updatedAt !== rn.updatedAt) {
              toUpsert.push(rn);
            }
          });

          // Find notes to delete locally (exist locally but not remotely)
          var toDelete = [];
          localNotes.forEach(function(ln) {
            if (!remoteMap[ln.id]) {
              toDelete.push(ln.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_NOTES, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_NOTES, id));
          });

          return Promise.all(promises).then(function() {
            return idbPut(STORE_META, { key: 'lastSyncTime', value: Date.now() });
          }).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Notes sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  function syncTodos(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Syncing todos...');
    var startTime = Date.now();

    return window.dmDb.collection('todos')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteTodos = [];
        snapshot.forEach(function(doc) {
          remoteTodos.push(serializeTodo(doc));
        });

        return idbGetAll(STORE_TODOS).then(function(localTodos) {
          var localMap = {};
          localTodos.forEach(function(t) { localMap[t.id] = t; });

          var remoteMap = {};
          remoteTodos.forEach(function(t) { remoteMap[t.id] = t; });

          var toUpsert = [];
          remoteTodos.forEach(function(rt) {
            var lt = localMap[rt.id];
            if (!lt || lt.updatedAt !== rt.updatedAt) {
              toUpsert.push(rt);
            }
          });

          var toDelete = [];
          localTodos.forEach(function(lt) {
            if (!remoteMap[lt.id]) {
              toDelete.push(lt.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_TODOS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_TODOS, id));
          });

          return Promise.all(promises).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Todos sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  function syncAll(userId) {
    if (_syncing) return Promise.resolve();
    _syncing = true;

    return syncNotes(userId)
      .then(function() { return syncTodos(userId); })
      .then(function() {
        _syncing = false;
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      })
      .catch(function(err) {
        console.error('[dm-sync] Sync error:', err);
        _syncing = false;
        throw err;
      });
  }

  function startBackgroundSync(userId) {
    stopBackgroundSync();
    _syncTimer = setInterval(function() {
      syncAll(userId).catch(function(err) {
        console.warn('[dm-sync] Background sync failed:', err);
      });
    }, SYNC_INTERVAL);
  }

  function stopBackgroundSync() {
    if (_syncTimer) {
      clearInterval(_syncTimer);
      _syncTimer = null;
    }
  }

  // ─── Public API ───

  window.dmSync = {
    // IndexedDB operations — Notes
    getNote: function(id) { return idbGet(STORE_NOTES, id); },
    getAllNotes: function() { return idbGetAll(STORE_NOTES); },
    putNote: function(note) {
      return idbPut(STORE_NOTES, note).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    deleteNote: function(id) {
      return idbDelete(STORE_NOTES, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },

    // IndexedDB operations — Todos
    getTodo: function(id) { return idbGet(STORE_TODOS, id); },
    getAllTodos: function() { return idbGetAll(STORE_TODOS); },
    putTodo: function(todo) {
      return idbPut(STORE_TODOS, todo).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    deleteTodo: function(id) {
      return idbDelete(STORE_TODOS, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    getTodosByParent: function(parentId) {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return t.parentId === parentId; });
      });
    },
    getTopLevelTodos: function() {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return !t.parentId; });
      });
    },

    // Query helpers — Notes
    getNotesByDestination: function(destination) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.destination === destination; });
      });
    },
    getNotesByLanguage: function(language) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.language === language; });
      });
    },
    getNotesByBookTitle: function(bookTitle) {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return n.bookTitle === bookTitle; });
      });
    },
    getBookTitles: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var titles = {};
        notes.forEach(function(n) {
          if (n.destination === 'book-note' && n.bookTitle) {
            titles[n.bookTitle] = true;
          }
        });
        return Object.keys(titles).sort();
      });
    },
    getSnippetLanguages: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var langs = {};
        notes.forEach(function(n) {
          if (n.destination === 'snippets' && n.language) {
            langs[n.language] = true;
          }
        });
        return Object.keys(langs).sort();
      });
    },

    // Sync operations
    sync: function(userId) { return syncAll(userId); },
    syncNotes: function(userId) { return syncNotes(userId); },
    syncTodos: function(userId) { return syncTodos(userId); },
    startBackgroundSync: startBackgroundSync,
    stopBackgroundSync: stopBackgroundSync,

    // Check if cache has data
    hasCachedData: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.length > 0;
      });
    },

    // Clear cache (on logout)
    clearCache: function() {
      stopBackgroundSync();
      return Promise.all([
        idbClear(STORE_NOTES),
        idbClear(STORE_TODOS),
        idbClear(STORE_META)
      ]).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    }
  };

  // ─── Auto-sync on Auth State Change ───

  if (window.dmAuth) {
    window.dmAuth.onAuthStateChanged(function(user) {
      if (user) {
        // Check if this is a different user than last cached session
        idbGet(STORE_META, 'currentUserId').then(function(meta) {
          var cachedUserId = meta ? meta.value : null;
          var proceed = cachedUserId === user.uid
            ? Promise.resolve()
            : Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META)]);

          return proceed.then(function() {
            return idbPut(STORE_META, { key: 'currentUserId', value: user.uid });
          }).then(function() {
            return syncAll(user.uid);
          }).then(function() {
            startBackgroundSync(user.uid);
          });
        }).catch(function(err) {
          console.warn('[dm-sync] Initial sync failed, using cached data if available');
          window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        });
      } else {
        stopBackgroundSync();
        // Clear cache on sign-out so no data leaks to another user
        Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META)])
          .then(function() {
            window.dispatchEvent(new CustomEvent('dm-sync-complete'));
            window.dispatchEvent(new CustomEvent('dm-todos-updated'));
          })
          .catch(function(err) {
            console.warn('[dm-sync] Error clearing cache on sign-out:', err);
          });
      }
    });
  }

})();
</script>
