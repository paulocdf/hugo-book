<!-- dm-sync: IndexedDB cache layer + Firestore sync engine -->

<!-- Reminder banner container -->
<div id="dm-reminder-banner-container"></div>

<!-- Offline indicator -->
<div id="dm-offline-indicator" class="dm-offline-indicator" style="display: none;">
  <svg class="dm-offline-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.56 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>
  <span class="dm-offline-text">Offline</span>
</div>
<style>
#dm-reminder-banner-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100000;
  display: flex;
  flex-direction: column;
}
.dm-reminder-banner {
  background: var(--color-link, #0055bb);
  color: #fff;
  padding: 0.5rem 1rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  transform: translateY(-100%);
  opacity: 0;
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.3s ease;
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}
.dm-reminder-banner.dm-banner--in {
  transform: translateY(0);
  opacity: 1;
}
.dm-reminder-banner.dm-banner--out {
  transform: translateY(-100%);
  opacity: 0;
}
.dm-reminder-banner-icon {
  flex-shrink: 0;
  width: 20px;
  height: 20px;
  animation: dm-bell-ring 0.8s ease-in-out 0.4s;
  transform-origin: top center;
}
@keyframes dm-bell-ring {
  0%, 100% { transform: rotate(0); }
  15% { transform: rotate(14deg); }
  30% { transform: rotate(-12deg); }
  45% { transform: rotate(10deg); }
  60% { transform: rotate(-8deg); }
  75% { transform: rotate(4deg); }
}
.dm-reminder-banner-body {
  flex: 1;
  min-width: 0;
  display: flex;
  align-items: baseline;
  gap: 0.5rem;
  overflow: hidden;
}
.dm-reminder-banner-label {
  font-weight: 600;
  font-size: 0.8125rem;
  white-space: nowrap;
  flex-shrink: 0;
}
.dm-reminder-banner-text {
  font-size: 0.8125rem;
  opacity: 0.9;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.dm-reminder-banner-ack {
  flex-shrink: 0;
  background: rgba(255,255,255,0.2);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: 5px;
  padding: 0.25rem 0.75rem;
  font-size: 0.75rem;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  transition: background 0.15s;
}
.dm-reminder-banner-ack:hover {
  background: rgba(255,255,255,0.35);
}

@media (max-width: 600px) {
  .dm-reminder-banner {
    padding: 0.5rem 0.75rem;
    gap: 0.5rem;
  }
  .dm-reminder-banner-body {
    flex-direction: column;
    gap: 0;
  }
  .dm-reminder-banner-ack {
    padding: 0.2rem 0.6rem;
  }
}

/* Offline indicator */
.dm-offline-indicator {
  position: fixed;
  bottom: 24px;
  left: 24px;
  z-index: 1060;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--gray-800, #333);
  color: #fff;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s, transform 0.3s;
  pointer-events: none;
}
.dm-offline-indicator.dm-offline--show {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
.dm-offline-icon {
  flex-shrink: 0;
}
@media (max-width: 600px) {
  .dm-offline-indicator {
    bottom: 16px;
    left: 16px;
  }
}
</style>

<script>
(function() {
  'use strict';

  var DB_NAME = 'dm-notes';
  var DB_VERSION = 7;
  var STORE_NOTES = 'notes';
  var STORE_TODOS = 'todos';
  var STORE_META = 'meta';
  var STORE_WRITE_QUEUE = 'writeQueue';
  var STORE_VERSIONS = 'noteVersions';
  var STORE_ATTACHMENTS = 'attachments';
  var STORE_REVIEW_CARDS = 'reviewCards';
  var MAX_VERSIONS_PER_NOTE = 50;
  var MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB
  var SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes
  var _db = null;
  var _syncTimer = null;
  var _syncing = false;
  var _isOnline = navigator.onLine;
  var _draining = false;

  // ─── IndexedDB Wrapper ───

  function openDB() {
    return new Promise(function(resolve, reject) {
      if (_db) { resolve(_db); return; }
      var req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = function(e) {
        var db = e.target.result;
        var tx = e.target.transaction;
        if (!db.objectStoreNames.contains(STORE_NOTES)) {
          var store = db.createObjectStore(STORE_NOTES, { keyPath: 'id' });
          store.createIndex('destination', 'destination', { unique: false });
          store.createIndex('language', 'language', { unique: false });
          store.createIndex('bookTitle', 'bookTitle', { unique: false });
          store.createIndex('updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_META)) {
          db.createObjectStore(STORE_META, { keyPath: 'key' });
        }
        if (!db.objectStoreNames.contains(STORE_TODOS)) {
          var todoStore = db.createObjectStore(STORE_TODOS, { keyPath: 'id' });
          todoStore.createIndex('parentId', 'parentId', { unique: false });
          todoStore.createIndex('done', 'done', { unique: false });
          todoStore.createIndex('order', 'order', { unique: false });
          todoStore.createIndex('updatedAt', 'updatedAt', { unique: false });
          todoStore.createIndex('reminderAt', 'reminderAt', { unique: false });
        } else {
          // Upgrading existing todos store — add reminderAt index if missing
          var existingStore = tx.objectStore(STORE_TODOS);
          if (!existingStore.indexNames.contains('reminderAt')) {
            existingStore.createIndex('reminderAt', 'reminderAt', { unique: false });
          }
        }
        // Offline write queue store (v4)
        if (!db.objectStoreNames.contains(STORE_WRITE_QUEUE)) {
          db.createObjectStore(STORE_WRITE_QUEUE, { keyPath: 'queueId', autoIncrement: true });
        }
        // Note versions store (v5)
        if (!db.objectStoreNames.contains(STORE_VERSIONS)) {
          var versionStore = db.createObjectStore(STORE_VERSIONS, { keyPath: 'id' });
          versionStore.createIndex('noteId', 'noteId', { unique: false });
          versionStore.createIndex('createdAt', 'createdAt', { unique: false });
        }
        // Attachments store (v6)
        if (!db.objectStoreNames.contains(STORE_ATTACHMENTS)) {
          var attachStore = db.createObjectStore(STORE_ATTACHMENTS, { keyPath: 'id' });
          attachStore.createIndex('noteId', 'noteId', { unique: false });
          attachStore.createIndex('createdAt', 'createdAt', { unique: false });
        }
        // Review cards store (v7)
        if (!db.objectStoreNames.contains(STORE_REVIEW_CARDS)) {
          var reviewStore = db.createObjectStore(STORE_REVIEW_CARDS, { keyPath: 'id' });
          reviewStore.createIndex('noteId', 'noteId', { unique: false });
          reviewStore.createIndex('nextReviewAt', 'nextReviewAt', { unique: false });
        }
      };
      req.onsuccess = function(e) {
        _db = e.target.result;
        resolve(_db);
      };
      req.onerror = function(e) {
        console.error('IndexedDB open error:', e.target.error);
        reject(e.target.error);
      };
    });
  }

  function idbPut(storeName, data) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(data);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGet(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).get(key);
        req.onsuccess = function() { resolve(req.result); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbGetAll(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readonly');
        var req = tx.objectStore(storeName).getAll();
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbDelete(storeName, key) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbClear(storeName) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).clear();
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function idbPutBatch(storeName, items) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(storeName, 'readwrite');
        var store = tx.objectStore(storeName);
        items.forEach(function(item) { store.put(item); });
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  // ─── Offline Write Queue ───
  // Queues Firestore operations when offline; drains on reconnect.
  // Each queued entry: { collection, docId, op: 'set'|'update'|'delete', data, timestamp }

  function queueWrite(entry) {
    entry.timestamp = Date.now();
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).add(entry);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function getAllQueued() {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readonly');
        var req = tx.objectStore(STORE_WRITE_QUEUE).getAll();
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function removeQueued(queueId) {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).delete(queueId);
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  function clearQueue() {
    return openDB().then(function(db) {
      return new Promise(function(resolve, reject) {
        var tx = db.transaction(STORE_WRITE_QUEUE, 'readwrite');
        tx.objectStore(STORE_WRITE_QUEUE).clear();
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function(e) { reject(e.target.error); };
      });
    });
  }

  /**
   * Execute a Firestore write with offline queue fallback.
   * @param {Object} opts
   *   collection: string — 'notes' or 'todos'
   *   docId: string — document ID
   *   op: 'set'|'update'|'delete' — Firestore operation
   *   data: Object|null — data for set/update (null for delete)
   *   localOp: function|null — optional callback to apply optimistic IDB write immediately
   * @returns {Promise}
   */
  function firestoreWrite(opts) {
    // Always apply local operation first (optimistic)
    var localPromise = opts.localOp ? opts.localOp() : Promise.resolve();

    return localPromise.then(function() {
      if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser || !_isOnline) {
        // Offline or no Firestore — queue for later
        console.log('[dm-sync] Queuing offline write:', opts.op, opts.collection, opts.docId);
        return queueWrite({
          collection: opts.collection,
          docId: opts.docId,
          op: opts.op,
          data: opts.data || null
        }).then(function() {
          updateOfflineIndicator();
        });
      }

      // Online — try Firestore directly
      var ref = window.dmDb.collection(opts.collection).doc(opts.docId);
      var fsPromise;
      if (opts.op === 'set') {
        fsPromise = ref.set(opts.data);
      } else if (opts.op === 'update') {
        fsPromise = ref.update(opts.data);
      } else if (opts.op === 'delete') {
        fsPromise = ref.delete();
      } else {
        return Promise.reject(new Error('Unknown op: ' + opts.op));
      }

      return fsPromise.catch(function(err) {
        // Firestore write failed (maybe went offline mid-write) — queue it
        console.warn('[dm-sync] Firestore write failed, queuing:', err.message);
        return queueWrite({
          collection: opts.collection,
          docId: opts.docId,
          op: opts.op,
          data: opts.data || null
        }).then(function() {
          updateOfflineIndicator();
        });
      });
    });
  }

  /**
   * Drain the offline write queue. Called on reconnect.
   * Processes entries in FIFO order. If an entry fails, stops and retries later.
   */
  function drainQueue() {
    if (_draining) return Promise.resolve();
    if (!window.dmDb || !window.dmAuth || !window.dmAuth.currentUser || !_isOnline) {
      return Promise.resolve();
    }
    _draining = true;
    console.log('[dm-sync] Draining offline write queue...');

    return getAllQueued().then(function(entries) {
      if (entries.length === 0) {
        _draining = false;
        updateOfflineIndicator();
        return;
      }

      console.log('[dm-sync] Queue has ' + entries.length + ' pending write(s)');

      // Process sequentially to preserve order
      var chain = Promise.resolve();
      var processed = 0;
      var failed = false;

      entries.forEach(function(entry) {
        chain = chain.then(function() {
          if (failed) return; // stop on first failure

          var ref = window.dmDb.collection(entry.collection).doc(entry.docId);
          var fsPromise;
          if (entry.op === 'set') {
            fsPromise = ref.set(entry.data);
          } else if (entry.op === 'update') {
            fsPromise = ref.update(entry.data);
          } else if (entry.op === 'delete') {
            fsPromise = ref.delete();
          } else {
            // Unknown op — remove from queue
            return removeQueued(entry.queueId);
          }

          return fsPromise.then(function() {
            processed++;
            return removeQueued(entry.queueId);
          }).catch(function(err) {
            // Check if it's a "not found" error for update/delete — remove from queue
            if (err.code === 'not-found') {
              console.warn('[dm-sync] Doc not found, removing queued op:', entry.collection, entry.docId);
              return removeQueued(entry.queueId);
            }
            console.warn('[dm-sync] Queue drain failed at entry, will retry:', err.message);
            failed = true;
          });
        });
      });

      return chain.then(function() {
        _draining = false;
        console.log('[dm-sync] Queue drain complete. Processed: ' + processed + '/' + entries.length);
        updateOfflineIndicator();

        // If all succeeded, trigger a sync to reconcile
        if (!failed && processed > 0) {
          var user = window.dmAuth.currentUser;
          if (user) {
            syncAll(user.uid).catch(function() {});
          }
        }

        // If some failed, retry after a delay
        if (failed) {
          setTimeout(drainQueue, 10000);
        }
      });
    }).catch(function(err) {
      console.warn('[dm-sync] Queue drain error:', err);
      _draining = false;
    });
  }

  // ─── Online/Offline Detection ───

  function updateOfflineIndicator() {
    getAllQueued().then(function(entries) {
      var indicator = document.getElementById('dm-offline-indicator');
      if (!indicator) return;

      if (!_isOnline) {
        indicator.style.display = '';
        indicator.querySelector('.dm-offline-text').textContent = 'Offline' + (entries.length ? ' (' + entries.length + ' pending)' : '');
        indicator.classList.add('dm-offline--show');
      } else if (entries.length > 0) {
        indicator.style.display = '';
        indicator.querySelector('.dm-offline-text').textContent = 'Syncing ' + entries.length + ' change' + (entries.length > 1 ? 's' : '') + '...';
        indicator.classList.add('dm-offline--show');
      } else {
        indicator.classList.remove('dm-offline--show');
        setTimeout(function() { indicator.style.display = 'none'; }, 300);
      }
    }).catch(function() {});
  }

  window.addEventListener('online', function() {
    _isOnline = true;
    console.log('[dm-sync] Back online');
    updateOfflineIndicator();
    // Drain queue after a short delay to let network stabilize
    setTimeout(drainQueue, 1500);
  });

  window.addEventListener('offline', function() {
    _isOnline = false;
    console.log('[dm-sync] Gone offline');
    updateOfflineIndicator();
  });

  // ─── Firestore Document Serializer ───

  function serializeNote(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    return {
      id: doc.id,
      title: data.title || '',
      content: data.content || '',
      mode: data.mode || 'note',
      destination: data.destination || 'inbox',
      language: data.language || null,
      bookTitle: data.bookTitle || null,
      tags: data.tags || [],
      userId: data.userId || '',
      userEmail: data.userEmail || '',
      userName: data.userName || '',
      createdAt: createdAt,
      updatedAt: updatedAt
    };
  }

  function serializeTodo(doc) {
    var data = doc.data();
    var createdAt = data.createdAt ? data.createdAt.toMillis() : 0;
    var updatedAt = data.updatedAt ? data.updatedAt.toMillis() : 0;
    var completedAt = data.completedAt ? data.completedAt.toMillis() : null;
    var reminderAt = data.reminderAt ? data.reminderAt.toMillis() : null;
    return {
      id: doc.id,
      userId: data.userId || '',
      title: data.title || '',
      estimatedMin: data.estimatedMin || 0,
      actualMin: data.actualMin != null ? data.actualMin : null,
      category: data.category || null,
      done: !!data.done,
      parentId: data.parentId || null,
      order: data.order || 0,
      scheduledDate: data.scheduledDate || null,
      reminderAt: reminderAt,
      reminderFired: !!data.reminderFired,
      createdAt: createdAt,
      updatedAt: updatedAt,
      completedAt: completedAt
    };
  }

  // ─── Sync Engine ───

  function syncNotes(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Starting sync...');
    var startTime = Date.now();

    // Full sync: fetch all notes for user, diff with local
    return window.dmDb.collection('notes')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteNotes = [];
        snapshot.forEach(function(doc) {
          remoteNotes.push(serializeNote(doc));
        });

        return idbGetAll(STORE_NOTES).then(function(localNotes) {
          var localMap = {};
          localNotes.forEach(function(n) { localMap[n.id] = n; });

          var remoteMap = {};
          remoteNotes.forEach(function(n) { remoteMap[n.id] = n; });

          // Find notes to upsert (new or updated)
          var toUpsert = [];
          remoteNotes.forEach(function(rn) {
            var ln = localMap[rn.id];
            if (!ln || ln.updatedAt !== rn.updatedAt) {
              toUpsert.push(rn);
            }
          });

          // Find notes to delete locally (exist locally but not remotely)
          var toDelete = [];
          localNotes.forEach(function(ln) {
            if (!remoteMap[ln.id]) {
              toDelete.push(ln.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_NOTES, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_NOTES, id));
          });

          return Promise.all(promises).then(function() {
            return idbPut(STORE_META, { key: 'lastSyncTime', value: Date.now() });
          }).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Notes sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  function syncTodos(userId) {
    if (!window.dmDb) return Promise.reject(new Error('Firestore not available'));

    console.log('[dm-sync] Syncing todos...');
    var startTime = Date.now();

    return window.dmDb.collection('todos')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteTodos = [];
        snapshot.forEach(function(doc) {
          remoteTodos.push(serializeTodo(doc));
        });

        return idbGetAll(STORE_TODOS).then(function(localTodos) {
          var localMap = {};
          localTodos.forEach(function(t) { localMap[t.id] = t; });

          var remoteMap = {};
          remoteTodos.forEach(function(t) { remoteMap[t.id] = t; });

          var toUpsert = [];
          remoteTodos.forEach(function(rt) {
            var lt = localMap[rt.id];
            if (!lt || lt.updatedAt !== rt.updatedAt) {
              toUpsert.push(rt);
            }
          });

          var toDelete = [];
          localTodos.forEach(function(lt) {
            if (!remoteMap[lt.id]) {
              toDelete.push(lt.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_TODOS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_TODOS, id));
          });

          return Promise.all(promises).then(function() {
            var elapsed = Date.now() - startTime;
            console.log('[dm-sync] Todos sync complete in ' + elapsed + 'ms. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
            return { upserted: toUpsert.length, deleted: toDelete.length };
          });
        });
      });
  }

  // ─── Auto-purge expired trash ───

  function purgeExpiredTrash() {
    var thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
    var cutoff = Date.now() - thirtyDaysMs;
    return idbGetAll(STORE_NOTES).then(function(notes) {
      var expired = notes.filter(function(n) { return n.deletedAt && n.deletedAt < cutoff; });
      if (!expired.length) return Promise.resolve();
      console.log('[dm-sync] Purging ' + expired.length + ' expired trash items');
      return Promise.all(expired.map(function(n) {
        return firestoreWrite({
          collection: 'notes',
          docId: n.id,
          op: 'delete',
          data: null,
          localOp: function() { return idbDelete(STORE_NOTES, n.id); }
        });
      }));
    });
  }

  function syncAll(userId) {
    if (_syncing) return Promise.resolve();
    _syncing = true;

    return syncNotes(userId)
      .then(function() { return syncTodos(userId); })
      .then(function() { return syncVersions(userId); })
      .then(function() { return syncAttachments(userId); })
      .then(function() { return syncReviewCards(userId); })
      .then(function() {
        _syncing = false;
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        // Auto-purge expired trash (30+ days old) after sync
        purgeExpiredTrash().catch(function(err) {
          console.warn('[dm-sync] Trash purge error:', err);
        });
      })
      .catch(function(err) {
        console.error('[dm-sync] Sync error:', err);
        _syncing = false;
        throw err;
      });
  }

  function startBackgroundSync(userId) {
    stopBackgroundSync();
    _syncTimer = setInterval(function() {
      syncAll(userId).catch(function(err) {
        console.warn('[dm-sync] Background sync failed:', err);
      });
    }, SYNC_INTERVAL);
  }

  function stopBackgroundSync() {
    if (_syncTimer) {
      clearInterval(_syncTimer);
      _syncTimer = null;
    }
  }

  // ─── Reminder Timer Engine ───

  var _reminderTimers = {}; // todoId -> timeoutId
  var MAX_TIMEOUT = 2147483647; // 2^31 - 1 ms (~24.8 days)

  // ─── Notification Chime (Web Audio API) ───

  function playReminderChime() {
    try {
      var ctx = new (window.AudioContext || window.webkitAudioContext)();
      var notes = [
        { freq: 830, start: 0, dur: 0.12 },
        { freq: 1050, start: 0.13, dur: 0.12 },
        { freq: 1250, start: 0.26, dur: 0.18 }
      ];
      notes.forEach(function(n) {
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = n.freq;
        gain.gain.setValueAtTime(0.15, ctx.currentTime + n.start);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + n.start + n.dur);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + n.start);
        osc.stop(ctx.currentTime + n.start + n.dur + 0.05);
      });
      // Close context after sound finishes
      setTimeout(function() { ctx.close(); }, 600);
    } catch(e) {
      // Audio not available — silent fallback
    }
  }

  // ─── Persistent Reminder Banner ───

  function showReminderBanner(title, text) {
    var container = document.getElementById('dm-reminder-banner-container');
    if (!container) return;

    var banner = document.createElement('div');
    banner.className = 'dm-reminder-banner';
    banner.innerHTML =
      '<svg class="dm-reminder-banner-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">' +
        '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>' +
        '<path d="M13.73 21a2 2 0 0 1-3.46 0"/>' +
      '</svg>' +
      '<div class="dm-reminder-banner-body">' +
        '<span class="dm-reminder-banner-label"></span>' +
        '<span class="dm-reminder-banner-text"></span>' +
      '</div>' +
      '<button class="dm-reminder-banner-ack">Acknowledge</button>';

    // Set text content safely (no innerHTML for user data)
    banner.querySelector('.dm-reminder-banner-label').textContent = title;
    banner.querySelector('.dm-reminder-banner-text').textContent = text;

    container.appendChild(banner);

    // Slide down
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        banner.classList.add('dm-banner--in');
      });
    });

    // Acknowledge = dismiss
    banner.querySelector('.dm-reminder-banner-ack').addEventListener('click', function() {
      banner.classList.remove('dm-banner--in');
      banner.classList.add('dm-banner--out');
      setTimeout(function() {
        if (banner.parentNode) banner.parentNode.removeChild(banner);
      }, 450);
    });
  }

  function clearReminderTimer(todoId) {
    if (_reminderTimers[todoId]) {
      clearTimeout(_reminderTimers[todoId]);
      delete _reminderTimers[todoId];
    }
  }

  function clearAllReminderTimers() {
    Object.keys(_reminderTimers).forEach(function(id) {
      clearTimeout(_reminderTimers[id]);
    });
    _reminderTimers = {};
  }

  function buildReminderBody(todo) {
    var parts = [todo.title];
    if (todo.estimatedMin) parts.push(todo.estimatedMin + 'min');
    if (todo.scheduledDate) {
      var today = new Date(); today.setHours(0,0,0,0);
      var d = new Date(todo.scheduledDate + 'T00:00:00');
      var diff = Math.round((d - today) / 86400000);
      if (diff === 0) parts.push('Today');
      else if (diff === 1) parts.push('Tomorrow');
      else parts.push(todo.scheduledDate);
    }
    return parts.join(' \u2014 '); // em dash
  }

  function fireReminder(todo) {
    var body = buildReminderBody(todo);

    // Show persistent banner + play chime
    playReminderChime();
    showReminderBanner('Reminder:', body);

    // Mark as fired — optimistic local write + queued Firestore write
    todo.reminderFired = true;
    todo.updatedAt = Date.now();
    firestoreWrite({
      collection: 'todos',
      docId: todo.id,
      op: 'update',
      data: {
        reminderFired: true,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      },
      localOp: function() {
        return idbPut(STORE_TODOS, todo);
      }
    }).then(function() {
      window.dispatchEvent(new CustomEvent('dm-todos-updated'));
    });
  }

  function scheduleReminder(todo) {
    clearReminderTimer(todo.id);

    if (!todo.reminderAt || todo.reminderFired || todo.done) return;

    var now = Date.now();
    var delay = todo.reminderAt - now;

    if (delay <= 0) {
      // Overdue — fire immediately
      fireReminder(todo);
      return;
    }

    // Cap at MAX_TIMEOUT; for longer delays, re-schedule instead of firing early
    var actualDelay = Math.min(delay, MAX_TIMEOUT);
    _reminderTimers[todo.id] = setTimeout(function() {
      delete _reminderTimers[todo.id];
      // Re-check in case it was cancelled or fired
      idbGet(STORE_TODOS, todo.id).then(function(latest) {
        if (latest && !latest.reminderFired && !latest.done && latest.reminderAt) {
          // If reminder time is still in the future (delay was capped), re-schedule
          if (latest.reminderAt > Date.now()) {
            scheduleReminder(latest);
          } else {
            fireReminder(latest);
          }
        }
      });
    }, actualDelay);
  }

  function scheduleAllReminders() {
    clearAllReminderTimers();
    idbGetAll(STORE_TODOS).then(function(todos) {
      todos.forEach(function(t) {
        if (t.reminderAt && !t.reminderFired && !t.done) {
          scheduleReminder(t);
        }
      });
    }).catch(function(err) {
      console.warn('[dm-sync] Failed to schedule reminders:', err);
    });
  }

  // Re-evaluate timers when todos change
  window.addEventListener('dm-todos-updated', function() {
    scheduleAllReminders();
  });

  // ─── Note Version History ───

  /**
   * Save a snapshot of the current note state as a version.
   * Called BEFORE applying new edits so the "previous" state is preserved.
   * @param {Object} note — the note object (current state before edit)
   * @returns {Promise}
   */
  function saveNoteVersion(note) {
    if (!note || !note.id) return Promise.resolve();

    var user = window.dmAuth && window.dmAuth.currentUser;
    if (!user) return Promise.resolve();

    var versionId = window.dmDb
      ? window.dmDb.collection('noteVersions').doc().id
      : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));

    var now = Date.now();
    var versionData = {
      userId: user.uid,
      noteId: note.id,
      title: note.title || '',
      content: note.content || '',
      tags: note.tags ? note.tags.slice() : [],
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };

    var localVersion = {
      id: versionId,
      userId: user.uid,
      noteId: note.id,
      title: note.title || '',
      content: note.content || '',
      tags: note.tags ? note.tags.slice() : [],
      createdAt: now
    };

    return firestoreWrite({
      collection: 'noteVersions',
      docId: versionId,
      op: 'set',
      data: versionData,
      localOp: function() { return idbPut(STORE_VERSIONS, localVersion); }
    }).then(function() {
      // Prune old versions beyond MAX_VERSIONS_PER_NOTE
      return pruneVersions(note.id);
    }).catch(function(err) {
      console.warn('[dm-sync] Version save failed (non-blocking):', err);
    });
  }

  /**
   * Remove oldest versions beyond MAX_VERSIONS_PER_NOTE for a given note.
   */
  function pruneVersions(noteId) {
    return getVersionsForNote(noteId).then(function(versions) {
      if (versions.length <= MAX_VERSIONS_PER_NOTE) return;

      // versions are sorted newest first — remove excess from the end
      var toDelete = versions.slice(MAX_VERSIONS_PER_NOTE);
      var chain = Promise.resolve();
      toDelete.forEach(function(v) {
        chain = chain.then(function() {
          return firestoreWrite({
            collection: 'noteVersions',
            docId: v.id,
            op: 'delete',
            data: null,
            localOp: function() { return idbDelete(STORE_VERSIONS, v.id); }
          });
        });
      });
      return chain;
    });
  }

  /**
   * Get all versions for a note, sorted newest first.
   */
  function getVersionsForNote(noteId) {
    return idbGetAll(STORE_VERSIONS).then(function(all) {
      return all.filter(function(v) { return v.noteId === noteId; })
        .sort(function(a, b) { return (b.createdAt || 0) - (a.createdAt || 0); });
    });
  }

  /**
   * Sync versions from Firestore for a given user (called during full sync).
   */
  function syncVersions(userId) {
    if (!window.dmDb) return Promise.resolve();

    console.log('[dm-sync] Syncing note versions...');
    return window.dmDb.collection('noteVersions')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteVersions = [];
        snapshot.forEach(function(doc) {
          var data = doc.data();
          remoteVersions.push({
            id: doc.id,
            userId: data.userId || '',
            noteId: data.noteId || '',
            title: data.title || '',
            content: data.content || '',
            tags: data.tags || [],
            createdAt: data.createdAt ? data.createdAt.toMillis() : 0
          });
        });

        return idbGetAll(STORE_VERSIONS).then(function(localVersions) {
          var localMap = {};
          localVersions.forEach(function(v) { localMap[v.id] = v; });

          var remoteMap = {};
          remoteVersions.forEach(function(v) { remoteMap[v.id] = v; });

          // Upsert remote versions
          var toUpsert = [];
          remoteVersions.forEach(function(rv) {
            var lv = localMap[rv.id];
            if (!lv || lv.createdAt !== rv.createdAt) {
              toUpsert.push(rv);
            }
          });

          // Delete local versions that no longer exist remotely
          var toDelete = [];
          localVersions.forEach(function(lv) {
            if (!remoteMap[lv.id]) {
              toDelete.push(lv.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_VERSIONS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_VERSIONS, id));
          });

          return Promise.all(promises).then(function() {
            console.log('[dm-sync] Versions sync complete. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
          });
        });
      });
  }

  // ─── Attachments ───

  function serializeAttachment(doc) {
    var data = doc.data();
    return {
      id: doc.id,
      userId: data.userId || '',
      noteId: data.noteId || '',
      fileName: data.fileName || '',
      fileType: data.fileType || '',
      fileSize: data.fileSize || 0,
      storagePath: data.storagePath || '',
      downloadUrl: data.downloadUrl || '',
      createdAt: data.createdAt ? data.createdAt.toMillis() : 0
    };
  }

  /**
   * Upload a file to Firebase Storage and create attachment metadata in Firestore.
   * @param {string} noteId — the note this attachment belongs to
   * @param {File} file — the File object to upload
   * @param {function} onProgress — optional callback(percent) for upload progress
   * @returns {Promise<Object>} — the attachment metadata object
   */
  function uploadAttachment(noteId, file, onProgress) {
    var user = window.dmAuth && window.dmAuth.currentUser;
    if (!user) return Promise.reject(new Error('Not authenticated'));
    if (!window.dmStorage) return Promise.reject(new Error('Storage not available'));

    if (file.size > MAX_FILE_SIZE) {
      return Promise.reject(new Error('File too large (max 10 MB)'));
    }

    // Generate unique filename to avoid collisions
    var timestamp = Date.now();
    var safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
    var storagePath = 'users/' + user.uid + '/attachments/' + noteId + '/' + timestamp + '-' + safeName;
    var storageRef = window.dmStorage.ref(storagePath);

    return new Promise(function(resolve, reject) {
      var uploadTask = storageRef.put(file);

      uploadTask.on('state_changed',
        function(snapshot) {
          if (onProgress) {
            var pct = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100);
            onProgress(pct);
          }
        },
        function(error) {
          console.error('[dm-sync] Upload error:', error);
          reject(error);
        },
        function() {
          // Upload complete — get download URL
          uploadTask.snapshot.ref.getDownloadURL().then(function(downloadUrl) {
            // Create attachment metadata in Firestore
            var attachId = window.dmDb
              ? window.dmDb.collection('attachments').doc().id
              : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));

            var now = Date.now();
            var attachData = {
              userId: user.uid,
              noteId: noteId,
              fileName: file.name,
              fileType: file.type || 'application/octet-stream',
              fileSize: file.size,
              storagePath: storagePath,
              downloadUrl: downloadUrl,
              createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            var localAttach = {
              id: attachId,
              userId: user.uid,
              noteId: noteId,
              fileName: file.name,
              fileType: file.type || 'application/octet-stream',
              fileSize: file.size,
              storagePath: storagePath,
              downloadUrl: downloadUrl,
              createdAt: now
            };

            firestoreWrite({
              collection: 'attachments',
              docId: attachId,
              op: 'set',
              data: attachData,
              localOp: function() { return idbPut(STORE_ATTACHMENTS, localAttach); }
            }).then(function() {
              window.dispatchEvent(new CustomEvent('dm-attachments-updated', { detail: { noteId: noteId } }));
              resolve(localAttach);
            }).catch(function(err) {
              reject(err);
            });
          }).catch(function(err) {
            reject(err);
          });
        }
      );
    });
  }

  /**
   * Get all attachments for a note, sorted newest first.
   */
  function getAttachmentsForNote(noteId) {
    return idbGetAll(STORE_ATTACHMENTS).then(function(all) {
      return all.filter(function(a) { return a.noteId === noteId; })
        .sort(function(a, b) { return (b.createdAt || 0) - (a.createdAt || 0); });
    });
  }

  /**
   * Delete an attachment: remove from Storage, Firestore, and IDB.
   */
  function deleteAttachment(attachment) {
    if (!attachment) return Promise.resolve();

    // Delete from Firebase Storage
    var storagePromise = Promise.resolve();
    if (window.dmStorage && attachment.storagePath && _isOnline) {
      var ref = window.dmStorage.ref(attachment.storagePath);
      storagePromise = ref.delete().catch(function(err) {
        // Ignore 'object-not-found' — file may already be deleted
        if (err.code !== 'storage/object-not-found') {
          console.warn('[dm-sync] Storage delete error:', err);
        }
      });
    }

    // Delete metadata from Firestore + IDB
    return storagePromise.then(function() {
      return firestoreWrite({
        collection: 'attachments',
        docId: attachment.id,
        op: 'delete',
        data: null,
        localOp: function() { return idbDelete(STORE_ATTACHMENTS, attachment.id); }
      });
    }).then(function() {
      window.dispatchEvent(new CustomEvent('dm-attachments-updated', { detail: { noteId: attachment.noteId } }));
    });
  }

  /**
   * Delete all attachments for a note.
   */
  function deleteAttachmentsForNote(noteId) {
    return getAttachmentsForNote(noteId).then(function(attachments) {
      var chain = Promise.resolve();
      attachments.forEach(function(a) {
        chain = chain.then(function() { return deleteAttachment(a); });
      });
      return chain;
    });
  }

  /**
   * Sync attachments from Firestore for a given user.
   */
  function syncAttachments(userId) {
    if (!window.dmDb) return Promise.resolve();

    console.log('[dm-sync] Syncing attachments...');
    return window.dmDb.collection('attachments')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteAttachments = [];
        snapshot.forEach(function(doc) {
          remoteAttachments.push(serializeAttachment(doc));
        });

        return idbGetAll(STORE_ATTACHMENTS).then(function(localAttachments) {
          var localMap = {};
          localAttachments.forEach(function(a) { localMap[a.id] = a; });

          var remoteMap = {};
          remoteAttachments.forEach(function(a) { remoteMap[a.id] = a; });

          var toUpsert = [];
          remoteAttachments.forEach(function(ra) {
            var la = localMap[ra.id];
            if (!la || la.createdAt !== ra.createdAt) {
              toUpsert.push(ra);
            }
          });

          var toDelete = [];
          localAttachments.forEach(function(la) {
            if (!remoteMap[la.id]) {
              toDelete.push(la.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_ATTACHMENTS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_ATTACHMENTS, id));
          });

          return Promise.all(promises).then(function() {
            console.log('[dm-sync] Attachments sync complete. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
          });
        });
      });
  }

  // ─── Spaced Repetition (SM-2 Algorithm) ───

  /**
   * SM-2 algorithm implementation.
   * @param {number} quality — 0-5 rating (0=blackout, 5=perfect)
   * @param {number} repetitions — current successful-review count
   * @param {number} easeFactor — current ease factor (min 1.3)
   * @param {number} interval — current interval in days
   * @returns {Object} - { repetitions, easeFactor, interval, nextReviewAt }
   */
  function sm2(quality, repetitions, easeFactor, interval) {
    var newEF = easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
    if (newEF < 1.3) newEF = 1.3;

    var newReps, newInterval;
    if (quality >= 3) {
      // Correct response
      newReps = repetitions + 1;
      if (newReps === 1) {
        newInterval = 1;
      } else if (newReps === 2) {
        newInterval = 6;
      } else {
        newInterval = Math.round(interval * newEF);
      }
    } else {
      // Incorrect — reset
      newReps = 0;
      newInterval = 1;
    }

    var now = new Date();
    var nextDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + newInterval);
    nextDate.setHours(0, 0, 0, 0);

    return {
      repetitions: newReps,
      easeFactor: Math.round(newEF * 100) / 100,
      interval: newInterval,
      nextReviewAt: nextDate.getTime()
    };
  }

  function serializeReviewCard(doc) {
    var data = doc.data();
    return {
      id: doc.id,
      noteId: data.noteId || '',
      userId: data.userId || '',
      easeFactor: data.easeFactor != null ? data.easeFactor : 2.5,
      interval: data.interval || 0,
      repetitions: data.repetitions || 0,
      nextReviewAt: data.nextReviewAt ? data.nextReviewAt.toMillis() : 0,
      lastReviewedAt: data.lastReviewedAt ? data.lastReviewedAt.toMillis() : null,
      createdAt: data.createdAt ? data.createdAt.toMillis() : 0,
      updatedAt: data.updatedAt ? data.updatedAt.toMillis() : 0
    };
  }

  /**
   * Create a review card for a note (opt-in).
   * First review is immediately due (nextReviewAt = now).
   */
  function createReviewCard(noteId) {
    var user = window.dmAuth && window.dmAuth.currentUser;
    if (!user) return Promise.reject(new Error('Not authenticated'));

    // Check if card already exists for this note
    return getReviewCardForNote(noteId).then(function(existing) {
      if (existing) return existing; // already enrolled

      var cardId = window.dmDb
        ? window.dmDb.collection('reviewCards').doc().id
        : ('local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));

      var now = Date.now();
      var localCard = {
        id: cardId,
        noteId: noteId,
        userId: user.uid,
        easeFactor: 2.5,
        interval: 0,
        repetitions: 0,
        nextReviewAt: now, // due immediately
        lastReviewedAt: null,
        createdAt: now,
        updatedAt: now
      };

      var fsData = {
        noteId: noteId,
        userId: user.uid,
        easeFactor: 2.5,
        interval: 0,
        repetitions: 0,
        nextReviewAt: firebase.firestore.Timestamp.fromMillis(now),
        lastReviewedAt: null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };

      return firestoreWrite({
        collection: 'reviewCards',
        docId: cardId,
        op: 'set',
        data: fsData,
        localOp: function() { return idbPut(STORE_REVIEW_CARDS, localCard); }
      }).then(function() {
        window.dispatchEvent(new CustomEvent('dm-review-updated'));
        return localCard;
      });
    });
  }

  /**
   * Submit a review rating for a card. Applies SM-2 to compute next interval.
   * @param {string} cardId
   * @param {number} quality — 0-5
   */
  function reviewCard(cardId, quality) {
    return idbGet(STORE_REVIEW_CARDS, cardId).then(function(card) {
      if (!card) return Promise.reject(new Error('Card not found'));

      var result = sm2(quality, card.repetitions, card.easeFactor, card.interval);
      var now = Date.now();

      card.easeFactor = result.easeFactor;
      card.interval = result.interval;
      card.repetitions = result.repetitions;
      card.nextReviewAt = result.nextReviewAt;
      card.lastReviewedAt = now;
      card.updatedAt = now;

      return firestoreWrite({
        collection: 'reviewCards',
        docId: card.id,
        op: 'update',
        data: {
          easeFactor: card.easeFactor,
          interval: card.interval,
          repetitions: card.repetitions,
          nextReviewAt: firebase.firestore.Timestamp.fromMillis(card.nextReviewAt),
          lastReviewedAt: firebase.firestore.Timestamp.fromMillis(now),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        },
        localOp: function() { return idbPut(STORE_REVIEW_CARDS, card); }
      }).then(function() {
        window.dispatchEvent(new CustomEvent('dm-review-updated'));
        return card;
      });
    });
  }

  /**
   * Remove a note from the review system.
   */
  function deleteReviewCard(cardId) {
    return firestoreWrite({
      collection: 'reviewCards',
      docId: cardId,
      op: 'delete',
      data: null,
      localOp: function() { return idbDelete(STORE_REVIEW_CARDS, cardId); }
    }).then(function() {
      window.dispatchEvent(new CustomEvent('dm-review-updated'));
    });
  }

  /**
   * Get the review card for a specific note (if enrolled).
   */
  function getReviewCardForNote(noteId) {
    return idbGetAll(STORE_REVIEW_CARDS).then(function(cards) {
      for (var i = 0; i < cards.length; i++) {
        if (cards[i].noteId === noteId) return cards[i];
      }
      return null;
    });
  }

  /**
   * Get all review cards, optionally only those due for review.
   * @param {boolean} dueOnly — if true, only return cards where nextReviewAt <= now
   */
  function getReviewCards(dueOnly) {
    var now = Date.now();
    return idbGetAll(STORE_REVIEW_CARDS).then(function(cards) {
      if (dueOnly) {
        cards = cards.filter(function(c) { return c.nextReviewAt <= now; });
      }
      // Sort: due soonest first
      return cards.sort(function(a, b) { return (a.nextReviewAt || 0) - (b.nextReviewAt || 0); });
    });
  }

  /**
   * Get count of cards due for review right now.
   */
  function getDueCount() {
    var now = Date.now();
    return idbGetAll(STORE_REVIEW_CARDS).then(function(cards) {
      return cards.filter(function(c) { return c.nextReviewAt <= now; }).length;
    });
  }

  /**
   * Sync review cards from Firestore.
   */
  function syncReviewCards(userId) {
    if (!window.dmDb) return Promise.resolve();

    console.log('[dm-sync] Syncing review cards...');
    return window.dmDb.collection('reviewCards')
      .where('userId', '==', userId)
      .get()
      .then(function(snapshot) {
        var remoteCards = [];
        snapshot.forEach(function(doc) {
          remoteCards.push(serializeReviewCard(doc));
        });

        return idbGetAll(STORE_REVIEW_CARDS).then(function(localCards) {
          var localMap = {};
          localCards.forEach(function(c) { localMap[c.id] = c; });

          var remoteMap = {};
          remoteCards.forEach(function(c) { remoteMap[c.id] = c; });

          var toUpsert = [];
          remoteCards.forEach(function(rc) {
            var lc = localMap[rc.id];
            if (!lc || lc.updatedAt !== rc.updatedAt) {
              toUpsert.push(rc);
            }
          });

          var toDelete = [];
          localCards.forEach(function(lc) {
            if (!remoteMap[lc.id]) {
              toDelete.push(lc.id);
            }
          });

          var promises = [];
          if (toUpsert.length > 0) {
            promises.push(idbPutBatch(STORE_REVIEW_CARDS, toUpsert));
          }
          toDelete.forEach(function(id) {
            promises.push(idbDelete(STORE_REVIEW_CARDS, id));
          });

          return Promise.all(promises).then(function() {
            console.log('[dm-sync] Review cards sync complete. Upserted: ' + toUpsert.length + ', Deleted: ' + toDelete.length);
          });
        });
      });
  }

  // ─── Public API ───

  // Helper: get all non-trashed notes from IDB
  function getActiveNotes() {
    return idbGetAll(STORE_NOTES).then(function(notes) {
      return notes.filter(function(n) { return !n.deletedAt; });
    });
  }

  window.dmSync = {
    // IndexedDB operations — Notes
    getNote: function(id) {
      return idbGet(STORE_NOTES, id).then(function(note) {
        if (note && note.deletedAt) return null;
        return note;
      });
    },
    getNoteIncludingTrashed: function(id) { return idbGet(STORE_NOTES, id); },
    getAllNotes: function() { return getActiveNotes(); },
    putNote: function(note) {
      return idbPut(STORE_NOTES, note).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    deleteNote: function(id) {
      return idbDelete(STORE_NOTES, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    // Soft-delete: move note to trash
    trashNote: function(id) {
      return idbGet(STORE_NOTES, id).then(function(note) {
        if (!note) return;
        note.deletedAt = Date.now();
        note.updatedAt = Date.now();
        return idbPut(STORE_NOTES, note).then(function() {
          window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        });
      });
    },
    // Restore a trashed note
    restoreNote: function(id) {
      return idbGet(STORE_NOTES, id).then(function(note) {
        if (!note) return;
        delete note.deletedAt;
        note.updatedAt = Date.now();
        return idbPut(STORE_NOTES, note).then(function() {
          window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        });
      });
    },
    // Get all trashed notes
    getTrashedNotes: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        return notes.filter(function(n) { return !!n.deletedAt; });
      });
    },
    // Permanently delete a trashed note from IDB
    permanentlyDeleteNote: function(id) {
      return idbDelete(STORE_NOTES, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    // Empty all trashed notes permanently
    emptyTrash: function() {
      return idbGetAll(STORE_NOTES).then(function(notes) {
        var trashed = notes.filter(function(n) { return !!n.deletedAt; });
        return Promise.all(trashed.map(function(n) { return idbDelete(STORE_NOTES, n.id); }));
      }).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },
    // Auto-purge notes trashed more than 30 days ago
    purgeExpiredTrash: function() {
      return purgeExpiredTrash().then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
      });
    },

    // IndexedDB operations — Todos
    getTodo: function(id) { return idbGet(STORE_TODOS, id); },
    getAllTodos: function() { return idbGetAll(STORE_TODOS); },
    putTodo: function(todo) {
      return idbPut(STORE_TODOS, todo).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    deleteTodo: function(id) {
      return idbDelete(STORE_TODOS, id).then(function() {
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
      });
    },
    getTodosByParent: function(parentId) {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return t.parentId === parentId; });
      });
    },
    getTopLevelTodos: function() {
      return idbGetAll(STORE_TODOS).then(function(todos) {
        return todos.filter(function(t) { return !t.parentId; });
      });
    },
    setReminder: function(todoId, reminderAtMs) {
      return idbGet(STORE_TODOS, todoId).then(function(todo) {
        if (!todo) return;
        todo.reminderAt = reminderAtMs;
        todo.reminderFired = false;
        todo.updatedAt = Date.now();
        return firestoreWrite({
          collection: 'todos',
          docId: todoId,
          op: 'update',
          data: {
            reminderAt: firebase.firestore.Timestamp.fromMillis(reminderAtMs),
            reminderFired: false,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          },
          localOp: function() {
            return idbPut(STORE_TODOS, todo);
          }
        }).then(function() {
          scheduleReminder(todo);
          window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        });
      });
    },
    clearReminder: function(todoId) {
      clearReminderTimer(todoId);
      return idbGet(STORE_TODOS, todoId).then(function(todo) {
        if (!todo) return;
        todo.reminderAt = null;
        todo.reminderFired = false;
        todo.updatedAt = Date.now();
        return firestoreWrite({
          collection: 'todos',
          docId: todoId,
          op: 'update',
          data: {
            reminderAt: null,
            reminderFired: false,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          },
          localOp: function() {
            return idbPut(STORE_TODOS, todo);
          }
        }).then(function() {
          window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        });
      });
    },

    // Query helpers — Notes
    getNotesByDestination: function(destination) {
      return getActiveNotes().then(function(notes) {
        return notes.filter(function(n) { return n.destination === destination; });
      });
    },
    getNotesByLanguage: function(language) {
      return getActiveNotes().then(function(notes) {
        return notes.filter(function(n) { return n.language === language; });
      });
    },
    getNotesByBookTitle: function(bookTitle) {
      return getActiveNotes().then(function(notes) {
        return notes.filter(function(n) { return n.bookTitle === bookTitle; });
      });
    },
    getBookTitles: function() {
      return getActiveNotes().then(function(notes) {
        var titles = {};
        notes.forEach(function(n) {
          if (n.destination === 'book-note' && n.bookTitle) {
            titles[n.bookTitle] = true;
          }
        });
        return Object.keys(titles).sort();
      });
    },
    getSnippetLanguages: function() {
      return getActiveNotes().then(function(notes) {
        var langs = {};
        notes.forEach(function(n) {
          if (n.destination === 'snippets' && n.language) {
            langs[n.language] = true;
          }
        });
        return Object.keys(langs).sort();
      });
    },

    // Query helpers — Tags
    getAllTags: function() {
      return getActiveNotes().then(function(notes) {
        var tagMap = {};
        notes.forEach(function(n) {
          if (n.tags && n.tags.length) {
            n.tags.forEach(function(t) {
              if (!tagMap[t]) tagMap[t] = 0;
              tagMap[t]++;
            });
          }
        });
        return Object.keys(tagMap).map(function(tag) {
          return { tag: tag, count: tagMap[tag] };
        }).sort(function(a, b) { return b.count - a.count || a.tag.localeCompare(b.tag); });
      });
    },
    getNotesByTag: function(tag) {
      return getActiveNotes().then(function(notes) {
        return notes.filter(function(n) {
          return n.tags && n.tags.indexOf(tag) !== -1;
        });
      });
    },

    // Query helpers — Backlinks
    getBacklinksForNote: function(noteId) {
      return getActiveNotes().then(function(notes) {
        var targetNote = null;
        notes.forEach(function(n) { if (n.id === noteId) targetNote = n; });
        if (!targetNote || !targetNote.title) return [];

        var results = [];
        var titleLower = targetNote.title.toLowerCase();
        var escapedTitle = targetNote.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var wikilinkPattern = new RegExp('\\[\\[' + escapedTitle + '\\]\\]', 'i');

        notes.forEach(function(n) {
          if (n.id === noteId) return;
          if (!n.content) return;

          var isExplicit = wikilinkPattern.test(n.content);
          var isTitleMatch = !isExplicit && titleLower.length > 3 && n.content.toLowerCase().indexOf(titleLower) !== -1;

          if (isExplicit || isTitleMatch) {
            results.push({
              note: n,
              type: isExplicit ? 'wikilink' : 'mention',
              confidence: isExplicit ? 'high' : 'medium'
            });
          }
        });

        return results.sort(function(a, b) {
          if (a.type !== b.type) return a.type === 'wikilink' ? -1 : 1;
          return (b.note.updatedAt || 0) - (a.note.updatedAt || 0);
        });
      });
    },

    // Sync operations
    sync: function(userId) { return syncAll(userId); },
    syncNotes: function(userId) { return syncNotes(userId); },
    syncTodos: function(userId) { return syncTodos(userId); },
    startBackgroundSync: startBackgroundSync,
    stopBackgroundSync: stopBackgroundSync,

    // Check if cache has data
    hasCachedData: function() {
      return getActiveNotes().then(function(notes) {
        return notes.length > 0;
      });
    },

    // Clear cache (on logout)
    clearCache: function() {
      stopBackgroundSync();
      return Promise.all([
        idbClear(STORE_NOTES),
        idbClear(STORE_TODOS),
        idbClear(STORE_META),
        idbClear(STORE_VERSIONS),
        idbClear(STORE_ATTACHMENTS),
        idbClear(STORE_REVIEW_CARDS),
        clearQueue()
      ]).then(function() {
        window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        window.dispatchEvent(new CustomEvent('dm-todos-updated'));
        updateOfflineIndicator();
      });
    },

    // Offline write support
    firestoreWrite: firestoreWrite,
    drainQueue: drainQueue,
    isOnline: function() { return _isOnline; },
    getQueuedCount: function() {
      return getAllQueued().then(function(entries) { return entries.length; });
    },

    // Reminder banner (for use by other partials)
    showReminderBanner: showReminderBanner,

    // Note version history
    saveNoteVersion: saveNoteVersion,
    getVersionsForNote: getVersionsForNote,
    deleteVersion: function(versionId) {
      return firestoreWrite({
        collection: 'noteVersions',
        docId: versionId,
        op: 'delete',
        data: null,
        localOp: function() { return idbDelete(STORE_VERSIONS, versionId); }
      });
    },

    // Attachments
    uploadAttachment: uploadAttachment,
    getAttachmentsForNote: getAttachmentsForNote,
    deleteAttachment: deleteAttachment,
    deleteAttachmentsForNote: deleteAttachmentsForNote,

    // Spaced repetition / review
    createReviewCard: createReviewCard,
    reviewCard: reviewCard,
    deleteReviewCard: deleteReviewCard,
    getReviewCardForNote: getReviewCardForNote,
    getReviewCards: getReviewCards,
    getDueCount: getDueCount
  };

  // ─── Auto-sync on Auth State Change ───

  if (window.dmAuth) {
    window.dmAuth.onAuthStateChanged(function(user) {
      if (user) {
        // Check if this is a different user than last cached session
        idbGet(STORE_META, 'currentUserId').then(function(meta) {
          var cachedUserId = meta ? meta.value : null;
          var proceed = cachedUserId === user.uid
            ? Promise.resolve()
            : Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META), idbClear(STORE_VERSIONS), idbClear(STORE_ATTACHMENTS), idbClear(STORE_REVIEW_CARDS), clearQueue()]);

          return proceed.then(function() {
            return idbPut(STORE_META, { key: 'currentUserId', value: user.uid });
          }).then(function() {
            // Drain any queued offline writes before syncing
            return drainQueue();
          }).then(function() {
            return syncAll(user.uid);
          }).then(function() {
            startBackgroundSync(user.uid);
            scheduleAllReminders();
            updateOfflineIndicator();
          });
        }).catch(function(err) {
          console.warn('[dm-sync] Initial sync failed, using cached data if available');
          window.dispatchEvent(new CustomEvent('dm-sync-complete'));
        });
      } else {
        stopBackgroundSync();
        clearAllReminderTimers();
        // Clear cache on sign-out so no data leaks to another user
        Promise.all([idbClear(STORE_NOTES), idbClear(STORE_TODOS), idbClear(STORE_META), idbClear(STORE_VERSIONS), idbClear(STORE_ATTACHMENTS), idbClear(STORE_REVIEW_CARDS), clearQueue()])
          .then(function() {
            window.dispatchEvent(new CustomEvent('dm-sync-complete'));
            window.dispatchEvent(new CustomEvent('dm-todos-updated'));
          })
          .catch(function(err) {
            console.warn('[dm-sync] Error clearing cache on sign-out:', err);
          });
      }
    });
  }

})();
</script>
